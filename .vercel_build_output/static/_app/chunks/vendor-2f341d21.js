var Fx=Object.defineProperty,kx=Object.defineProperties;var Ox=Object.getOwnPropertyDescriptors;var Ih=Object.getOwnPropertySymbols;var Bx=Object.prototype.hasOwnProperty,zx=Object.prototype.propertyIsEnumerable;var Fh=(c,t,e)=>t in c?Fx(c,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):c[t]=e,Qs=(c,t)=>{for(var e in t||(t={}))Bx.call(t,e)&&Fh(c,e,t[e]);if(Ih)for(var e of Ih(t))zx.call(t,e)&&Fh(c,e,t[e]);return c},il=(c,t)=>kx(c,Ox(t));function tr(){}function Nx(c,t){for(const e in t)c[e]=t[e];return c}function kh(c){return c()}function Oh(){return Object.create(null)}function er(c){c.forEach(kh)}function Vx(c){return typeof c=="function"}function Ux(c,t){return c!=c?t==t:c!==t||c&&typeof c=="object"||typeof c=="function"}function Hx(c){return Object.keys(c).length===0}function oT(c,t,e,s){if(c){const a=Bh(c,t,e,s);return c[0](a)}}function Bh(c,t,e,s){return c[1]&&s?Nx(e.ctx.slice(),c[1](s(t))):e.ctx}function aT(c,t,e,s){if(c[2]&&s){const a=c[2](s(e));if(t.dirty===void 0)return a;if(typeof a=="object"){const h=[],d=Math.max(t.dirty.length,a.length);for(let p=0;p<d;p+=1)h[p]=t.dirty[p]|a[p];return h}return t.dirty|a}return t.dirty}function lT(c,t,e,s,a,h){if(a){const d=Bh(t,e,s,h);c.p(d,a)}}function cT(c){if(c.ctx.length>32){const t=[],e=c.ctx.length/32;for(let s=0;s<e;s++)t[s]=-1;return t}return-1}let uo=!1;function Wx(){uo=!0}function Gx(){uo=!1}function Xx(c,t,e,s){for(;c<t;){const a=c+(t-c>>1);e(a)<=s?c=a+1:t=a}return c}function jx(c){if(c.hydrate_init)return;c.hydrate_init=!0;let t=c.childNodes;if(c.nodeName==="HEAD"){const g=[];for(let _=0;_<t.length;_++){const v=t[_];v.claim_order!==void 0&&g.push(v)}t=g}const e=new Int32Array(t.length+1),s=new Int32Array(t.length);e[0]=-1;let a=0;for(let g=0;g<t.length;g++){const _=t[g].claim_order,v=(a>0&&t[e[a]].claim_order<=_?a+1:Xx(1,a,M=>t[e[M]].claim_order,_))-1;s[g]=e[v]+1;const b=v+1;e[b]=g,a=Math.max(b,a)}const h=[],d=[];let p=t.length-1;for(let g=e[a]+1;g!=0;g=s[g-1]){for(h.push(t[g-1]);p>=g;p--)d.push(t[p]);p--}for(;p>=0;p--)d.push(t[p]);h.reverse(),d.sort((g,_)=>g.claim_order-_.claim_order);for(let g=0,_=0;g<d.length;g++){for(;_<h.length&&d[g].claim_order>=h[_].claim_order;)_++;const v=_<h.length?h[_]:null;c.insertBefore(d[g],v)}}function qx(c,t){if(uo){for(jx(c),(c.actual_end_child===void 0||c.actual_end_child!==null&&c.actual_end_child.parentElement!==c)&&(c.actual_end_child=c.firstChild);c.actual_end_child!==null&&c.actual_end_child.claim_order===void 0;)c.actual_end_child=c.actual_end_child.nextSibling;t!==c.actual_end_child?(t.claim_order!==void 0||t.parentNode!==c)&&c.insertBefore(t,c.actual_end_child):c.actual_end_child=t.nextSibling}else(t.parentNode!==c||t.nextSibling!==null)&&c.appendChild(t)}function uT(c,t,e){uo&&!e?qx(c,t):(t.parentNode!==c||t.nextSibling!=e)&&c.insertBefore(t,e||null)}function Yx(c){c.parentNode.removeChild(c)}function hT(c,t){for(let e=0;e<c.length;e+=1)c[e]&&c[e].d(t)}function $x(c){return document.createElement(c)}function sl(c){return document.createTextNode(c)}function dT(){return sl(" ")}function fT(){return sl("")}function pT(c,t,e,s){return c.addEventListener(t,e,s),()=>c.removeEventListener(t,e,s)}function mT(c,t,e){e==null?c.removeAttribute(t):c.getAttribute(t)!==e&&c.setAttribute(t,e)}function gT(c){return c===""?null:+c}function Zx(c){return Array.from(c.childNodes)}function Jx(c){c.claim_info===void 0&&(c.claim_info={last_index:0,total_claimed:0})}function zh(c,t,e,s,a=!1){Jx(c);const h=(()=>{for(let d=c.claim_info.last_index;d<c.length;d++){const p=c[d];if(t(p)){const g=e(p);return g===void 0?c.splice(d,1):c[d]=g,a||(c.claim_info.last_index=d),p}}for(let d=c.claim_info.last_index-1;d>=0;d--){const p=c[d];if(t(p)){const g=e(p);return g===void 0?c.splice(d,1):c[d]=g,a?g===void 0&&c.claim_info.last_index--:c.claim_info.last_index=d,p}}return s()})();return h.claim_order=c.claim_info.total_claimed,c.claim_info.total_claimed+=1,h}function Kx(c,t,e,s){return zh(c,a=>a.nodeName===t,a=>{const h=[];for(let d=0;d<a.attributes.length;d++){const p=a.attributes[d];e[p.name]||h.push(p.name)}h.forEach(d=>a.removeAttribute(d))},()=>s(t))}function xT(c,t,e){return Kx(c,t,e,$x)}function Qx(c,t){return zh(c,e=>e.nodeType===3,e=>{const s=""+t;if(e.data.startsWith(s)){if(e.data.length!==s.length)return e.splitText(s.length)}else e.data=s},()=>sl(t),!0)}function _T(c){return Qx(c," ")}function yT(c,t){t=""+t,c.wholeText!==t&&(c.data=t)}function vT(c,t){c.value=t==null?"":t}let ho;function fo(c){ho=c}function rl(){if(!ho)throw new Error("Function called outside component initialization");return ho}function bT(c){rl().$$.on_mount.push(c)}function MT(c){rl().$$.after_update.push(c)}function wT(c,t){rl().$$.context.set(c,t)}const nr=[],Nh=[],po=[],ol=[],t_=Promise.resolve();let al=!1;function e_(){al||(al=!0,t_.then(Vh))}function ll(c){po.push(c)}function ST(c){ol.push(c)}let cl=!1;const ul=new Set;function Vh(){if(!cl){cl=!0;do{for(let c=0;c<nr.length;c+=1){const t=nr[c];fo(t),n_(t.$$)}for(fo(null),nr.length=0;Nh.length;)Nh.pop()();for(let c=0;c<po.length;c+=1){const t=po[c];ul.has(t)||(ul.add(t),t())}po.length=0}while(nr.length);for(;ol.length;)ol.pop()();al=!1,cl=!1,ul.clear()}}function n_(c){if(c.fragment!==null){c.update(),er(c.before_update);const t=c.dirty;c.dirty=[-1],c.fragment&&c.fragment.p(c.ctx,t),c.after_update.forEach(ll)}}const mo=new Set;let Ei;function TT(){Ei={r:0,c:[],p:Ei}}function ET(){Ei.r||er(Ei.c),Ei=Ei.p}function i_(c,t){c&&c.i&&(mo.delete(c),c.i(t))}function AT(c,t,e,s){if(c&&c.o){if(mo.has(c))return;mo.add(c),Ei.c.push(()=>{mo.delete(c),s&&(e&&c.d(1),s())}),c.o(t)}}function LT(c,t){const e={},s={},a={$$scope:1};let h=c.length;for(;h--;){const d=c[h],p=t[h];if(p){for(const g in d)g in p||(s[g]=1);for(const g in p)a[g]||(e[g]=p[g],a[g]=1);c[h]=p}else for(const g in d)a[g]=1}for(const d in s)d in e||(e[d]=void 0);return e}function CT(c){return typeof c=="object"&&c!==null?c:{}}function RT(c,t,e){const s=c.$$.props[t];s!==void 0&&(c.$$.bound[s]=e,e(c.$$.ctx[s]))}function PT(c){c&&c.c()}function DT(c,t){c&&c.l(t)}function s_(c,t,e,s){const{fragment:a,on_mount:h,on_destroy:d,after_update:p}=c.$$;a&&a.m(t,e),s||ll(()=>{const g=h.map(kh).filter(Vx);d?d.push(...g):er(g),c.$$.on_mount=[]}),p.forEach(ll)}function r_(c,t){const e=c.$$;e.fragment!==null&&(er(e.on_destroy),e.fragment&&e.fragment.d(t),e.on_destroy=e.fragment=null,e.ctx=[])}function o_(c,t){c.$$.dirty[0]===-1&&(nr.push(c),e_(),c.$$.dirty.fill(0)),c.$$.dirty[t/31|0]|=1<<t%31}function IT(c,t,e,s,a,h,d,p=[-1]){const g=ho;fo(c);const _=c.$$={fragment:null,ctx:null,props:h,update:tr,not_equal:a,bound:Oh(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(t.context||(g?g.$$.context:[])),callbacks:Oh(),dirty:p,skip_bound:!1,root:t.target||g.$$.root};d&&d(_.root);let v=!1;if(_.ctx=e?e(c,t.props||{},(b,M,...S)=>{const L=S.length?S[0]:M;return _.ctx&&a(_.ctx[b],_.ctx[b]=L)&&(!_.skip_bound&&_.bound[b]&&_.bound[b](L),v&&o_(c,b)),M}):[],_.update(),v=!0,er(_.before_update),_.fragment=s?s(_.ctx):!1,t.target){if(t.hydrate){Wx();const b=Zx(t.target);_.fragment&&_.fragment.l(b),b.forEach(Yx)}else _.fragment&&_.fragment.c();t.intro&&i_(c.$$.fragment),s_(c,t.target,t.anchor,t.customElement),Gx(),Vh()}fo(g)}class FT{$destroy(){r_(this,1),this.$destroy=tr}$on(t,e){const s=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return s.push(e),()=>{const a=s.indexOf(e);a!==-1&&s.splice(a,1)}}$set(t){this.$$set&&!Hx(t)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}const Hi=[];function kT(c,t=tr){let e;const s=new Set;function a(p){if(Ux(c,p)&&(c=p,e)){const g=!Hi.length;for(const _ of s)_[1](),Hi.push(_,c);if(g){for(let _=0;_<Hi.length;_+=2)Hi[_][0](Hi[_+1]);Hi.length=0}}}function h(p){a(p(c))}function d(p,g=tr){const _=[p,g];return s.add(_),s.size===1&&(e=t(a)||tr),p(c),()=>{s.delete(_),s.size===0&&(e(),e=null)}}return{set:a,update:h,subscribe:d}}/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Uh="133",a_=0,Hh=1,l_=2,Wh=1,c_=2,ir=3,sr=0,ke=1,Wi=2,Gh=1,ni=0,rr=1,Xh=2,jh=3,qh=4,u_=5,Gi=100,h_=101,d_=102,Yh=103,$h=104,f_=200,p_=201,m_=202,g_=203,Zh=204,Jh=205,x_=206,__=207,y_=208,v_=209,b_=210,M_=0,w_=1,S_=2,hl=3,T_=4,E_=5,A_=6,L_=7,go=0,C_=1,R_=2,Ai=0,P_=1,D_=2,I_=3,F_=4,k_=5,Kh=300,xo=301,_o=302,dl=303,fl=304,yo=306,pl=307,ml=1e3,ln=1001,gl=1002,Ne=1003,Qh=1004,td=1005,xn=1006,O_=1007,vo=1008,ii=1009,B_=1010,z_=1011,bo=1012,N_=1013,Mo=1014,si=1015,Xi=1016,V_=1017,U_=1018,H_=1019,or=1020,W_=1021,ji=1022,tn=1023,G_=1024,X_=1025,j_=tn,qi=1026,ar=1027,q_=1028,Y_=1029,$_=1030,Z_=1031,J_=1032,K_=1033,ed=33776,nd=33777,id=33778,sd=33779,rd=35840,od=35841,ad=35842,ld=35843,Q_=36196,cd=37492,ud=37496,t0=37808,e0=37809,n0=37810,i0=37811,s0=37812,r0=37813,o0=37814,a0=37815,l0=37816,c0=37817,u0=37818,h0=37819,d0=37820,f0=37821,p0=36492,m0=37840,g0=37841,x0=37842,_0=37843,y0=37844,v0=37845,b0=37846,M0=37847,w0=37848,S0=37849,T0=37850,E0=37851,A0=37852,L0=37853,C0=2200,R0=2201,P0=2202,wo=2300,So=2301,xl=2302,Yi=2400,$i=2401,To=2402,_l=2500,hd=2501,D0=0,qe=3e3,Li=3001,yl=3007,vl=3002,I0=3003,dd=3004,fd=3005,pd=3006,F0=3200,k0=3201,Zi=0,O0=1,bl=7680,B0=519,lr=35044,Eo=35048,md="300 es";class Ci{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[t]===void 0&&(s[t]=[]),s[t].indexOf(e)===-1&&s[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const s=this._listeners;return s[t]!==void 0&&s[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const a=this._listeners[t];if(a!==void 0){const h=a.indexOf(e);h!==-1&&a.splice(h,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const s=this._listeners[t.type];if(s!==void 0){t.target=this;const a=s.slice(0);for(let h=0,d=a.length;h<d;h++)a[h].call(this,t);t.target=null}}}const Ml=Math.PI/180,wl=180/Math.PI,We=[];for(let c=0;c<256;c++)We[c]=(c<16?"0":"")+c.toString(16);const z0=typeof crypto!="undefined"&&"randomUUID"in crypto;function In(){if(z0)return crypto.randomUUID().toUpperCase();const c=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return(We[c&255]+We[c>>8&255]+We[c>>16&255]+We[c>>24&255]+"-"+We[t&255]+We[t>>8&255]+"-"+We[t>>16&15|64]+We[t>>24&255]+"-"+We[e&63|128]+We[e>>8&255]+"-"+We[e>>16&255]+We[e>>24&255]+We[s&255]+We[s>>8&255]+We[s>>16&255]+We[s>>24&255]).toUpperCase()}function cn(c,t,e){return Math.max(t,Math.min(e,c))}function N0(c,t){return(c%t+t)%t}function Sl(c,t,e){return(1-e)*c+e*t}function gd(c){return(c&c-1)==0&&c!==0}function V0(c){return Math.pow(2,Math.floor(Math.log(c)/Math.LN2))}class Mt{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,s=this.y,a=t.elements;return this.x=a[0]*e+a[3]*s+a[6],this.y=a[1]*e+a[4]*s+a[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(t,Math.min(e,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,s=this.y-t.y;return e*e+s*s}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,s){return s!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const s=Math.cos(e),a=Math.sin(e),h=this.x-t.x,d=this.y-t.y;return this.x=h*s-d*a+t.x,this.y=h*a+d*s+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}Mt.prototype.isVector2=!0;class Ge{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,s,a,h,d,p,g,_){const v=this.elements;return v[0]=t,v[1]=a,v[2]=p,v[3]=e,v[4]=h,v[5]=g,v[6]=s,v[7]=d,v[8]=_,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],this}extractBasis(t,e,s){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,a=e.elements,h=this.elements,d=s[0],p=s[3],g=s[6],_=s[1],v=s[4],b=s[7],M=s[2],S=s[5],L=s[8],C=a[0],k=a[3],T=a[6],E=a[1],z=a[4],I=a[7],V=a[2],G=a[5],F=a[8];return h[0]=d*C+p*E+g*V,h[3]=d*k+p*z+g*G,h[6]=d*T+p*I+g*F,h[1]=_*C+v*E+b*V,h[4]=_*k+v*z+b*G,h[7]=_*T+v*I+b*F,h[2]=M*C+S*E+L*V,h[5]=M*k+S*z+L*G,h[8]=M*T+S*I+L*F,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],s=t[1],a=t[2],h=t[3],d=t[4],p=t[5],g=t[6],_=t[7],v=t[8];return e*d*v-e*p*_-s*h*v+s*p*g+a*h*_-a*d*g}invert(){const t=this.elements,e=t[0],s=t[1],a=t[2],h=t[3],d=t[4],p=t[5],g=t[6],_=t[7],v=t[8],b=v*d-p*_,M=p*g-v*h,S=_*h-d*g,L=e*b+s*M+a*S;if(L===0)return this.set(0,0,0,0,0,0,0,0,0);const C=1/L;return t[0]=b*C,t[1]=(a*_-v*s)*C,t[2]=(p*s-a*d)*C,t[3]=M*C,t[4]=(v*e-a*g)*C,t[5]=(a*h-p*e)*C,t[6]=S*C,t[7]=(s*g-_*e)*C,t[8]=(d*e-s*h)*C,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,s,a,h,d,p){const g=Math.cos(h),_=Math.sin(h);return this.set(s*g,s*_,-s*(g*d+_*p)+d+t,-a*_,a*g,-a*(-_*d+g*p)+p+e,0,0,1),this}scale(t,e){const s=this.elements;return s[0]*=t,s[3]*=t,s[6]*=t,s[1]*=e,s[4]*=e,s[7]*=e,this}rotate(t){const e=Math.cos(t),s=Math.sin(t),a=this.elements,h=a[0],d=a[3],p=a[6],g=a[1],_=a[4],v=a[7];return a[0]=e*h+s*g,a[3]=e*d+s*_,a[6]=e*p+s*v,a[1]=-s*h+e*g,a[4]=-s*d+e*_,a[7]=-s*p+e*v,this}translate(t,e){const s=this.elements;return s[0]+=t*s[2],s[3]+=t*s[5],s[6]+=t*s[8],s[1]+=e*s[2],s[4]+=e*s[5],s[7]+=e*s[8],this}equals(t){const e=this.elements,s=t.elements;for(let a=0;a<9;a++)if(e[a]!==s[a])return!1;return!0}fromArray(t,e=0){for(let s=0;s<9;s++)this.elements[s]=t[s+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t}clone(){return new this.constructor().fromArray(this.elements)}}Ge.prototype.isMatrix3=!0;function xd(c){if(c.length===0)return-1/0;let t=c[0];for(let e=1,s=c.length;e<s;++e)c[e]>t&&(t=c[e]);return t}function Ao(c){return document.createElementNS("http://www.w3.org/1999/xhtml",c)}let Ji;class Ki{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement=="undefined")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{Ji===void 0&&(Ji=Ao("canvas")),Ji.width=t.width,Ji.height=t.height;const s=Ji.getContext("2d");t instanceof ImageData?s.putImageData(t,0,0):s.drawImage(t,0,0,t.width,t.height),e=Ji}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}}let U0=0;class Xe extends Ci{constructor(t=Xe.DEFAULT_IMAGE,e=Xe.DEFAULT_MAPPING,s=ln,a=ln,h=xn,d=vo,p=tn,g=ii,_=1,v=qe){super();Object.defineProperty(this,"id",{value:U0++}),this.uuid=In(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=s,this.wrapT=a,this.magFilter=h,this.minFilter=d,this.anisotropy=_,this.format=p,this.internalFormat=null,this.type=g,this.offset=new Mt(0,0),this.repeat=new Mt(1,1),this.center=new Mt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Ge,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=v,this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const s={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const a=this.image;if(a.uuid===void 0&&(a.uuid=In()),!e&&t.images[a.uuid]===void 0){let h;if(Array.isArray(a)){h=[];for(let d=0,p=a.length;d<p;d++)a[d].isDataTexture?h.push(Tl(a[d].image)):h.push(Tl(a[d]))}else h=Tl(a);t.images[a.uuid]={uuid:a.uuid,url:h}}s.image=a.uuid}return e||(t.textures[this.uuid]=s),s}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==Kh)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case ml:t.x=t.x-Math.floor(t.x);break;case ln:t.x=t.x<0?0:1;break;case gl:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case ml:t.y=t.y-Math.floor(t.y);break;case ln:t.y=t.y<0?0:1;break;case gl:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&this.version++}}Xe.DEFAULT_IMAGE=void 0;Xe.DEFAULT_MAPPING=Kh;Xe.prototype.isTexture=!0;function Tl(c){return typeof HTMLImageElement!="undefined"&&c instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&c instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&c instanceof ImageBitmap?Ki.getDataURL(c):c.data?{data:Array.prototype.slice.call(c.data),width:c.width,height:c.height,type:c.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class ge{constructor(t=0,e=0,s=0,a=1){this.x=t,this.y=e,this.z=s,this.w=a}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,s,a){return this.x=t,this.y=e,this.z=s,this.w=a,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,s=this.y,a=this.z,h=this.w,d=t.elements;return this.x=d[0]*e+d[4]*s+d[8]*a+d[12]*h,this.y=d[1]*e+d[5]*s+d[9]*a+d[13]*h,this.z=d[2]*e+d[6]*s+d[10]*a+d[14]*h,this.w=d[3]*e+d[7]*s+d[11]*a+d[15]*h,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,s,a,h;const d=.01,p=.1,g=t.elements,_=g[0],v=g[4],b=g[8],M=g[1],S=g[5],L=g[9],C=g[2],k=g[6],T=g[10];if(Math.abs(v-M)<d&&Math.abs(b-C)<d&&Math.abs(L-k)<d){if(Math.abs(v+M)<p&&Math.abs(b+C)<p&&Math.abs(L+k)<p&&Math.abs(_+S+T-3)<p)return this.set(1,0,0,0),this;e=Math.PI;const z=(_+1)/2,I=(S+1)/2,V=(T+1)/2,G=(v+M)/4,F=(b+C)/4,K=(L+k)/4;return z>I&&z>V?z<d?(s=0,a=.707106781,h=.707106781):(s=Math.sqrt(z),a=G/s,h=F/s):I>V?I<d?(s=.707106781,a=0,h=.707106781):(a=Math.sqrt(I),s=G/a,h=K/a):V<d?(s=.707106781,a=.707106781,h=0):(h=Math.sqrt(V),s=F/h,a=K/h),this.set(s,a,h,e),this}let E=Math.sqrt((k-L)*(k-L)+(b-C)*(b-C)+(M-v)*(M-v));return Math.abs(E)<.001&&(E=1),this.x=(k-L)/E,this.y=(b-C)/E,this.z=(M-v)/E,this.w=Math.acos((_+S+T-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(t,Math.min(e,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this.z=t.z+(e.z-t.z)*s,this.w=t.w+(e.w-t.w)*s,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,s){return s!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}ge.prototype.isVector4=!0;class Fn extends Ci{constructor(t,e,s={}){super();this.width=t,this.height=e,this.depth=1,this.scissor=new ge(0,0,t,e),this.scissorTest=!1,this.viewport=new ge(0,0,t,e),this.texture=new Xe(void 0,s.mapping,s.wrapS,s.wrapT,s.magFilter,s.minFilter,s.format,s.type,s.anisotropy,s.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:t,height:e,depth:1},this.texture.generateMipmaps=s.generateMipmaps!==void 0?s.generateMipmaps:!1,this.texture.internalFormat=s.internalFormat!==void 0?s.internalFormat:null,this.texture.minFilter=s.minFilter!==void 0?s.minFilter:xn,this.depthBuffer=s.depthBuffer!==void 0?s.depthBuffer:!0,this.stencilBuffer=s.stencilBuffer!==void 0?s.stencilBuffer:!1,this.depthTexture=s.depthTexture!==void 0?s.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,s=1){(this.width!==t||this.height!==e||this.depth!==s)&&(this.width=t,this.height=e,this.depth=s,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=s,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.image=Qs({},this.texture.image),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}Fn.prototype.isWebGLRenderTarget=!0;class H0 extends Fn{constructor(t,e,s){super(t,e);const a=this.texture;this.texture=[];for(let h=0;h<s;h++)this.texture[h]=a.clone()}setSize(t,e,s=1){if(this.width!==t||this.height!==e||this.depth!==s){this.width=t,this.height=e,this.depth=s;for(let a=0,h=this.texture.length;a<h;a++)this.texture[a].image.width=t,this.texture[a].image.height=e,this.texture[a].image.depth=s;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this.texture.length=0;for(let e=0,s=t.texture.length;e<s;e++)this.texture[e]=t.texture[e].clone();return this}}H0.prototype.isWebGLMultipleRenderTargets=!0;class _d extends Fn{constructor(t,e,s){super(t,e,s);this.samples=4}copy(t){return super.copy.call(this,t),this.samples=t.samples,this}}_d.prototype.isWebGLMultisampleRenderTarget=!0;class sn{constructor(t=0,e=0,s=0,a=1){this._x=t,this._y=e,this._z=s,this._w=a}static slerp(t,e,s,a){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),s.slerpQuaternions(t,e,a)}static slerpFlat(t,e,s,a,h,d,p){let g=s[a+0],_=s[a+1],v=s[a+2],b=s[a+3];const M=h[d+0],S=h[d+1],L=h[d+2],C=h[d+3];if(p===0){t[e+0]=g,t[e+1]=_,t[e+2]=v,t[e+3]=b;return}if(p===1){t[e+0]=M,t[e+1]=S,t[e+2]=L,t[e+3]=C;return}if(b!==C||g!==M||_!==S||v!==L){let k=1-p;const T=g*M+_*S+v*L+b*C,E=T>=0?1:-1,z=1-T*T;if(z>Number.EPSILON){const V=Math.sqrt(z),G=Math.atan2(V,T*E);k=Math.sin(k*G)/V,p=Math.sin(p*G)/V}const I=p*E;if(g=g*k+M*I,_=_*k+S*I,v=v*k+L*I,b=b*k+C*I,k===1-p){const V=1/Math.sqrt(g*g+_*_+v*v+b*b);g*=V,_*=V,v*=V,b*=V}}t[e]=g,t[e+1]=_,t[e+2]=v,t[e+3]=b}static multiplyQuaternionsFlat(t,e,s,a,h,d){const p=s[a],g=s[a+1],_=s[a+2],v=s[a+3],b=h[d],M=h[d+1],S=h[d+2],L=h[d+3];return t[e]=p*L+v*b+g*S-_*M,t[e+1]=g*L+v*M+_*b-p*S,t[e+2]=_*L+v*S+p*M-g*b,t[e+3]=v*L-p*b-g*M-_*S,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,s,a){return this._x=t,this._y=e,this._z=s,this._w=a,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!(t&&t.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const s=t._x,a=t._y,h=t._z,d=t._order,p=Math.cos,g=Math.sin,_=p(s/2),v=p(a/2),b=p(h/2),M=g(s/2),S=g(a/2),L=g(h/2);switch(d){case"XYZ":this._x=M*v*b+_*S*L,this._y=_*S*b-M*v*L,this._z=_*v*L+M*S*b,this._w=_*v*b-M*S*L;break;case"YXZ":this._x=M*v*b+_*S*L,this._y=_*S*b-M*v*L,this._z=_*v*L-M*S*b,this._w=_*v*b+M*S*L;break;case"ZXY":this._x=M*v*b-_*S*L,this._y=_*S*b+M*v*L,this._z=_*v*L+M*S*b,this._w=_*v*b-M*S*L;break;case"ZYX":this._x=M*v*b-_*S*L,this._y=_*S*b+M*v*L,this._z=_*v*L-M*S*b,this._w=_*v*b+M*S*L;break;case"YZX":this._x=M*v*b+_*S*L,this._y=_*S*b+M*v*L,this._z=_*v*L-M*S*b,this._w=_*v*b-M*S*L;break;case"XZY":this._x=M*v*b-_*S*L,this._y=_*S*b-M*v*L,this._z=_*v*L+M*S*b,this._w=_*v*b+M*S*L;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+d)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const s=e/2,a=Math.sin(s);return this._x=t.x*a,this._y=t.y*a,this._z=t.z*a,this._w=Math.cos(s),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,s=e[0],a=e[4],h=e[8],d=e[1],p=e[5],g=e[9],_=e[2],v=e[6],b=e[10],M=s+p+b;if(M>0){const S=.5/Math.sqrt(M+1);this._w=.25/S,this._x=(v-g)*S,this._y=(h-_)*S,this._z=(d-a)*S}else if(s>p&&s>b){const S=2*Math.sqrt(1+s-p-b);this._w=(v-g)/S,this._x=.25*S,this._y=(a+d)/S,this._z=(h+_)/S}else if(p>b){const S=2*Math.sqrt(1+p-s-b);this._w=(h-_)/S,this._x=(a+d)/S,this._y=.25*S,this._z=(g+v)/S}else{const S=2*Math.sqrt(1+b-s-p);this._w=(d-a)/S,this._x=(h+_)/S,this._y=(g+v)/S,this._z=.25*S}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let s=t.dot(e)+1;return s<Number.EPSILON?(s=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=s):(this._x=0,this._y=-t.z,this._z=t.y,this._w=s)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=s),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(cn(this.dot(t),-1,1)))}rotateTowards(t,e){const s=this.angleTo(t);if(s===0)return this;const a=Math.min(1,e/s);return this.slerp(t,a),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return e!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const s=t._x,a=t._y,h=t._z,d=t._w,p=e._x,g=e._y,_=e._z,v=e._w;return this._x=s*v+d*p+a*_-h*g,this._y=a*v+d*g+h*p-s*_,this._z=h*v+d*_+s*g-a*p,this._w=d*v-s*p-a*g-h*_,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const s=this._x,a=this._y,h=this._z,d=this._w;let p=d*t._w+s*t._x+a*t._y+h*t._z;if(p<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,p=-p):this.copy(t),p>=1)return this._w=d,this._x=s,this._y=a,this._z=h,this;const g=1-p*p;if(g<=Number.EPSILON){const S=1-e;return this._w=S*d+e*this._w,this._x=S*s+e*this._x,this._y=S*a+e*this._y,this._z=S*h+e*this._z,this.normalize(),this._onChangeCallback(),this}const _=Math.sqrt(g),v=Math.atan2(_,p),b=Math.sin((1-e)*v)/_,M=Math.sin(e*v)/_;return this._w=d*b+this._w*M,this._x=s*b+this._x*M,this._y=a*b+this._y*M,this._z=h*b+this._z*M,this._onChangeCallback(),this}slerpQuaternions(t,e,s){this.copy(t).slerp(e,s)}random(){const t=Math.random(),e=Math.sqrt(1-t),s=Math.sqrt(t),a=2*Math.PI*Math.random(),h=2*Math.PI*Math.random();return this.set(e*Math.cos(a),s*Math.sin(h),s*Math.cos(h),e*Math.sin(a))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}sn.prototype.isQuaternion=!0;class N{constructor(t=0,e=0,s=0){this.x=t,this.y=e,this.z=s}set(t,e,s){return s===void 0&&(s=this.z),this.x=t,this.y=e,this.z=s,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(yd.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(yd.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,s=this.y,a=this.z,h=t.elements;return this.x=h[0]*e+h[3]*s+h[6]*a,this.y=h[1]*e+h[4]*s+h[7]*a,this.z=h[2]*e+h[5]*s+h[8]*a,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,s=this.y,a=this.z,h=t.elements,d=1/(h[3]*e+h[7]*s+h[11]*a+h[15]);return this.x=(h[0]*e+h[4]*s+h[8]*a+h[12])*d,this.y=(h[1]*e+h[5]*s+h[9]*a+h[13])*d,this.z=(h[2]*e+h[6]*s+h[10]*a+h[14])*d,this}applyQuaternion(t){const e=this.x,s=this.y,a=this.z,h=t.x,d=t.y,p=t.z,g=t.w,_=g*e+d*a-p*s,v=g*s+p*e-h*a,b=g*a+h*s-d*e,M=-h*e-d*s-p*a;return this.x=_*g+M*-h+v*-p-b*-d,this.y=v*g+M*-d+b*-h-_*-p,this.z=b*g+M*-p+_*-d-v*-h,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,s=this.y,a=this.z,h=t.elements;return this.x=h[0]*e+h[4]*s+h[8]*a,this.y=h[1]*e+h[5]*s+h[9]*a,this.z=h[2]*e+h[6]*s+h[10]*a,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(t,Math.min(e,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this.z=t.z+(e.z-t.z)*s,this}cross(t,e){return e!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const s=t.x,a=t.y,h=t.z,d=e.x,p=e.y,g=e.z;return this.x=a*g-h*p,this.y=h*d-s*g,this.z=s*p-a*d,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const s=t.dot(this)/e;return this.copy(t).multiplyScalar(s)}projectOnPlane(t){return El.copy(this).projectOnVector(t),this.sub(El)}reflect(t){return this.sub(El.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const s=this.dot(t)/e;return Math.acos(cn(s,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,s=this.y-t.y,a=this.z-t.z;return e*e+s*s+a*a}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,s){const a=Math.sin(e)*t;return this.x=a*Math.sin(s),this.y=Math.cos(e)*t,this.z=a*Math.cos(s),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,s){return this.x=t*Math.sin(e),this.y=s,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),s=this.setFromMatrixColumn(t,1).length(),a=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=s,this.z=a,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,s){return s!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=(Math.random()-.5)*2,e=Math.random()*Math.PI*2,s=Math.sqrt(1-t**2);return this.x=s*Math.cos(e),this.y=s*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}N.prototype.isVector3=!0;const El=new N,yd=new sn;class Mn{constructor(t=new N(1/0,1/0,1/0),e=new N(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,s=1/0,a=1/0,h=-1/0,d=-1/0,p=-1/0;for(let g=0,_=t.length;g<_;g+=3){const v=t[g],b=t[g+1],M=t[g+2];v<e&&(e=v),b<s&&(s=b),M<a&&(a=M),v>h&&(h=v),b>d&&(d=b),M>p&&(p=M)}return this.min.set(e,s,a),this.max.set(h,d,p),this}setFromBufferAttribute(t){let e=1/0,s=1/0,a=1/0,h=-1/0,d=-1/0,p=-1/0;for(let g=0,_=t.count;g<_;g++){const v=t.getX(g),b=t.getY(g),M=t.getZ(g);v<e&&(e=v),b<s&&(s=b),M<a&&(a=M),v>h&&(h=v),b>d&&(d=b),M>p&&(p=M)}return this.min.set(e,s,a),this.max.set(h,d,p),this}setFromPoints(t){this.makeEmpty();for(let e=0,s=t.length;e<s;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const s=cr.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(s),this.max.copy(t).add(s),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;e!==void 0&&(e.boundingBox===null&&e.computeBoundingBox(),Al.copy(e.boundingBox),Al.applyMatrix4(t.matrixWorld),this.union(Al));const s=t.children;for(let a=0,h=s.length;a<h;a++)this.expandByObject(s[a]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,cr),cr.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,s;return t.normal.x>0?(e=t.normal.x*this.min.x,s=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,s=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,s+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,s+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,s+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,s+=t.normal.z*this.min.z),e<=-t.constant&&s>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(ur),Lo.subVectors(this.max,ur),Qi.subVectors(t.a,ur),ts.subVectors(t.b,ur),es.subVectors(t.c,ur),ri.subVectors(ts,Qi),oi.subVectors(es,ts),Ri.subVectors(Qi,es);let e=[0,-ri.z,ri.y,0,-oi.z,oi.y,0,-Ri.z,Ri.y,ri.z,0,-ri.x,oi.z,0,-oi.x,Ri.z,0,-Ri.x,-ri.y,ri.x,0,-oi.y,oi.x,0,-Ri.y,Ri.x,0];return!Ll(e,Qi,ts,es,Lo)||(e=[1,0,0,0,1,0,0,0,1],!Ll(e,Qi,ts,es,Lo))?!1:(Co.crossVectors(ri,oi),e=[Co.x,Co.y,Co.z],Ll(e,Qi,ts,es,Lo))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return cr.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=this.getSize(cr).length()*.5,t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(Un[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),Un[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),Un[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),Un[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),Un[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),Un[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),Un[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),Un[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(Un),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}Mn.prototype.isBox3=!0;const Un=[new N,new N,new N,new N,new N,new N,new N,new N],cr=new N,Al=new Mn,Qi=new N,ts=new N,es=new N,ri=new N,oi=new N,Ri=new N,ur=new N,Lo=new N,Co=new N,Pi=new N;function Ll(c,t,e,s,a){for(let h=0,d=c.length-3;h<=d;h+=3){Pi.fromArray(c,h);const p=a.x*Math.abs(Pi.x)+a.y*Math.abs(Pi.y)+a.z*Math.abs(Pi.z),g=t.dot(Pi),_=e.dot(Pi),v=s.dot(Pi);if(Math.max(-Math.max(g,_,v),Math.min(g,_,v))>p)return!1}return!0}const W0=new Mn,vd=new N,Cl=new N,Rl=new N;class ns{constructor(t=new N,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const s=this.center;e!==void 0?s.copy(e):W0.setFromPoints(t).getCenter(s);let a=0;for(let h=0,d=t.length;h<d;h++)a=Math.max(a,s.distanceToSquared(t[h]));return this.radius=Math.sqrt(a),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const s=this.center.distanceToSquared(t);return e.copy(t),s>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){Rl.subVectors(t,this.center);const e=Rl.lengthSq();if(e>this.radius*this.radius){const s=Math.sqrt(e),a=(s-this.radius)*.5;this.center.add(Rl.multiplyScalar(a/s)),this.radius+=a}return this}union(t){return Cl.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(vd.copy(t.center).add(Cl)),this.expandByPoint(vd.copy(t.center).sub(Cl)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Hn=new N,Pl=new N,Ro=new N,ai=new N,Dl=new N,Po=new N,Il=new N;class is{constructor(t=new N,e=new N(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Hn)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const s=e.dot(this.direction);return s<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(s).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Hn.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Hn.copy(this.direction).multiplyScalar(e).add(this.origin),Hn.distanceToSquared(t))}distanceSqToSegment(t,e,s,a){Pl.copy(t).add(e).multiplyScalar(.5),Ro.copy(e).sub(t).normalize(),ai.copy(this.origin).sub(Pl);const h=t.distanceTo(e)*.5,d=-this.direction.dot(Ro),p=ai.dot(this.direction),g=-ai.dot(Ro),_=ai.lengthSq(),v=Math.abs(1-d*d);let b,M,S,L;if(v>0)if(b=d*g-p,M=d*p-g,L=h*v,b>=0)if(M>=-L)if(M<=L){const C=1/v;b*=C,M*=C,S=b*(b+d*M+2*p)+M*(d*b+M+2*g)+_}else M=h,b=Math.max(0,-(d*M+p)),S=-b*b+M*(M+2*g)+_;else M=-h,b=Math.max(0,-(d*M+p)),S=-b*b+M*(M+2*g)+_;else M<=-L?(b=Math.max(0,-(-d*h+p)),M=b>0?-h:Math.min(Math.max(-h,-g),h),S=-b*b+M*(M+2*g)+_):M<=L?(b=0,M=Math.min(Math.max(-h,-g),h),S=M*(M+2*g)+_):(b=Math.max(0,-(d*h+p)),M=b>0?h:Math.min(Math.max(-h,-g),h),S=-b*b+M*(M+2*g)+_);else M=d>0?-h:h,b=Math.max(0,-(d*M+p)),S=-b*b+M*(M+2*g)+_;return s&&s.copy(this.direction).multiplyScalar(b).add(this.origin),a&&a.copy(Ro).multiplyScalar(M).add(Pl),S}intersectSphere(t,e){Hn.subVectors(t.center,this.origin);const s=Hn.dot(this.direction),a=Hn.dot(Hn)-s*s,h=t.radius*t.radius;if(a>h)return null;const d=Math.sqrt(h-a),p=s-d,g=s+d;return p<0&&g<0?null:p<0?this.at(g,e):this.at(p,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const s=-(this.origin.dot(t.normal)+t.constant)/e;return s>=0?s:null}intersectPlane(t,e){const s=this.distanceToPlane(t);return s===null?null:this.at(s,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let s,a,h,d,p,g;const _=1/this.direction.x,v=1/this.direction.y,b=1/this.direction.z,M=this.origin;return _>=0?(s=(t.min.x-M.x)*_,a=(t.max.x-M.x)*_):(s=(t.max.x-M.x)*_,a=(t.min.x-M.x)*_),v>=0?(h=(t.min.y-M.y)*v,d=(t.max.y-M.y)*v):(h=(t.max.y-M.y)*v,d=(t.min.y-M.y)*v),s>d||h>a||((h>s||s!==s)&&(s=h),(d<a||a!==a)&&(a=d),b>=0?(p=(t.min.z-M.z)*b,g=(t.max.z-M.z)*b):(p=(t.max.z-M.z)*b,g=(t.min.z-M.z)*b),s>g||p>a)||((p>s||s!==s)&&(s=p),(g<a||a!==a)&&(a=g),a<0)?null:this.at(s>=0?s:a,e)}intersectsBox(t){return this.intersectBox(t,Hn)!==null}intersectTriangle(t,e,s,a,h){Dl.subVectors(e,t),Po.subVectors(s,t),Il.crossVectors(Dl,Po);let d=this.direction.dot(Il),p;if(d>0){if(a)return null;p=1}else if(d<0)p=-1,d=-d;else return null;ai.subVectors(this.origin,t);const g=p*this.direction.dot(Po.crossVectors(ai,Po));if(g<0)return null;const _=p*this.direction.dot(Dl.cross(ai));if(_<0||g+_>d)return null;const v=-p*ai.dot(Il);return v<0?null:this.at(v/d,h)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class jt{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,s,a,h,d,p,g,_,v,b,M,S,L,C,k){const T=this.elements;return T[0]=t,T[4]=e,T[8]=s,T[12]=a,T[1]=h,T[5]=d,T[9]=p,T[13]=g,T[2]=_,T[6]=v,T[10]=b,T[14]=M,T[3]=S,T[7]=L,T[11]=C,T[15]=k,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new jt().fromArray(this.elements)}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],e[9]=s[9],e[10]=s[10],e[11]=s[11],e[12]=s[12],e[13]=s[13],e[14]=s[14],e[15]=s[15],this}copyPosition(t){const e=this.elements,s=t.elements;return e[12]=s[12],e[13]=s[13],e[14]=s[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,s){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(t,e,s){return this.set(t.x,e.x,s.x,0,t.y,e.y,s.y,0,t.z,e.z,s.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,s=t.elements,a=1/ss.setFromMatrixColumn(t,0).length(),h=1/ss.setFromMatrixColumn(t,1).length(),d=1/ss.setFromMatrixColumn(t,2).length();return e[0]=s[0]*a,e[1]=s[1]*a,e[2]=s[2]*a,e[3]=0,e[4]=s[4]*h,e[5]=s[5]*h,e[6]=s[6]*h,e[7]=0,e[8]=s[8]*d,e[9]=s[9]*d,e[10]=s[10]*d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,s=t.x,a=t.y,h=t.z,d=Math.cos(s),p=Math.sin(s),g=Math.cos(a),_=Math.sin(a),v=Math.cos(h),b=Math.sin(h);if(t.order==="XYZ"){const M=d*v,S=d*b,L=p*v,C=p*b;e[0]=g*v,e[4]=-g*b,e[8]=_,e[1]=S+L*_,e[5]=M-C*_,e[9]=-p*g,e[2]=C-M*_,e[6]=L+S*_,e[10]=d*g}else if(t.order==="YXZ"){const M=g*v,S=g*b,L=_*v,C=_*b;e[0]=M+C*p,e[4]=L*p-S,e[8]=d*_,e[1]=d*b,e[5]=d*v,e[9]=-p,e[2]=S*p-L,e[6]=C+M*p,e[10]=d*g}else if(t.order==="ZXY"){const M=g*v,S=g*b,L=_*v,C=_*b;e[0]=M-C*p,e[4]=-d*b,e[8]=L+S*p,e[1]=S+L*p,e[5]=d*v,e[9]=C-M*p,e[2]=-d*_,e[6]=p,e[10]=d*g}else if(t.order==="ZYX"){const M=d*v,S=d*b,L=p*v,C=p*b;e[0]=g*v,e[4]=L*_-S,e[8]=M*_+C,e[1]=g*b,e[5]=C*_+M,e[9]=S*_-L,e[2]=-_,e[6]=p*g,e[10]=d*g}else if(t.order==="YZX"){const M=d*g,S=d*_,L=p*g,C=p*_;e[0]=g*v,e[4]=C-M*b,e[8]=L*b+S,e[1]=b,e[5]=d*v,e[9]=-p*v,e[2]=-_*v,e[6]=S*b+L,e[10]=M-C*b}else if(t.order==="XZY"){const M=d*g,S=d*_,L=p*g,C=p*_;e[0]=g*v,e[4]=-b,e[8]=_*v,e[1]=M*b+C,e[5]=d*v,e[9]=S*b-L,e[2]=L*b-S,e[6]=p*v,e[10]=C*b+M}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(G0,t,X0)}lookAt(t,e,s){const a=this.elements;return un.subVectors(t,e),un.lengthSq()===0&&(un.z=1),un.normalize(),li.crossVectors(s,un),li.lengthSq()===0&&(Math.abs(s.z)===1?un.x+=1e-4:un.z+=1e-4,un.normalize(),li.crossVectors(s,un)),li.normalize(),Do.crossVectors(un,li),a[0]=li.x,a[4]=Do.x,a[8]=un.x,a[1]=li.y,a[5]=Do.y,a[9]=un.y,a[2]=li.z,a[6]=Do.z,a[10]=un.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,a=e.elements,h=this.elements,d=s[0],p=s[4],g=s[8],_=s[12],v=s[1],b=s[5],M=s[9],S=s[13],L=s[2],C=s[6],k=s[10],T=s[14],E=s[3],z=s[7],I=s[11],V=s[15],G=a[0],F=a[4],K=a[8],pt=a[12],ut=a[1],X=a[5],ht=a[9],it=a[13],Q=a[2],rt=a[6],tt=a[10],st=a[14],St=a[3],Bt=a[7],Wt=a[11],Pt=a[15];return h[0]=d*G+p*ut+g*Q+_*St,h[4]=d*F+p*X+g*rt+_*Bt,h[8]=d*K+p*ht+g*tt+_*Wt,h[12]=d*pt+p*it+g*st+_*Pt,h[1]=v*G+b*ut+M*Q+S*St,h[5]=v*F+b*X+M*rt+S*Bt,h[9]=v*K+b*ht+M*tt+S*Wt,h[13]=v*pt+b*it+M*st+S*Pt,h[2]=L*G+C*ut+k*Q+T*St,h[6]=L*F+C*X+k*rt+T*Bt,h[10]=L*K+C*ht+k*tt+T*Wt,h[14]=L*pt+C*it+k*st+T*Pt,h[3]=E*G+z*ut+I*Q+V*St,h[7]=E*F+z*X+I*rt+V*Bt,h[11]=E*K+z*ht+I*tt+V*Wt,h[15]=E*pt+z*it+I*st+V*Pt,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],s=t[4],a=t[8],h=t[12],d=t[1],p=t[5],g=t[9],_=t[13],v=t[2],b=t[6],M=t[10],S=t[14],L=t[3],C=t[7],k=t[11],T=t[15];return L*(+h*g*b-a*_*b-h*p*M+s*_*M+a*p*S-s*g*S)+C*(+e*g*S-e*_*M+h*d*M-a*d*S+a*_*v-h*g*v)+k*(+e*_*b-e*p*S-h*d*b+s*d*S+h*p*v-s*_*v)+T*(-a*p*v-e*g*b+e*p*M+a*d*b-s*d*M+s*g*v)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,s){const a=this.elements;return t.isVector3?(a[12]=t.x,a[13]=t.y,a[14]=t.z):(a[12]=t,a[13]=e,a[14]=s),this}invert(){const t=this.elements,e=t[0],s=t[1],a=t[2],h=t[3],d=t[4],p=t[5],g=t[6],_=t[7],v=t[8],b=t[9],M=t[10],S=t[11],L=t[12],C=t[13],k=t[14],T=t[15],E=b*k*_-C*M*_+C*g*S-p*k*S-b*g*T+p*M*T,z=L*M*_-v*k*_-L*g*S+d*k*S+v*g*T-d*M*T,I=v*C*_-L*b*_+L*p*S-d*C*S-v*p*T+d*b*T,V=L*b*g-v*C*g-L*p*M+d*C*M+v*p*k-d*b*k,G=e*E+s*z+a*I+h*V;if(G===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const F=1/G;return t[0]=E*F,t[1]=(C*M*h-b*k*h-C*a*S+s*k*S+b*a*T-s*M*T)*F,t[2]=(p*k*h-C*g*h+C*a*_-s*k*_-p*a*T+s*g*T)*F,t[3]=(b*g*h-p*M*h-b*a*_+s*M*_+p*a*S-s*g*S)*F,t[4]=z*F,t[5]=(v*k*h-L*M*h+L*a*S-e*k*S-v*a*T+e*M*T)*F,t[6]=(L*g*h-d*k*h-L*a*_+e*k*_+d*a*T-e*g*T)*F,t[7]=(d*M*h-v*g*h+v*a*_-e*M*_-d*a*S+e*g*S)*F,t[8]=I*F,t[9]=(L*b*h-v*C*h-L*s*S+e*C*S+v*s*T-e*b*T)*F,t[10]=(d*C*h-L*p*h+L*s*_-e*C*_-d*s*T+e*p*T)*F,t[11]=(v*p*h-d*b*h-v*s*_+e*b*_+d*s*S-e*p*S)*F,t[12]=V*F,t[13]=(v*C*a-L*b*a+L*s*M-e*C*M-v*s*k+e*b*k)*F,t[14]=(L*p*a-d*C*a-L*s*g+e*C*g+d*s*k-e*p*k)*F,t[15]=(d*b*a-v*p*a+v*s*g-e*b*g-d*s*M+e*p*M)*F,this}scale(t){const e=this.elements,s=t.x,a=t.y,h=t.z;return e[0]*=s,e[4]*=a,e[8]*=h,e[1]*=s,e[5]*=a,e[9]*=h,e[2]*=s,e[6]*=a,e[10]*=h,e[3]*=s,e[7]*=a,e[11]*=h,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],s=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],a=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,s,a))}makeTranslation(t,e,s){return this.set(1,0,0,t,0,1,0,e,0,0,1,s,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),s=Math.sin(t);return this.set(1,0,0,0,0,e,-s,0,0,s,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,0,s,0,0,1,0,0,-s,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,-s,0,0,s,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const s=Math.cos(e),a=Math.sin(e),h=1-s,d=t.x,p=t.y,g=t.z,_=h*d,v=h*p;return this.set(_*d+s,_*p-a*g,_*g+a*p,0,_*p+a*g,v*p+s,v*g-a*d,0,_*g-a*p,v*g+a*d,h*g*g+s,0,0,0,0,1),this}makeScale(t,e,s){return this.set(t,0,0,0,0,e,0,0,0,0,s,0,0,0,0,1),this}makeShear(t,e,s,a,h,d){return this.set(1,s,h,0,t,1,d,0,e,a,1,0,0,0,0,1),this}compose(t,e,s){const a=this.elements,h=e._x,d=e._y,p=e._z,g=e._w,_=h+h,v=d+d,b=p+p,M=h*_,S=h*v,L=h*b,C=d*v,k=d*b,T=p*b,E=g*_,z=g*v,I=g*b,V=s.x,G=s.y,F=s.z;return a[0]=(1-(C+T))*V,a[1]=(S+I)*V,a[2]=(L-z)*V,a[3]=0,a[4]=(S-I)*G,a[5]=(1-(M+T))*G,a[6]=(k+E)*G,a[7]=0,a[8]=(L+z)*F,a[9]=(k-E)*F,a[10]=(1-(M+C))*F,a[11]=0,a[12]=t.x,a[13]=t.y,a[14]=t.z,a[15]=1,this}decompose(t,e,s){const a=this.elements;let h=ss.set(a[0],a[1],a[2]).length();const d=ss.set(a[4],a[5],a[6]).length(),p=ss.set(a[8],a[9],a[10]).length();this.determinant()<0&&(h=-h),t.x=a[12],t.y=a[13],t.z=a[14],wn.copy(this);const _=1/h,v=1/d,b=1/p;return wn.elements[0]*=_,wn.elements[1]*=_,wn.elements[2]*=_,wn.elements[4]*=v,wn.elements[5]*=v,wn.elements[6]*=v,wn.elements[8]*=b,wn.elements[9]*=b,wn.elements[10]*=b,e.setFromRotationMatrix(wn),s.x=h,s.y=d,s.z=p,this}makePerspective(t,e,s,a,h,d){d===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const p=this.elements,g=2*h/(e-t),_=2*h/(s-a),v=(e+t)/(e-t),b=(s+a)/(s-a),M=-(d+h)/(d-h),S=-2*d*h/(d-h);return p[0]=g,p[4]=0,p[8]=v,p[12]=0,p[1]=0,p[5]=_,p[9]=b,p[13]=0,p[2]=0,p[6]=0,p[10]=M,p[14]=S,p[3]=0,p[7]=0,p[11]=-1,p[15]=0,this}makeOrthographic(t,e,s,a,h,d){const p=this.elements,g=1/(e-t),_=1/(s-a),v=1/(d-h),b=(e+t)*g,M=(s+a)*_,S=(d+h)*v;return p[0]=2*g,p[4]=0,p[8]=0,p[12]=-b,p[1]=0,p[5]=2*_,p[9]=0,p[13]=-M,p[2]=0,p[6]=0,p[10]=-2*v,p[14]=-S,p[3]=0,p[7]=0,p[11]=0,p[15]=1,this}equals(t){const e=this.elements,s=t.elements;for(let a=0;a<16;a++)if(e[a]!==s[a])return!1;return!0}fromArray(t,e=0){for(let s=0;s<16;s++)this.elements[s]=t[s+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t[e+9]=s[9],t[e+10]=s[10],t[e+11]=s[11],t[e+12]=s[12],t[e+13]=s[13],t[e+14]=s[14],t[e+15]=s[15],t}}jt.prototype.isMatrix4=!0;const ss=new N,wn=new jt,G0=new N(0,0,0),X0=new N(1,1,1),li=new N,Do=new N,un=new N,bd=new jt,Md=new sn;class rs{constructor(t=0,e=0,s=0,a=rs.DefaultOrder){this._x=t,this._y=e,this._z=s,this._order=a}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,s,a=this._order){return this._x=t,this._y=e,this._z=s,this._order=a,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,s=!0){const a=t.elements,h=a[0],d=a[4],p=a[8],g=a[1],_=a[5],v=a[9],b=a[2],M=a[6],S=a[10];switch(e){case"XYZ":this._y=Math.asin(cn(p,-1,1)),Math.abs(p)<.9999999?(this._x=Math.atan2(-v,S),this._z=Math.atan2(-d,h)):(this._x=Math.atan2(M,_),this._z=0);break;case"YXZ":this._x=Math.asin(-cn(v,-1,1)),Math.abs(v)<.9999999?(this._y=Math.atan2(p,S),this._z=Math.atan2(g,_)):(this._y=Math.atan2(-b,h),this._z=0);break;case"ZXY":this._x=Math.asin(cn(M,-1,1)),Math.abs(M)<.9999999?(this._y=Math.atan2(-b,S),this._z=Math.atan2(-d,_)):(this._y=0,this._z=Math.atan2(g,h));break;case"ZYX":this._y=Math.asin(-cn(b,-1,1)),Math.abs(b)<.9999999?(this._x=Math.atan2(M,S),this._z=Math.atan2(g,h)):(this._x=0,this._z=Math.atan2(-d,_));break;case"YZX":this._z=Math.asin(cn(g,-1,1)),Math.abs(g)<.9999999?(this._x=Math.atan2(-v,_),this._y=Math.atan2(-b,h)):(this._x=0,this._y=Math.atan2(p,S));break;case"XZY":this._z=Math.asin(-cn(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(M,_),this._y=Math.atan2(p,h)):(this._x=Math.atan2(-v,S),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,s===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,s){return bd.makeRotationFromQuaternion(t),this.setFromRotationMatrix(bd,e,s)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Md.setFromEuler(this),this.setFromQuaternion(Md,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new N(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}rs.prototype.isEuler=!0;rs.DefaultOrder="XYZ";rs.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class j0{constructor(){this.mask=1|0}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=4294967295|0}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!=0}}let q0=0;const wd=new N,os=new sn,Wn=new jt,Io=new N,hr=new N,Y0=new N,$0=new sn,Sd=new N(1,0,0),Td=new N(0,1,0),Ed=new N(0,0,1),Z0={type:"added"},Ad={type:"removed"};class de extends Ci{constructor(){super();Object.defineProperty(this,"id",{value:q0++}),this.uuid=In(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=de.DefaultUp.clone();const t=new N,e=new rs,s=new sn,a=new N(1,1,1);function h(){s.setFromEuler(e,!1)}function d(){e.setFromQuaternion(s,void 0,!1)}e._onChange(h),s._onChange(d),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:s},scale:{configurable:!0,enumerable:!0,value:a},modelViewMatrix:{value:new jt},normalMatrix:{value:new Ge}}),this.matrix=new jt,this.matrixWorld=new jt,this.matrixAutoUpdate=de.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new j0,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return os.setFromAxisAngle(t,e),this.quaternion.multiply(os),this}rotateOnWorldAxis(t,e){return os.setFromAxisAngle(t,e),this.quaternion.premultiply(os),this}rotateX(t){return this.rotateOnAxis(Sd,t)}rotateY(t){return this.rotateOnAxis(Td,t)}rotateZ(t){return this.rotateOnAxis(Ed,t)}translateOnAxis(t,e){return wd.copy(t).applyQuaternion(this.quaternion),this.position.add(wd.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(Sd,t)}translateY(t){return this.translateOnAxis(Td,t)}translateZ(t){return this.translateOnAxis(Ed,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(Wn.copy(this.matrixWorld).invert())}lookAt(t,e,s){t.isVector3?Io.copy(t):Io.set(t,e,s);const a=this.parent;this.updateWorldMatrix(!0,!1),hr.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Wn.lookAt(hr,Io,this.up):Wn.lookAt(Io,hr,this.up),this.quaternion.setFromRotationMatrix(Wn),a&&(Wn.extractRotation(a.matrixWorld),os.setFromRotationMatrix(Wn),this.quaternion.premultiply(os.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.parent!==null&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(Z0)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let s=0;s<arguments.length;s++)this.remove(arguments[s]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(Ad)),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(Ad)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),Wn.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),Wn.multiply(t.parent.matrixWorld)),t.applyMatrix4(Wn),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let s=0,a=this.children.length;s<a;s++){const d=this.children[s].getObjectByProperty(t,e);if(d!==void 0)return d}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(hr,t,Y0),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(hr,$0,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let s=0,a=e.length;s<a;s++)e[s].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let s=0,a=e.length;s<a;s++)e[s].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let s=0,a=e.length;s<a;s++)e[s].updateMatrixWorld(t)}updateWorldMatrix(t,e){const s=this.parent;if(t===!0&&s!==null&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const a=this.children;for(let h=0,d=a.length;h<d;h++)a[h].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",s={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},s.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const a={};a.uuid=this.uuid,a.type=this.type,this.name!==""&&(a.name=this.name),this.castShadow===!0&&(a.castShadow=!0),this.receiveShadow===!0&&(a.receiveShadow=!0),this.visible===!1&&(a.visible=!1),this.frustumCulled===!1&&(a.frustumCulled=!1),this.renderOrder!==0&&(a.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(a.userData=this.userData),a.layers=this.layers.mask,a.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(a.matrixAutoUpdate=!1),this.isInstancedMesh&&(a.type="InstancedMesh",a.count=this.count,a.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(a.instanceColor=this.instanceColor.toJSON()));function h(p,g){return p[g.uuid]===void 0&&(p[g.uuid]=g.toJSON(t)),g.uuid}if(this.isScene)this.background&&(this.background.isColor?a.background=this.background.toJSON():this.background.isTexture&&(a.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&(a.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){a.geometry=h(t.geometries,this.geometry);const p=this.geometry.parameters;if(p!==void 0&&p.shapes!==void 0){const g=p.shapes;if(Array.isArray(g))for(let _=0,v=g.length;_<v;_++){const b=g[_];h(t.shapes,b)}else h(t.shapes,g)}}if(this.isSkinnedMesh&&(a.bindMode=this.bindMode,a.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(h(t.skeletons,this.skeleton),a.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const p=[];for(let g=0,_=this.material.length;g<_;g++)p.push(h(t.materials,this.material[g]));a.material=p}else a.material=h(t.materials,this.material);if(this.children.length>0){a.children=[];for(let p=0;p<this.children.length;p++)a.children.push(this.children[p].toJSON(t).object)}if(this.animations.length>0){a.animations=[];for(let p=0;p<this.animations.length;p++){const g=this.animations[p];a.animations.push(h(t.animations,g))}}if(e){const p=d(t.geometries),g=d(t.materials),_=d(t.textures),v=d(t.images),b=d(t.shapes),M=d(t.skeletons),S=d(t.animations);p.length>0&&(s.geometries=p),g.length>0&&(s.materials=g),_.length>0&&(s.textures=_),v.length>0&&(s.images=v),b.length>0&&(s.shapes=b),M.length>0&&(s.skeletons=M),S.length>0&&(s.animations=S)}return s.object=a,s;function d(p){const g=[];for(const _ in p){const v=p[_];delete v.metadata,g.push(v)}return g}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let s=0;s<t.children.length;s++){const a=t.children[s];this.add(a.clone())}return this}}de.DefaultUp=new N(0,1,0);de.DefaultMatrixAutoUpdate=!0;de.prototype.isObject3D=!0;const Sn=new N,Gn=new N,Fl=new N,Xn=new N,as=new N,ls=new N,Ld=new N,kl=new N,Ol=new N,Bl=new N;class Pe{constructor(t=new N,e=new N,s=new N){this.a=t,this.b=e,this.c=s}static getNormal(t,e,s,a){a.subVectors(s,e),Sn.subVectors(t,e),a.cross(Sn);const h=a.lengthSq();return h>0?a.multiplyScalar(1/Math.sqrt(h)):a.set(0,0,0)}static getBarycoord(t,e,s,a,h){Sn.subVectors(a,e),Gn.subVectors(s,e),Fl.subVectors(t,e);const d=Sn.dot(Sn),p=Sn.dot(Gn),g=Sn.dot(Fl),_=Gn.dot(Gn),v=Gn.dot(Fl),b=d*_-p*p;if(b===0)return h.set(-2,-1,-1);const M=1/b,S=(_*g-p*v)*M,L=(d*v-p*g)*M;return h.set(1-S-L,L,S)}static containsPoint(t,e,s,a){return this.getBarycoord(t,e,s,a,Xn),Xn.x>=0&&Xn.y>=0&&Xn.x+Xn.y<=1}static getUV(t,e,s,a,h,d,p,g){return this.getBarycoord(t,e,s,a,Xn),g.set(0,0),g.addScaledVector(h,Xn.x),g.addScaledVector(d,Xn.y),g.addScaledVector(p,Xn.z),g}static isFrontFacing(t,e,s,a){return Sn.subVectors(s,e),Gn.subVectors(t,e),Sn.cross(Gn).dot(a)<0}set(t,e,s){return this.a.copy(t),this.b.copy(e),this.c.copy(s),this}setFromPointsAndIndices(t,e,s,a){return this.a.copy(t[e]),this.b.copy(t[s]),this.c.copy(t[a]),this}setFromAttributeAndIndices(t,e,s,a){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,s),this.c.fromBufferAttribute(t,a),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return Sn.subVectors(this.c,this.b),Gn.subVectors(this.a,this.b),Sn.cross(Gn).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return Pe.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return Pe.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,s,a,h){return Pe.getUV(t,this.a,this.b,this.c,e,s,a,h)}containsPoint(t){return Pe.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return Pe.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const s=this.a,a=this.b,h=this.c;let d,p;as.subVectors(a,s),ls.subVectors(h,s),kl.subVectors(t,s);const g=as.dot(kl),_=ls.dot(kl);if(g<=0&&_<=0)return e.copy(s);Ol.subVectors(t,a);const v=as.dot(Ol),b=ls.dot(Ol);if(v>=0&&b<=v)return e.copy(a);const M=g*b-v*_;if(M<=0&&g>=0&&v<=0)return d=g/(g-v),e.copy(s).addScaledVector(as,d);Bl.subVectors(t,h);const S=as.dot(Bl),L=ls.dot(Bl);if(L>=0&&S<=L)return e.copy(h);const C=S*_-g*L;if(C<=0&&_>=0&&L<=0)return p=_/(_-L),e.copy(s).addScaledVector(ls,p);const k=v*L-S*b;if(k<=0&&b-v>=0&&S-L>=0)return Ld.subVectors(h,a),p=(b-v)/(b-v+(S-L)),e.copy(a).addScaledVector(Ld,p);const T=1/(k+C+M);return d=C*T,p=M*T,e.copy(s).addScaledVector(as,d).addScaledVector(ls,p)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let J0=0;class Ye extends Ci{constructor(){super();Object.defineProperty(this,"id",{value:J0++}),this.uuid=In(),this.name="",this.type="Material",this.fog=!0,this.blending=rr,this.side=sr,this.vertexColors=!1,this.opacity=1,this.format=tn,this.transparent=!1,this.blendSrc=Zh,this.blendDst=Jh,this.blendEquation=Gi,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=hl,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=B0,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=bl,this.stencilZFail=bl,this.stencilZPass=bl,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const s=t[e];if(s===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=s===Gh;continue}const a=this[e];if(a===void 0){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}a&&a.isColor?a.set(s):a&&a.isVector3&&s&&s.isVector3?a.copy(s):this[e]=s}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const s={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.color&&this.color.isColor&&(s.color=this.color.getHex()),this.roughness!==void 0&&(s.roughness=this.roughness),this.metalness!==void 0&&(s.metalness=this.metalness),this.sheen!==void 0&&(s.sheen=this.sheen),this.sheenTint&&this.sheenTint.isColor&&(s.sheenTint=this.sheenTint.getHex()),this.sheenRoughness!==void 0&&(s.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(s.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(s.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(s.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(s.specularIntensity=this.specularIntensity),this.specularTint&&this.specularTint.isColor&&(s.specularTint=this.specularTint.getHex()),this.shininess!==void 0&&(s.shininess=this.shininess),this.clearcoat!==void 0&&(s.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(s.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(s.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(s.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,s.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(s.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(s.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(s.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(s.lightMap=this.lightMap.toJSON(t).uuid,s.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(s.aoMap=this.aoMap.toJSON(t).uuid,s.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(s.bumpMap=this.bumpMap.toJSON(t).uuid,s.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(s.normalMap=this.normalMap.toJSON(t).uuid,s.normalMapType=this.normalMapType,s.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(s.displacementMap=this.displacementMap.toJSON(t).uuid,s.displacementScale=this.displacementScale,s.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(s.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(s.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(s.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(s.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(s.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularTintMap&&this.specularTintMap.isTexture&&(s.specularTintMap=this.specularTintMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(s.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(s.combine=this.combine)),this.envMapIntensity!==void 0&&(s.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(s.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(s.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(s.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(s.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(s.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(s.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(s.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&(s.attenuationDistance=this.attenuationDistance),this.attenuationTint!==void 0&&(s.attenuationTint=this.attenuationTint.getHex()),this.size!==void 0&&(s.size=this.size),this.shadowSide!==null&&(s.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(s.sizeAttenuation=this.sizeAttenuation),this.blending!==rr&&(s.blending=this.blending),this.side!==sr&&(s.side=this.side),this.vertexColors&&(s.vertexColors=!0),this.opacity<1&&(s.opacity=this.opacity),this.format!==tn&&(s.format=this.format),this.transparent===!0&&(s.transparent=this.transparent),s.depthFunc=this.depthFunc,s.depthTest=this.depthTest,s.depthWrite=this.depthWrite,s.colorWrite=this.colorWrite,s.stencilWrite=this.stencilWrite,s.stencilWriteMask=this.stencilWriteMask,s.stencilFunc=this.stencilFunc,s.stencilRef=this.stencilRef,s.stencilFuncMask=this.stencilFuncMask,s.stencilFail=this.stencilFail,s.stencilZFail=this.stencilZFail,s.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(s.rotation=this.rotation),this.polygonOffset===!0&&(s.polygonOffset=!0),this.polygonOffsetFactor!==0&&(s.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(s.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(s.linewidth=this.linewidth),this.dashSize!==void 0&&(s.dashSize=this.dashSize),this.gapSize!==void 0&&(s.gapSize=this.gapSize),this.scale!==void 0&&(s.scale=this.scale),this.dithering===!0&&(s.dithering=!0),this.alphaTest>0&&(s.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(s.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(s.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(s.wireframe=this.wireframe),this.wireframeLinewidth>1&&(s.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(s.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(s.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(s.flatShading=this.flatShading),this.visible===!1&&(s.visible=!1),this.toneMapped===!1&&(s.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(s.userData=this.userData);function a(h){const d=[];for(const p in h){const g=h[p];delete g.metadata,d.push(g)}return d}if(e){const h=a(t.textures),d=a(t.images);h.length>0&&(s.textures=h),d.length>0&&(s.images=d)}return s}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.format=t.format,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let s=null;if(e!==null){const a=e.length;s=new Array(a);for(let h=0;h!==a;++h)s[h]=e[h].clone()}return this.clippingPlanes=s,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}}Ye.prototype.isMaterial=!0;const Cd={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Tn={h:0,s:0,l:0},Fo={h:0,s:0,l:0};function zl(c,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?c+(t-c)*6*e:e<1/2?t:e<2/3?c+(t-c)*6*(2/3-e):c}function Nl(c){return c<.04045?c*.0773993808:Math.pow(c*.9478672986+.0521327014,2.4)}function Vl(c){return c<.0031308?c*12.92:1.055*Math.pow(c,.41666)-.055}class Ht{constructor(t,e,s){return e===void 0&&s===void 0?this.set(t):this.setRGB(t,e,s)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,this}setRGB(t,e,s){return this.r=t,this.g=e,this.b=s,this}setHSL(t,e,s){if(t=N0(t,1),e=cn(e,0,1),s=cn(s,0,1),e===0)this.r=this.g=this.b=s;else{const a=s<=.5?s*(1+e):s+e-s*e,h=2*s-a;this.r=zl(h,a,t+1/3),this.g=zl(h,a,t),this.b=zl(h,a,t-1/3)}return this}setStyle(t){function e(a){a!==void 0&&parseFloat(a)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let s;if(s=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let a;const h=s[1],d=s[2];switch(h){case"rgb":case"rgba":if(a=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))return this.r=Math.min(255,parseInt(a[1],10))/255,this.g=Math.min(255,parseInt(a[2],10))/255,this.b=Math.min(255,parseInt(a[3],10))/255,e(a[4]),this;if(a=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))return this.r=Math.min(100,parseInt(a[1],10))/100,this.g=Math.min(100,parseInt(a[2],10))/100,this.b=Math.min(100,parseInt(a[3],10))/100,e(a[4]),this;break;case"hsl":case"hsla":if(a=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d)){const p=parseFloat(a[1])/360,g=parseInt(a[2],10)/100,_=parseInt(a[3],10)/100;return e(a[4]),this.setHSL(p,g,_)}break}}else if(s=/^\#([A-Fa-f\d]+)$/.exec(t)){const a=s[1],h=a.length;if(h===3)return this.r=parseInt(a.charAt(0)+a.charAt(0),16)/255,this.g=parseInt(a.charAt(1)+a.charAt(1),16)/255,this.b=parseInt(a.charAt(2)+a.charAt(2),16)/255,this;if(h===6)return this.r=parseInt(a.charAt(0)+a.charAt(1),16)/255,this.g=parseInt(a.charAt(2)+a.charAt(3),16)/255,this.b=parseInt(a.charAt(4)+a.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=Cd[t.toLowerCase()];return e!==void 0?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,e=2){return this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this}copyLinearToGamma(t,e=2){const s=e>0?1/e:1;return this.r=Math.pow(t.r,s),this.g=Math.pow(t.g,s),this.b=Math.pow(t.b,s),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=Nl(t.r),this.g=Nl(t.g),this.b=Nl(t.b),this}copyLinearToSRGB(t){return this.r=Vl(t.r),this.g=Vl(t.g),this.b=Vl(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){const e=this.r,s=this.g,a=this.b,h=Math.max(e,s,a),d=Math.min(e,s,a);let p,g;const _=(d+h)/2;if(d===h)p=0,g=0;else{const v=h-d;switch(g=_<=.5?v/(h+d):v/(2-h-d),h){case e:p=(s-a)/v+(s<a?6:0);break;case s:p=(a-e)/v+2;break;case a:p=(e-s)/v+4;break}p/=6}return t.h=p,t.s=g,t.l=_,t}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(t,e,s){return this.getHSL(Tn),Tn.h+=t,Tn.s+=e,Tn.l+=s,this.setHSL(Tn.h,Tn.s,Tn.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,s){return this.r=t.r+(e.r-t.r)*s,this.g=t.g+(e.g-t.g)*s,this.b=t.b+(e.b-t.b)*s,this}lerpHSL(t,e){this.getHSL(Tn),t.getHSL(Fo);const s=Sl(Tn.h,Fo.h,e),a=Sl(Tn.s,Fo.s,e),h=Sl(Tn.l,Fo.l,e);return this.setHSL(s,a,h),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),t.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Ht.NAMES=Cd;Ht.prototype.isColor=!0;Ht.prototype.r=1;Ht.prototype.g=1;Ht.prototype.b=1;class Ul extends Ye{constructor(t){super();this.type="MeshBasicMaterial",this.color=new Ht(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=go,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}Ul.prototype.isMeshBasicMaterial=!0;const _e=new N,ko=new Mt;class Oe{constructor(t,e,s){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=s===!0,this.usage=lr,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,s){t*=this.itemSize,s*=e.itemSize;for(let a=0,h=this.itemSize;a<h;a++)this.array[t+a]=e.array[s+a];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let s=0;for(let a=0,h=t.length;a<h;a++){let d=t[a];d===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",a),d=new Ht),e[s++]=d.r,e[s++]=d.g,e[s++]=d.b}return this}copyVector2sArray(t){const e=this.array;let s=0;for(let a=0,h=t.length;a<h;a++){let d=t[a];d===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",a),d=new Mt),e[s++]=d.x,e[s++]=d.y}return this}copyVector3sArray(t){const e=this.array;let s=0;for(let a=0,h=t.length;a<h;a++){let d=t[a];d===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",a),d=new N),e[s++]=d.x,e[s++]=d.y,e[s++]=d.z}return this}copyVector4sArray(t){const e=this.array;let s=0;for(let a=0,h=t.length;a<h;a++){let d=t[a];d===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",a),d=new ge),e[s++]=d.x,e[s++]=d.y,e[s++]=d.z,e[s++]=d.w}return this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,s=this.count;e<s;e++)ko.fromBufferAttribute(this,e),ko.applyMatrix3(t),this.setXY(e,ko.x,ko.y);else if(this.itemSize===3)for(let e=0,s=this.count;e<s;e++)_e.fromBufferAttribute(this,e),_e.applyMatrix3(t),this.setXYZ(e,_e.x,_e.y,_e.z);return this}applyMatrix4(t){for(let e=0,s=this.count;e<s;e++)_e.x=this.getX(e),_e.y=this.getY(e),_e.z=this.getZ(e),_e.applyMatrix4(t),this.setXYZ(e,_e.x,_e.y,_e.z);return this}applyNormalMatrix(t){for(let e=0,s=this.count;e<s;e++)_e.x=this.getX(e),_e.y=this.getY(e),_e.z=this.getZ(e),_e.applyNormalMatrix(t),this.setXYZ(e,_e.x,_e.y,_e.z);return this}transformDirection(t){for(let e=0,s=this.count;e<s;e++)_e.x=this.getX(e),_e.y=this.getY(e),_e.z=this.getZ(e),_e.transformDirection(t),this.setXYZ(e,_e.x,_e.y,_e.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,s){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=s,this}setXYZ(t,e,s,a){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=s,this.array[t+2]=a,this}setXYZW(t,e,s,a,h){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=s,this.array[t+2]=a,this.array[t+3]=h,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==lr&&(t.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(t.updateRange=this.updateRange),t}}Oe.prototype.isBufferAttribute=!0;class Rd extends Oe{constructor(t,e,s){super(new Uint16Array(t),e,s)}}class Pd extends Oe{constructor(t,e,s){super(new Uint32Array(t),e,s)}}class K0 extends Oe{constructor(t,e,s){super(new Uint16Array(t),e,s)}}K0.prototype.isFloat16BufferAttribute=!0;class Ae extends Oe{constructor(t,e,s){super(new Float32Array(t),e,s)}}let Q0=0;const _n=new jt,Hl=new de,cs=new N,hn=new Mn,dr=new Mn,Ve=new N;class ve extends Ci{constructor(){super();Object.defineProperty(this,"id",{value:Q0++}),this.uuid=In(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(xd(t)>65535?Pd:Rd)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,s=0){this.groups.push({start:t,count:e,materialIndex:s})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const s=this.attributes.normal;if(s!==void 0){const h=new Ge().getNormalMatrix(t);s.applyNormalMatrix(h),s.needsUpdate=!0}const a=this.attributes.tangent;return a!==void 0&&(a.transformDirection(t),a.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return _n.makeRotationFromQuaternion(t),this.applyMatrix4(_n),this}rotateX(t){return _n.makeRotationX(t),this.applyMatrix4(_n),this}rotateY(t){return _n.makeRotationY(t),this.applyMatrix4(_n),this}rotateZ(t){return _n.makeRotationZ(t),this.applyMatrix4(_n),this}translate(t,e,s){return _n.makeTranslation(t,e,s),this.applyMatrix4(_n),this}scale(t,e,s){return _n.makeScale(t,e,s),this.applyMatrix4(_n),this}lookAt(t){return Hl.lookAt(t),Hl.updateMatrix(),this.applyMatrix4(Hl.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(cs).negate(),this.translate(cs.x,cs.y,cs.z),this}setFromPoints(t){const e=[];for(let s=0,a=t.length;s<a;s++){const h=t[s];e.push(h.x,h.y,h.z||0)}return this.setAttribute("position",new Ae(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Mn);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new N(-1/0,-1/0,-1/0),new N(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let s=0,a=e.length;s<a;s++){const h=e[s];hn.setFromBufferAttribute(h),this.morphTargetsRelative?(Ve.addVectors(this.boundingBox.min,hn.min),this.boundingBox.expandByPoint(Ve),Ve.addVectors(this.boundingBox.max,hn.max),this.boundingBox.expandByPoint(Ve)):(this.boundingBox.expandByPoint(hn.min),this.boundingBox.expandByPoint(hn.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new ns);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new N,1/0);return}if(t){const s=this.boundingSphere.center;if(hn.setFromBufferAttribute(t),e)for(let h=0,d=e.length;h<d;h++){const p=e[h];dr.setFromBufferAttribute(p),this.morphTargetsRelative?(Ve.addVectors(hn.min,dr.min),hn.expandByPoint(Ve),Ve.addVectors(hn.max,dr.max),hn.expandByPoint(Ve)):(hn.expandByPoint(dr.min),hn.expandByPoint(dr.max))}hn.getCenter(s);let a=0;for(let h=0,d=t.count;h<d;h++)Ve.fromBufferAttribute(t,h),a=Math.max(a,s.distanceToSquared(Ve));if(e)for(let h=0,d=e.length;h<d;h++){const p=e[h],g=this.morphTargetsRelative;for(let _=0,v=p.count;_<v;_++)Ve.fromBufferAttribute(p,_),g&&(cs.fromBufferAttribute(t,_),Ve.add(cs)),a=Math.max(a,s.distanceToSquared(Ve))}this.boundingSphere.radius=Math.sqrt(a),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const s=t.array,a=e.position.array,h=e.normal.array,d=e.uv.array,p=a.length/3;e.tangent===void 0&&this.setAttribute("tangent",new Oe(new Float32Array(4*p),4));const g=e.tangent.array,_=[],v=[];for(let ut=0;ut<p;ut++)_[ut]=new N,v[ut]=new N;const b=new N,M=new N,S=new N,L=new Mt,C=new Mt,k=new Mt,T=new N,E=new N;function z(ut,X,ht){b.fromArray(a,ut*3),M.fromArray(a,X*3),S.fromArray(a,ht*3),L.fromArray(d,ut*2),C.fromArray(d,X*2),k.fromArray(d,ht*2),M.sub(b),S.sub(b),C.sub(L),k.sub(L);const it=1/(C.x*k.y-k.x*C.y);!isFinite(it)||(T.copy(M).multiplyScalar(k.y).addScaledVector(S,-C.y).multiplyScalar(it),E.copy(S).multiplyScalar(C.x).addScaledVector(M,-k.x).multiplyScalar(it),_[ut].add(T),_[X].add(T),_[ht].add(T),v[ut].add(E),v[X].add(E),v[ht].add(E))}let I=this.groups;I.length===0&&(I=[{start:0,count:s.length}]);for(let ut=0,X=I.length;ut<X;++ut){const ht=I[ut],it=ht.start,Q=ht.count;for(let rt=it,tt=it+Q;rt<tt;rt+=3)z(s[rt+0],s[rt+1],s[rt+2])}const V=new N,G=new N,F=new N,K=new N;function pt(ut){F.fromArray(h,ut*3),K.copy(F);const X=_[ut];V.copy(X),V.sub(F.multiplyScalar(F.dot(X))).normalize(),G.crossVectors(K,X);const it=G.dot(v[ut])<0?-1:1;g[ut*4]=V.x,g[ut*4+1]=V.y,g[ut*4+2]=V.z,g[ut*4+3]=it}for(let ut=0,X=I.length;ut<X;++ut){const ht=I[ut],it=ht.start,Q=ht.count;for(let rt=it,tt=it+Q;rt<tt;rt+=3)pt(s[rt+0]),pt(s[rt+1]),pt(s[rt+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let s=this.getAttribute("normal");if(s===void 0)s=new Oe(new Float32Array(e.count*3),3),this.setAttribute("normal",s);else for(let M=0,S=s.count;M<S;M++)s.setXYZ(M,0,0,0);const a=new N,h=new N,d=new N,p=new N,g=new N,_=new N,v=new N,b=new N;if(t)for(let M=0,S=t.count;M<S;M+=3){const L=t.getX(M+0),C=t.getX(M+1),k=t.getX(M+2);a.fromBufferAttribute(e,L),h.fromBufferAttribute(e,C),d.fromBufferAttribute(e,k),v.subVectors(d,h),b.subVectors(a,h),v.cross(b),p.fromBufferAttribute(s,L),g.fromBufferAttribute(s,C),_.fromBufferAttribute(s,k),p.add(v),g.add(v),_.add(v),s.setXYZ(L,p.x,p.y,p.z),s.setXYZ(C,g.x,g.y,g.z),s.setXYZ(k,_.x,_.y,_.z)}else for(let M=0,S=e.count;M<S;M+=3)a.fromBufferAttribute(e,M+0),h.fromBufferAttribute(e,M+1),d.fromBufferAttribute(e,M+2),v.subVectors(d,h),b.subVectors(a,h),v.cross(b),s.setXYZ(M+0,v.x,v.y,v.z),s.setXYZ(M+1,v.x,v.y,v.z),s.setXYZ(M+2,v.x,v.y,v.z);this.normalizeNormals(),s.needsUpdate=!0}}merge(t,e){if(!(t&&t.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);return}e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const s=this.attributes;for(const a in s){if(t.attributes[a]===void 0)continue;const d=s[a].array,p=t.attributes[a],g=p.array,_=p.itemSize*e,v=Math.min(g.length,d.length-_);for(let b=0,M=_;b<v;b++,M++)d[M]=g[b]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,s=t.count;e<s;e++)Ve.fromBufferAttribute(t,e),Ve.normalize(),t.setXYZ(e,Ve.x,Ve.y,Ve.z)}toNonIndexed(){function t(p,g){const _=p.array,v=p.itemSize,b=p.normalized,M=new _.constructor(g.length*v);let S=0,L=0;for(let C=0,k=g.length;C<k;C++){p.isInterleavedBufferAttribute?S=g[C]*p.data.stride+p.offset:S=g[C]*v;for(let T=0;T<v;T++)M[L++]=_[S++]}return new Oe(M,v,b)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new ve,s=this.index.array,a=this.attributes;for(const p in a){const g=a[p],_=t(g,s);e.setAttribute(p,_)}const h=this.morphAttributes;for(const p in h){const g=[],_=h[p];for(let v=0,b=_.length;v<b;v++){const M=_[v],S=t(M,s);g.push(S)}e.morphAttributes[p]=g}e.morphTargetsRelative=this.morphTargetsRelative;const d=this.groups;for(let p=0,g=d.length;p<g;p++){const _=d[p];e.addGroup(_.start,_.count,_.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const g=this.parameters;for(const _ in g)g[_]!==void 0&&(t[_]=g[_]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const s=this.attributes;for(const g in s){const _=s[g];t.data.attributes[g]=_.toJSON(t.data)}const a={};let h=!1;for(const g in this.morphAttributes){const _=this.morphAttributes[g],v=[];for(let b=0,M=_.length;b<M;b++){const S=_[b];v.push(S.toJSON(t.data))}v.length>0&&(a[g]=v,h=!0)}h&&(t.data.morphAttributes=a,t.data.morphTargetsRelative=this.morphTargetsRelative);const d=this.groups;d.length>0&&(t.data.groups=JSON.parse(JSON.stringify(d)));const p=this.boundingSphere;return p!==null&&(t.data.boundingSphere={center:p.center.toArray(),radius:p.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const s=t.index;s!==null&&this.setIndex(s.clone(e));const a=t.attributes;for(const _ in a){const v=a[_];this.setAttribute(_,v.clone(e))}const h=t.morphAttributes;for(const _ in h){const v=[],b=h[_];for(let M=0,S=b.length;M<S;M++)v.push(b[M].clone(e));this.morphAttributes[_]=v}this.morphTargetsRelative=t.morphTargetsRelative;const d=t.groups;for(let _=0,v=d.length;_<v;_++){const b=d[_];this.addGroup(b.start,b.count,b.materialIndex)}const p=t.boundingBox;p!==null&&(this.boundingBox=p.clone());const g=t.boundingSphere;return g!==null&&(this.boundingSphere=g.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,t.parameters!==void 0&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}ve.prototype.isBufferGeometry=!0;const Dd=new jt,us=new is,Wl=new ns,ci=new N,ui=new N,hi=new N,Gl=new N,Xl=new N,jl=new N,Oo=new N,Bo=new N,zo=new N,No=new Mt,Vo=new Mt,Uo=new Mt,ql=new N,Ho=new N;class rn extends de{constructor(t=new ve,e=new Ul){super();this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,s=Object.keys(e);if(s.length>0){const a=e[s[0]];if(a!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let h=0,d=a.length;h<d;h++){const p=a[h].name||String(h);this.morphTargetInfluences.push(0),this.morphTargetDictionary[p]=h}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){const s=this.geometry,a=this.material,h=this.matrixWorld;if(a===void 0||(s.boundingSphere===null&&s.computeBoundingSphere(),Wl.copy(s.boundingSphere),Wl.applyMatrix4(h),t.ray.intersectsSphere(Wl)===!1)||(Dd.copy(h).invert(),us.copy(t.ray).applyMatrix4(Dd),s.boundingBox!==null&&us.intersectsBox(s.boundingBox)===!1))return;let d;if(s.isBufferGeometry){const p=s.index,g=s.attributes.position,_=s.morphAttributes.position,v=s.morphTargetsRelative,b=s.attributes.uv,M=s.attributes.uv2,S=s.groups,L=s.drawRange;if(p!==null)if(Array.isArray(a))for(let C=0,k=S.length;C<k;C++){const T=S[C],E=a[T.materialIndex],z=Math.max(T.start,L.start),I=Math.min(p.count,Math.min(T.start+T.count,L.start+L.count));for(let V=z,G=I;V<G;V+=3){const F=p.getX(V),K=p.getX(V+1),pt=p.getX(V+2);d=Wo(this,E,t,us,g,_,v,b,M,F,K,pt),d&&(d.faceIndex=Math.floor(V/3),d.face.materialIndex=T.materialIndex,e.push(d))}}else{const C=Math.max(0,L.start),k=Math.min(p.count,L.start+L.count);for(let T=C,E=k;T<E;T+=3){const z=p.getX(T),I=p.getX(T+1),V=p.getX(T+2);d=Wo(this,a,t,us,g,_,v,b,M,z,I,V),d&&(d.faceIndex=Math.floor(T/3),e.push(d))}}else if(g!==void 0)if(Array.isArray(a))for(let C=0,k=S.length;C<k;C++){const T=S[C],E=a[T.materialIndex],z=Math.max(T.start,L.start),I=Math.min(g.count,Math.min(T.start+T.count,L.start+L.count));for(let V=z,G=I;V<G;V+=3){const F=V,K=V+1,pt=V+2;d=Wo(this,E,t,us,g,_,v,b,M,F,K,pt),d&&(d.faceIndex=Math.floor(V/3),d.face.materialIndex=T.materialIndex,e.push(d))}}else{const C=Math.max(0,L.start),k=Math.min(g.count,L.start+L.count);for(let T=C,E=k;T<E;T+=3){const z=T,I=T+1,V=T+2;d=Wo(this,a,t,us,g,_,v,b,M,z,I,V),d&&(d.faceIndex=Math.floor(T/3),e.push(d))}}}else s.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}rn.prototype.isMesh=!0;function ty(c,t,e,s,a,h,d,p){let g;if(t.side===ke?g=s.intersectTriangle(d,h,a,!0,p):g=s.intersectTriangle(a,h,d,t.side!==Wi,p),g===null)return null;Ho.copy(p),Ho.applyMatrix4(c.matrixWorld);const _=e.ray.origin.distanceTo(Ho);return _<e.near||_>e.far?null:{distance:_,point:Ho.clone(),object:c}}function Wo(c,t,e,s,a,h,d,p,g,_,v,b){ci.fromBufferAttribute(a,_),ui.fromBufferAttribute(a,v),hi.fromBufferAttribute(a,b);const M=c.morphTargetInfluences;if(h&&M){Oo.set(0,0,0),Bo.set(0,0,0),zo.set(0,0,0);for(let L=0,C=h.length;L<C;L++){const k=M[L],T=h[L];k!==0&&(Gl.fromBufferAttribute(T,_),Xl.fromBufferAttribute(T,v),jl.fromBufferAttribute(T,b),d?(Oo.addScaledVector(Gl,k),Bo.addScaledVector(Xl,k),zo.addScaledVector(jl,k)):(Oo.addScaledVector(Gl.sub(ci),k),Bo.addScaledVector(Xl.sub(ui),k),zo.addScaledVector(jl.sub(hi),k)))}ci.add(Oo),ui.add(Bo),hi.add(zo)}c.isSkinnedMesh&&(c.boneTransform(_,ci),c.boneTransform(v,ui),c.boneTransform(b,hi));const S=ty(c,t,e,s,ci,ui,hi,ql);if(S){p&&(No.fromBufferAttribute(p,_),Vo.fromBufferAttribute(p,v),Uo.fromBufferAttribute(p,b),S.uv=Pe.getUV(ql,ci,ui,hi,No,Vo,Uo,new Mt)),g&&(No.fromBufferAttribute(g,_),Vo.fromBufferAttribute(g,v),Uo.fromBufferAttribute(g,b),S.uv2=Pe.getUV(ql,ci,ui,hi,No,Vo,Uo,new Mt));const L={a:_,b:v,c:b,normal:new N,materialIndex:0};Pe.getNormal(ci,ui,hi,L.normal),S.face=L}return S}class fr extends ve{constructor(t=1,e=1,s=1,a=1,h=1,d=1){super();this.type="BoxGeometry",this.parameters={width:t,height:e,depth:s,widthSegments:a,heightSegments:h,depthSegments:d};const p=this;a=Math.floor(a),h=Math.floor(h),d=Math.floor(d);const g=[],_=[],v=[],b=[];let M=0,S=0;L("z","y","x",-1,-1,s,e,t,d,h,0),L("z","y","x",1,-1,s,e,-t,d,h,1),L("x","z","y",1,1,t,s,e,a,d,2),L("x","z","y",1,-1,t,s,-e,a,d,3),L("x","y","z",1,-1,t,e,s,a,h,4),L("x","y","z",-1,-1,t,e,-s,a,h,5),this.setIndex(g),this.setAttribute("position",new Ae(_,3)),this.setAttribute("normal",new Ae(v,3)),this.setAttribute("uv",new Ae(b,2));function L(C,k,T,E,z,I,V,G,F,K,pt){const ut=I/F,X=V/K,ht=I/2,it=V/2,Q=G/2,rt=F+1,tt=K+1;let st=0,St=0;const Bt=new N;for(let Wt=0;Wt<tt;Wt++){const Pt=Wt*X-it;for(let Zt=0;Zt<rt;Zt++){const ee=Zt*ut-ht;Bt[C]=ee*E,Bt[k]=Pt*z,Bt[T]=Q,_.push(Bt.x,Bt.y,Bt.z),Bt[C]=0,Bt[k]=0,Bt[T]=G>0?1:-1,v.push(Bt.x,Bt.y,Bt.z),b.push(Zt/F),b.push(1-Wt/K),st+=1}}for(let Wt=0;Wt<K;Wt++)for(let Pt=0;Pt<F;Pt++){const Zt=M+Pt+rt*Wt,ee=M+Pt+rt*(Wt+1),re=M+(Pt+1)+rt*(Wt+1),xt=M+(Pt+1)+rt*Wt;g.push(Zt,ee,xt),g.push(ee,re,xt),St+=6}p.addGroup(S,St,pt),S+=St,M+=st}}static fromJSON(t){return new fr(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function hs(c){const t={};for(const e in c){t[e]={};for(const s in c[e]){const a=c[e][s];a&&(a.isColor||a.isMatrix3||a.isMatrix4||a.isVector2||a.isVector3||a.isVector4||a.isTexture||a.isQuaternion)?t[e][s]=a.clone():Array.isArray(a)?t[e][s]=a.slice():t[e][s]=a}}return t}function $e(c){const t={};for(let e=0;e<c.length;e++){const s=hs(c[e]);for(const a in s)t[a]=s[a]}return t}const ey={clone:hs,merge:$e};var ny=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,iy=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Di extends Ye{constructor(t){super();this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=ny,this.fragmentShader=iy,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&(t.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=hs(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const a in this.uniforms){const d=this.uniforms[a].value;d&&d.isTexture?e.uniforms[a]={type:"t",value:d.toJSON(t).uuid}:d&&d.isColor?e.uniforms[a]={type:"c",value:d.getHex()}:d&&d.isVector2?e.uniforms[a]={type:"v2",value:d.toArray()}:d&&d.isVector3?e.uniforms[a]={type:"v3",value:d.toArray()}:d&&d.isVector4?e.uniforms[a]={type:"v4",value:d.toArray()}:d&&d.isMatrix3?e.uniforms[a]={type:"m3",value:d.toArray()}:d&&d.isMatrix4?e.uniforms[a]={type:"m4",value:d.toArray()}:e.uniforms[a]={value:d}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const s={};for(const a in this.extensions)this.extensions[a]===!0&&(s[a]=!0);return Object.keys(s).length>0&&(e.extensions=s),e}}Di.prototype.isShaderMaterial=!0;class Yl extends de{constructor(){super();this.type="Camera",this.matrixWorldInverse=new jt,this.projectionMatrix=new jt,this.projectionMatrixInverse=new jt}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}Yl.prototype.isCamera=!0;class on extends Yl{constructor(t=50,e=1,s=.1,a=2e3){super();this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=s,this.far=a,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=wl*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(Ml*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return wl*2*Math.atan(Math.tan(Ml*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,s,a,h,d){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=s,this.view.offsetY=a,this.view.width=h,this.view.height=d,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(Ml*.5*this.fov)/this.zoom,s=2*e,a=this.aspect*s,h=-.5*a;const d=this.view;if(this.view!==null&&this.view.enabled){const g=d.fullWidth,_=d.fullHeight;h+=d.offsetX*a/g,e-=d.offsetY*s/_,a*=d.width/g,s*=d.height/_}const p=this.filmOffset;p!==0&&(h+=t*p/this.getFilmWidth()),this.projectionMatrix.makePerspective(h,h+a,e,e-s,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}on.prototype.isPerspectiveCamera=!0;const ds=90,fs=1;class $l extends de{constructor(t,e,s){super();if(this.type="CubeCamera",s.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=s;const a=new on(ds,fs,t,e);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new N(1,0,0)),this.add(a);const h=new on(ds,fs,t,e);h.layers=this.layers,h.up.set(0,-1,0),h.lookAt(new N(-1,0,0)),this.add(h);const d=new on(ds,fs,t,e);d.layers=this.layers,d.up.set(0,0,1),d.lookAt(new N(0,1,0)),this.add(d);const p=new on(ds,fs,t,e);p.layers=this.layers,p.up.set(0,0,-1),p.lookAt(new N(0,-1,0)),this.add(p);const g=new on(ds,fs,t,e);g.layers=this.layers,g.up.set(0,-1,0),g.lookAt(new N(0,0,1)),this.add(g);const _=new on(ds,fs,t,e);_.layers=this.layers,_.up.set(0,-1,0),_.lookAt(new N(0,0,-1)),this.add(_)}update(t,e){this.parent===null&&this.updateMatrixWorld();const s=this.renderTarget,[a,h,d,p,g,_]=this.children,v=t.xr.enabled,b=t.getRenderTarget();t.xr.enabled=!1;const M=s.texture.generateMipmaps;s.texture.generateMipmaps=!1,t.setRenderTarget(s,0),t.render(e,a),t.setRenderTarget(s,1),t.render(e,h),t.setRenderTarget(s,2),t.render(e,d),t.setRenderTarget(s,3),t.render(e,p),t.setRenderTarget(s,4),t.render(e,g),s.texture.generateMipmaps=M,t.setRenderTarget(s,5),t.render(e,_),t.setRenderTarget(b),t.xr.enabled=v}}class Go extends Xe{constructor(t,e,s,a,h,d,p,g,_,v){t=t!==void 0?t:[],e=e!==void 0?e:xo;super(t,e,s,a,h,d,p,g,_,v);this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}Go.prototype.isCubeTexture=!0;class Id extends Fn{constructor(t,e,s){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=s);super(t,t,e);e=e||{},this.texture=new Go(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:xn,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=tn,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const s={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},a=new fr(5,5,5),h=new Di({name:"CubemapFromEquirect",uniforms:hs(s.uniforms),vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,side:ke,blending:ni});h.uniforms.tEquirect.value=e;const d=new rn(a,h),p=e.minFilter;return e.minFilter===vo&&(e.minFilter=xn),new $l(1,10,this).update(t,d),e.minFilter=p,d.geometry.dispose(),d.material.dispose(),this}clear(t,e,s,a){const h=t.getRenderTarget();for(let d=0;d<6;d++)t.setRenderTarget(this,d),t.clear(e,s,a);t.setRenderTarget(h)}}Id.prototype.isWebGLCubeRenderTarget=!0;const Zl=new N,sy=new N,ry=new Ge;class jn{constructor(t=new N(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,s,a){return this.normal.set(t,e,s),this.constant=a,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,s){const a=Zl.subVectors(s,e).cross(sy.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(a,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const s=t.delta(Zl),a=this.normal.dot(s);if(a===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const h=-(t.start.dot(this.normal)+this.constant)/a;return h<0||h>1?null:e.copy(s).multiplyScalar(h).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),s=this.distanceToPoint(t.end);return e<0&&s>0||s<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const s=e||ry.getNormalMatrix(t),a=this.coplanarPoint(Zl).applyMatrix4(t),h=this.normal.applyMatrix3(s).normalize();return this.constant=-a.dot(h),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}jn.prototype.isPlane=!0;const ps=new ns,Xo=new N;class jo{constructor(t=new jn,e=new jn,s=new jn,a=new jn,h=new jn,d=new jn){this.planes=[t,e,s,a,h,d]}set(t,e,s,a,h,d){const p=this.planes;return p[0].copy(t),p[1].copy(e),p[2].copy(s),p[3].copy(a),p[4].copy(h),p[5].copy(d),this}copy(t){const e=this.planes;for(let s=0;s<6;s++)e[s].copy(t.planes[s]);return this}setFromProjectionMatrix(t){const e=this.planes,s=t.elements,a=s[0],h=s[1],d=s[2],p=s[3],g=s[4],_=s[5],v=s[6],b=s[7],M=s[8],S=s[9],L=s[10],C=s[11],k=s[12],T=s[13],E=s[14],z=s[15];return e[0].setComponents(p-a,b-g,C-M,z-k).normalize(),e[1].setComponents(p+a,b+g,C+M,z+k).normalize(),e[2].setComponents(p+h,b+_,C+S,z+T).normalize(),e[3].setComponents(p-h,b-_,C-S,z-T).normalize(),e[4].setComponents(p-d,b-v,C-L,z-E).normalize(),e[5].setComponents(p+d,b+v,C+L,z+E).normalize(),this}intersectsObject(t){const e=t.geometry;return e.boundingSphere===null&&e.computeBoundingSphere(),ps.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(ps)}intersectsSprite(t){return ps.center.set(0,0,0),ps.radius=.7071067811865476,ps.applyMatrix4(t.matrixWorld),this.intersectsSphere(ps)}intersectsSphere(t){const e=this.planes,s=t.center,a=-t.radius;for(let h=0;h<6;h++)if(e[h].distanceToPoint(s)<a)return!1;return!0}intersectsBox(t){const e=this.planes;for(let s=0;s<6;s++){const a=e[s];if(Xo.x=a.normal.x>0?t.max.x:t.min.x,Xo.y=a.normal.y>0?t.max.y:t.min.y,Xo.z=a.normal.z>0?t.max.z:t.min.z,a.distanceToPoint(Xo)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let s=0;s<6;s++)if(e[s].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function Fd(){let c=null,t=!1,e=null,s=null;function a(h,d){e(h,d),s=c.requestAnimationFrame(a)}return{start:function(){t!==!0&&e!==null&&(s=c.requestAnimationFrame(a),t=!0)},stop:function(){c.cancelAnimationFrame(s),t=!1},setAnimationLoop:function(h){e=h},setContext:function(h){c=h}}}function oy(c,t){const e=t.isWebGL2,s=new WeakMap;function a(_,v){const b=_.array,M=_.usage,S=c.createBuffer();c.bindBuffer(v,S),c.bufferData(v,b,M),_.onUploadCallback();let L=5126;return b instanceof Float32Array?L=5126:b instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):b instanceof Uint16Array?_.isFloat16BufferAttribute?e?L=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):L=5123:b instanceof Int16Array?L=5122:b instanceof Uint32Array?L=5125:b instanceof Int32Array?L=5124:b instanceof Int8Array?L=5120:(b instanceof Uint8Array||b instanceof Uint8ClampedArray)&&(L=5121),{buffer:S,type:L,bytesPerElement:b.BYTES_PER_ELEMENT,version:_.version}}function h(_,v,b){const M=v.array,S=v.updateRange;c.bindBuffer(b,_),S.count===-1?c.bufferSubData(b,0,M):(e?c.bufferSubData(b,S.offset*M.BYTES_PER_ELEMENT,M,S.offset,S.count):c.bufferSubData(b,S.offset*M.BYTES_PER_ELEMENT,M.subarray(S.offset,S.offset+S.count)),S.count=-1)}function d(_){return _.isInterleavedBufferAttribute&&(_=_.data),s.get(_)}function p(_){_.isInterleavedBufferAttribute&&(_=_.data);const v=s.get(_);v&&(c.deleteBuffer(v.buffer),s.delete(_))}function g(_,v){if(_.isGLBufferAttribute){const M=s.get(_);(!M||M.version<_.version)&&s.set(_,{buffer:_.buffer,type:_.type,bytesPerElement:_.elementSize,version:_.version});return}_.isInterleavedBufferAttribute&&(_=_.data);const b=s.get(_);b===void 0?s.set(_,a(_,v)):b.version<_.version&&(h(b.buffer,_,v),b.version=_.version)}return{get:d,remove:p,update:g}}class Jl extends ve{constructor(t=1,e=1,s=1,a=1){super();this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:s,heightSegments:a};const h=t/2,d=e/2,p=Math.floor(s),g=Math.floor(a),_=p+1,v=g+1,b=t/p,M=e/g,S=[],L=[],C=[],k=[];for(let T=0;T<v;T++){const E=T*M-d;for(let z=0;z<_;z++){const I=z*b-h;L.push(I,-E,0),C.push(0,0,1),k.push(z/p),k.push(1-T/g)}}for(let T=0;T<g;T++)for(let E=0;E<p;E++){const z=E+_*T,I=E+_*(T+1),V=E+1+_*(T+1),G=E+1+_*T;S.push(z,I,G),S.push(I,V,G)}this.setIndex(S),this.setAttribute("position",new Ae(L,3)),this.setAttribute("normal",new Ae(C,3)),this.setAttribute("uv",new Ae(k,2))}static fromJSON(t){return new Jl(t.width,t.height,t.widthSegments,t.heightSegments)}}var ay=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,ly=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,cy=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,uy=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,hy=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,dy=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,fy="vec3 transformed = vec3( position );",py=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,my=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenTint, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenTint * ( D * V );
}
#endif`,gy=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,xy=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,_y=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,yy=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,vy=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,by=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,My=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,wy=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,Sy=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,Ty=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,Ey=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,Ay=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Ly=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Cy=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,Ry=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Py=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Dy="gl_FragColor = linearToOutputTexel( gl_FragColor );",Iy=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,Fy=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
		envColor = envMapTexelToLinear( envColor );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,ky=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Oy=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,By=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,zy=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,Ny=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,Vy=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,Uy=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,Hy=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,Wy=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,Gy=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,Xy=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,jy=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,qy=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,Yy=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,$y=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,Zy=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,Jy=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,Ky=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,Qy=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularTintFactor = specularTint;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARTINTMAP
			specularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularTintFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenTint = sheenTint;
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
#endif`,tv=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenTint;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenTint, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,ev=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,nv=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,iv=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,sv=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,rv=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,ov=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,av=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,lv=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,cv=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,uv=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,hv=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,dv=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,fv=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,pv=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,mv=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform vec2 morphTargetsTextureSize;
		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {
			float texelIndex = float( vertexIndex * stride + offset );
			float y = floor( texelIndex / morphTargetsTextureSize.x );
			float x = texelIndex - y * morphTargetsTextureSize.x;
			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );
			return texture( morphTargetsTexture, morphUV ).xyz;
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,gv=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			#ifndef USE_MORPHNORMALS
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];
			#else
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];
			#endif
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,xv=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,_v=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,yv=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,vv=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,bv=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,Mv=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,wv=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,Sv=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,Tv=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,Ev=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,Av=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,Lv=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Cv=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Rv=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,Pv=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Dv=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Iv=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,Fv=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,kv=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,Ov=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,Bv=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,zv=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,Nv=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,Vv=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,Uv=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Hv=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,Wv=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,Gv=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,Xv=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,jv=`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationTint, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,qv=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationTint;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( float roughness, float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef TEXTURE_LOD_EXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,Yv=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,$v=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,Zv=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,Jv=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,Kv=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,Qv=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,tb=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const eb=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,nb=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,ib=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,sb=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,rb=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,ob=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,ab=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,lb=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,cb=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,ub=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,hb=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,db=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,fb=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,pb=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,mb=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,gb=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,xb=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,_b=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,yb=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,vb=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,bb=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Mb=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,wb=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,Sb=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularTint;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARTINTMAP
		uniform sampler2D specularTintMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenTint;
	uniform float sheenRoughness;
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Tb=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Eb=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Ab=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,Lb=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Cb=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Rb=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Pb=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Db=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,se={alphamap_fragment:ay,alphamap_pars_fragment:ly,alphatest_fragment:cy,alphatest_pars_fragment:uy,aomap_fragment:hy,aomap_pars_fragment:dy,begin_vertex:fy,beginnormal_vertex:py,bsdfs:my,bumpmap_pars_fragment:gy,clipping_planes_fragment:xy,clipping_planes_pars_fragment:_y,clipping_planes_pars_vertex:yy,clipping_planes_vertex:vy,color_fragment:by,color_pars_fragment:My,color_pars_vertex:wy,color_vertex:Sy,common:Ty,cube_uv_reflection_fragment:Ey,defaultnormal_vertex:Ay,displacementmap_pars_vertex:Ly,displacementmap_vertex:Cy,emissivemap_fragment:Ry,emissivemap_pars_fragment:Py,encodings_fragment:Dy,encodings_pars_fragment:Iy,envmap_fragment:Fy,envmap_common_pars_fragment:ky,envmap_pars_fragment:Oy,envmap_pars_vertex:By,envmap_physical_pars_fragment:Yy,envmap_vertex:zy,fog_vertex:Ny,fog_pars_vertex:Vy,fog_fragment:Uy,fog_pars_fragment:Hy,gradientmap_pars_fragment:Wy,lightmap_fragment:Gy,lightmap_pars_fragment:Xy,lights_lambert_vertex:jy,lights_pars_begin:qy,lights_toon_fragment:$y,lights_toon_pars_fragment:Zy,lights_phong_fragment:Jy,lights_phong_pars_fragment:Ky,lights_physical_fragment:Qy,lights_physical_pars_fragment:tv,lights_fragment_begin:ev,lights_fragment_maps:nv,lights_fragment_end:iv,logdepthbuf_fragment:sv,logdepthbuf_pars_fragment:rv,logdepthbuf_pars_vertex:ov,logdepthbuf_vertex:av,map_fragment:lv,map_pars_fragment:cv,map_particle_fragment:uv,map_particle_pars_fragment:hv,metalnessmap_fragment:dv,metalnessmap_pars_fragment:fv,morphnormal_vertex:pv,morphtarget_pars_vertex:mv,morphtarget_vertex:gv,normal_fragment_begin:xv,normal_fragment_maps:_v,normal_pars_fragment:yv,normal_pars_vertex:vv,normal_vertex:bv,normalmap_pars_fragment:Mv,clearcoat_normal_fragment_begin:wv,clearcoat_normal_fragment_maps:Sv,clearcoat_pars_fragment:Tv,output_fragment:Ev,packing:Av,premultiplied_alpha_fragment:Lv,project_vertex:Cv,dithering_fragment:Rv,dithering_pars_fragment:Pv,roughnessmap_fragment:Dv,roughnessmap_pars_fragment:Iv,shadowmap_pars_fragment:Fv,shadowmap_pars_vertex:kv,shadowmap_vertex:Ov,shadowmask_pars_fragment:Bv,skinbase_vertex:zv,skinning_pars_vertex:Nv,skinning_vertex:Vv,skinnormal_vertex:Uv,specularmap_fragment:Hv,specularmap_pars_fragment:Wv,tonemapping_fragment:Gv,tonemapping_pars_fragment:Xv,transmission_fragment:jv,transmission_pars_fragment:qv,uv_pars_fragment:Yv,uv_pars_vertex:$v,uv_vertex:Zv,uv2_pars_fragment:Jv,uv2_pars_vertex:Kv,uv2_vertex:Qv,worldpos_vertex:tb,background_vert:eb,background_frag:nb,cube_vert:ib,cube_frag:sb,depth_vert:rb,depth_frag:ob,distanceRGBA_vert:ab,distanceRGBA_frag:lb,equirect_vert:cb,equirect_frag:ub,linedashed_vert:hb,linedashed_frag:db,meshbasic_vert:fb,meshbasic_frag:pb,meshlambert_vert:mb,meshlambert_frag:gb,meshmatcap_vert:xb,meshmatcap_frag:_b,meshnormal_vert:yb,meshnormal_frag:vb,meshphong_vert:bb,meshphong_frag:Mb,meshphysical_vert:wb,meshphysical_frag:Sb,meshtoon_vert:Tb,meshtoon_frag:Eb,points_vert:Ab,points_frag:Lb,shadow_vert:Cb,shadow_frag:Rb,sprite_vert:Pb,sprite_frag:Db},Ct={common:{diffuse:{value:new Ht(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Ge},uv2Transform:{value:new Ge},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Mt(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ht(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Ht(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Ge}},sprite:{diffuse:{value:new Ht(16777215)},opacity:{value:1},center:{value:new Mt(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Ge}}},kn={basic:{uniforms:$e([Ct.common,Ct.specularmap,Ct.envmap,Ct.aomap,Ct.lightmap,Ct.fog]),vertexShader:se.meshbasic_vert,fragmentShader:se.meshbasic_frag},lambert:{uniforms:$e([Ct.common,Ct.specularmap,Ct.envmap,Ct.aomap,Ct.lightmap,Ct.emissivemap,Ct.fog,Ct.lights,{emissive:{value:new Ht(0)}}]),vertexShader:se.meshlambert_vert,fragmentShader:se.meshlambert_frag},phong:{uniforms:$e([Ct.common,Ct.specularmap,Ct.envmap,Ct.aomap,Ct.lightmap,Ct.emissivemap,Ct.bumpmap,Ct.normalmap,Ct.displacementmap,Ct.fog,Ct.lights,{emissive:{value:new Ht(0)},specular:{value:new Ht(1118481)},shininess:{value:30}}]),vertexShader:se.meshphong_vert,fragmentShader:se.meshphong_frag},standard:{uniforms:$e([Ct.common,Ct.envmap,Ct.aomap,Ct.lightmap,Ct.emissivemap,Ct.bumpmap,Ct.normalmap,Ct.displacementmap,Ct.roughnessmap,Ct.metalnessmap,Ct.fog,Ct.lights,{emissive:{value:new Ht(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:se.meshphysical_vert,fragmentShader:se.meshphysical_frag},toon:{uniforms:$e([Ct.common,Ct.aomap,Ct.lightmap,Ct.emissivemap,Ct.bumpmap,Ct.normalmap,Ct.displacementmap,Ct.gradientmap,Ct.fog,Ct.lights,{emissive:{value:new Ht(0)}}]),vertexShader:se.meshtoon_vert,fragmentShader:se.meshtoon_frag},matcap:{uniforms:$e([Ct.common,Ct.bumpmap,Ct.normalmap,Ct.displacementmap,Ct.fog,{matcap:{value:null}}]),vertexShader:se.meshmatcap_vert,fragmentShader:se.meshmatcap_frag},points:{uniforms:$e([Ct.points,Ct.fog]),vertexShader:se.points_vert,fragmentShader:se.points_frag},dashed:{uniforms:$e([Ct.common,Ct.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:se.linedashed_vert,fragmentShader:se.linedashed_frag},depth:{uniforms:$e([Ct.common,Ct.displacementmap]),vertexShader:se.depth_vert,fragmentShader:se.depth_frag},normal:{uniforms:$e([Ct.common,Ct.bumpmap,Ct.normalmap,Ct.displacementmap,{opacity:{value:1}}]),vertexShader:se.meshnormal_vert,fragmentShader:se.meshnormal_frag},sprite:{uniforms:$e([Ct.sprite,Ct.fog]),vertexShader:se.sprite_vert,fragmentShader:se.sprite_frag},background:{uniforms:{uvTransform:{value:new Ge},t2D:{value:null}},vertexShader:se.background_vert,fragmentShader:se.background_frag},cube:{uniforms:$e([Ct.envmap,{opacity:{value:1}}]),vertexShader:se.cube_vert,fragmentShader:se.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:se.equirect_vert,fragmentShader:se.equirect_frag},distanceRGBA:{uniforms:$e([Ct.common,Ct.displacementmap,{referencePosition:{value:new N},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:se.distanceRGBA_vert,fragmentShader:se.distanceRGBA_frag},shadow:{uniforms:$e([Ct.lights,Ct.fog,{color:{value:new Ht(0)},opacity:{value:1}}]),vertexShader:se.shadow_vert,fragmentShader:se.shadow_frag}};kn.physical={uniforms:$e([kn.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Mt(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenTint:{value:new Ht(0)},sheenRoughness:{value:0},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Mt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationTint:{value:new Ht(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularTint:{value:new Ht(1,1,1)},specularTintMap:{value:null}}]),vertexShader:se.meshphysical_vert,fragmentShader:se.meshphysical_frag};function Ib(c,t,e,s,a){const h=new Ht(0);let d=0,p,g,_=null,v=0,b=null;function M(L,C){let k=!1,T=C.isScene===!0?C.background:null;T&&T.isTexture&&(T=t.get(T));const E=c.xr,z=E.getSession&&E.getSession();z&&z.environmentBlendMode==="additive"&&(T=null),T===null?S(h,d):T&&T.isColor&&(S(T,1),k=!0),(c.autoClear||k)&&c.clear(c.autoClearColor,c.autoClearDepth,c.autoClearStencil),T&&(T.isCubeTexture||T.mapping===yo)?(g===void 0&&(g=new rn(new fr(1,1,1),new Di({name:"BackgroundCubeMaterial",uniforms:hs(kn.cube.uniforms),vertexShader:kn.cube.vertexShader,fragmentShader:kn.cube.fragmentShader,side:ke,depthTest:!1,depthWrite:!1,fog:!1})),g.geometry.deleteAttribute("normal"),g.geometry.deleteAttribute("uv"),g.onBeforeRender=function(I,V,G){this.matrixWorld.copyPosition(G.matrixWorld)},Object.defineProperty(g.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),s.update(g)),g.material.uniforms.envMap.value=T,g.material.uniforms.flipEnvMap.value=T.isCubeTexture&&T.isRenderTargetTexture===!1?-1:1,(_!==T||v!==T.version||b!==c.toneMapping)&&(g.material.needsUpdate=!0,_=T,v=T.version,b=c.toneMapping),L.unshift(g,g.geometry,g.material,0,0,null)):T&&T.isTexture&&(p===void 0&&(p=new rn(new Jl(2,2),new Di({name:"BackgroundMaterial",uniforms:hs(kn.background.uniforms),vertexShader:kn.background.vertexShader,fragmentShader:kn.background.fragmentShader,side:sr,depthTest:!1,depthWrite:!1,fog:!1})),p.geometry.deleteAttribute("normal"),Object.defineProperty(p.material,"map",{get:function(){return this.uniforms.t2D.value}}),s.update(p)),p.material.uniforms.t2D.value=T,T.matrixAutoUpdate===!0&&T.updateMatrix(),p.material.uniforms.uvTransform.value.copy(T.matrix),(_!==T||v!==T.version||b!==c.toneMapping)&&(p.material.needsUpdate=!0,_=T,v=T.version,b=c.toneMapping),L.unshift(p,p.geometry,p.material,0,0,null))}function S(L,C){e.buffers.color.setClear(L.r,L.g,L.b,C,a)}return{getClearColor:function(){return h},setClearColor:function(L,C=1){h.set(L),d=C,S(h,d)},getClearAlpha:function(){return d},setClearAlpha:function(L){d=L,S(h,d)},render:M}}function Fb(c,t,e,s){const a=c.getParameter(34921),h=s.isWebGL2?null:t.get("OES_vertex_array_object"),d=s.isWebGL2||h!==null,p={},g=C(null);let _=g;function v(it,Q,rt,tt,st){let St=!1;if(d){const Bt=L(tt,rt,Q);_!==Bt&&(_=Bt,M(_.object)),St=k(tt,st),St&&T(tt,st)}else{const Bt=Q.wireframe===!0;(_.geometry!==tt.id||_.program!==rt.id||_.wireframe!==Bt)&&(_.geometry=tt.id,_.program=rt.id,_.wireframe=Bt,St=!0)}it.isInstancedMesh===!0&&(St=!0),st!==null&&e.update(st,34963),St&&(F(it,Q,rt,tt),st!==null&&c.bindBuffer(34963,e.get(st).buffer))}function b(){return s.isWebGL2?c.createVertexArray():h.createVertexArrayOES()}function M(it){return s.isWebGL2?c.bindVertexArray(it):h.bindVertexArrayOES(it)}function S(it){return s.isWebGL2?c.deleteVertexArray(it):h.deleteVertexArrayOES(it)}function L(it,Q,rt){const tt=rt.wireframe===!0;let st=p[it.id];st===void 0&&(st={},p[it.id]=st);let St=st[Q.id];St===void 0&&(St={},st[Q.id]=St);let Bt=St[tt];return Bt===void 0&&(Bt=C(b()),St[tt]=Bt),Bt}function C(it){const Q=[],rt=[],tt=[];for(let st=0;st<a;st++)Q[st]=0,rt[st]=0,tt[st]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:Q,enabledAttributes:rt,attributeDivisors:tt,object:it,attributes:{},index:null}}function k(it,Q){const rt=_.attributes,tt=it.attributes;let st=0;for(const St in tt){const Bt=rt[St],Wt=tt[St];if(Bt===void 0||Bt.attribute!==Wt||Bt.data!==Wt.data)return!0;st++}return _.attributesNum!==st||_.index!==Q}function T(it,Q){const rt={},tt=it.attributes;let st=0;for(const St in tt){const Bt=tt[St],Wt={};Wt.attribute=Bt,Bt.data&&(Wt.data=Bt.data),rt[St]=Wt,st++}_.attributes=rt,_.attributesNum=st,_.index=Q}function E(){const it=_.newAttributes;for(let Q=0,rt=it.length;Q<rt;Q++)it[Q]=0}function z(it){I(it,0)}function I(it,Q){const rt=_.newAttributes,tt=_.enabledAttributes,st=_.attributeDivisors;rt[it]=1,tt[it]===0&&(c.enableVertexAttribArray(it),tt[it]=1),st[it]!==Q&&((s.isWebGL2?c:t.get("ANGLE_instanced_arrays"))[s.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](it,Q),st[it]=Q)}function V(){const it=_.newAttributes,Q=_.enabledAttributes;for(let rt=0,tt=Q.length;rt<tt;rt++)Q[rt]!==it[rt]&&(c.disableVertexAttribArray(rt),Q[rt]=0)}function G(it,Q,rt,tt,st,St){s.isWebGL2===!0&&(rt===5124||rt===5125)?c.vertexAttribIPointer(it,Q,rt,st,St):c.vertexAttribPointer(it,Q,rt,tt,st,St)}function F(it,Q,rt,tt){if(s.isWebGL2===!1&&(it.isInstancedMesh||tt.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;E();const st=tt.attributes,St=rt.getAttributes(),Bt=Q.defaultAttributeValues;for(const Wt in St){const Pt=St[Wt];if(Pt.location>=0){let Zt=st[Wt];if(Zt===void 0&&(Wt==="instanceMatrix"&&it.instanceMatrix&&(Zt=it.instanceMatrix),Wt==="instanceColor"&&it.instanceColor&&(Zt=it.instanceColor)),Zt!==void 0){const ee=Zt.normalized,re=Zt.itemSize,xt=e.get(Zt);if(xt===void 0)continue;const Y=xt.buffer,Xt=xt.type,It=xt.bytesPerElement;if(Zt.isInterleavedBufferAttribute){const vt=Zt.data,Ft=vt.stride,Jt=Zt.offset;if(vt&&vt.isInstancedInterleavedBuffer){for(let ot=0;ot<Pt.locationSize;ot++)I(Pt.location+ot,vt.meshPerAttribute);it.isInstancedMesh!==!0&&tt._maxInstanceCount===void 0&&(tt._maxInstanceCount=vt.meshPerAttribute*vt.count)}else for(let ot=0;ot<Pt.locationSize;ot++)z(Pt.location+ot);c.bindBuffer(34962,Y);for(let ot=0;ot<Pt.locationSize;ot++)G(Pt.location+ot,re/Pt.locationSize,Xt,ee,Ft*It,(Jt+re/Pt.locationSize*ot)*It)}else{if(Zt.isInstancedBufferAttribute){for(let vt=0;vt<Pt.locationSize;vt++)I(Pt.location+vt,Zt.meshPerAttribute);it.isInstancedMesh!==!0&&tt._maxInstanceCount===void 0&&(tt._maxInstanceCount=Zt.meshPerAttribute*Zt.count)}else for(let vt=0;vt<Pt.locationSize;vt++)z(Pt.location+vt);c.bindBuffer(34962,Y);for(let vt=0;vt<Pt.locationSize;vt++)G(Pt.location+vt,re/Pt.locationSize,Xt,ee,re*It,re/Pt.locationSize*vt*It)}}else if(Bt!==void 0){const ee=Bt[Wt];if(ee!==void 0)switch(ee.length){case 2:c.vertexAttrib2fv(Pt.location,ee);break;case 3:c.vertexAttrib3fv(Pt.location,ee);break;case 4:c.vertexAttrib4fv(Pt.location,ee);break;default:c.vertexAttrib1fv(Pt.location,ee)}}}}V()}function K(){X();for(const it in p){const Q=p[it];for(const rt in Q){const tt=Q[rt];for(const st in tt)S(tt[st].object),delete tt[st];delete Q[rt]}delete p[it]}}function pt(it){if(p[it.id]===void 0)return;const Q=p[it.id];for(const rt in Q){const tt=Q[rt];for(const st in tt)S(tt[st].object),delete tt[st];delete Q[rt]}delete p[it.id]}function ut(it){for(const Q in p){const rt=p[Q];if(rt[it.id]===void 0)continue;const tt=rt[it.id];for(const st in tt)S(tt[st].object),delete tt[st];delete rt[it.id]}}function X(){ht(),_!==g&&(_=g,M(_.object))}function ht(){g.geometry=null,g.program=null,g.wireframe=!1}return{setup:v,reset:X,resetDefaultState:ht,dispose:K,releaseStatesOfGeometry:pt,releaseStatesOfProgram:ut,initAttributes:E,enableAttribute:z,disableUnusedAttributes:V}}function kb(c,t,e,s){const a=s.isWebGL2;let h;function d(_){h=_}function p(_,v){c.drawArrays(h,_,v),e.update(v,h,1)}function g(_,v,b){if(b===0)return;let M,S;if(a)M=c,S="drawArraysInstanced";else if(M=t.get("ANGLE_instanced_arrays"),S="drawArraysInstancedANGLE",M===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}M[S](h,_,v,b),e.update(v,h,b)}this.setMode=d,this.render=p,this.renderInstances=g}function Ob(c,t,e){let s;function a(){if(s!==void 0)return s;if(t.has("EXT_texture_filter_anisotropic")===!0){const F=t.get("EXT_texture_filter_anisotropic");s=c.getParameter(F.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else s=0;return s}function h(F){if(F==="highp"){if(c.getShaderPrecisionFormat(35633,36338).precision>0&&c.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";F="mediump"}return F==="mediump"&&c.getShaderPrecisionFormat(35633,36337).precision>0&&c.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const d=typeof WebGL2RenderingContext!="undefined"&&c instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&c instanceof WebGL2ComputeRenderingContext;let p=e.precision!==void 0?e.precision:"highp";const g=h(p);g!==p&&(console.warn("THREE.WebGLRenderer:",p,"not supported, using",g,"instead."),p=g);const _=d||t.has("WEBGL_draw_buffers"),v=e.logarithmicDepthBuffer===!0,b=c.getParameter(34930),M=c.getParameter(35660),S=c.getParameter(3379),L=c.getParameter(34076),C=c.getParameter(34921),k=c.getParameter(36347),T=c.getParameter(36348),E=c.getParameter(36349),z=M>0,I=d||t.has("OES_texture_float"),V=z&&I,G=d?c.getParameter(36183):0;return{isWebGL2:d,drawBuffers:_,getMaxAnisotropy:a,getMaxPrecision:h,precision:p,logarithmicDepthBuffer:v,maxTextures:b,maxVertexTextures:M,maxTextureSize:S,maxCubemapSize:L,maxAttributes:C,maxVertexUniforms:k,maxVaryings:T,maxFragmentUniforms:E,vertexTextures:z,floatFragmentTextures:I,floatVertexTextures:V,maxSamples:G}}function Bb(c){const t=this;let e=null,s=0,a=!1,h=!1;const d=new jn,p=new Ge,g={value:null,needsUpdate:!1};this.uniform=g,this.numPlanes=0,this.numIntersection=0,this.init=function(b,M,S){const L=b.length!==0||M||s!==0||a;return a=M,e=v(b,S,0),s=b.length,L},this.beginShadows=function(){h=!0,v(null)},this.endShadows=function(){h=!1,_()},this.setState=function(b,M,S){const L=b.clippingPlanes,C=b.clipIntersection,k=b.clipShadows,T=c.get(b);if(!a||L===null||L.length===0||h&&!k)h?v(null):_();else{const E=h?0:s,z=E*4;let I=T.clippingState||null;g.value=I,I=v(L,M,z,S);for(let V=0;V!==z;++V)I[V]=e[V];T.clippingState=I,this.numIntersection=C?this.numPlanes:0,this.numPlanes+=E}};function _(){g.value!==e&&(g.value=e,g.needsUpdate=s>0),t.numPlanes=s,t.numIntersection=0}function v(b,M,S,L){const C=b!==null?b.length:0;let k=null;if(C!==0){if(k=g.value,L!==!0||k===null){const T=S+C*4,E=M.matrixWorldInverse;p.getNormalMatrix(E),(k===null||k.length<T)&&(k=new Float32Array(T));for(let z=0,I=S;z!==C;++z,I+=4)d.copy(b[z]).applyMatrix4(E,p),d.normal.toArray(k,I),k[I+3]=d.constant}g.value=k,g.needsUpdate=!0}return t.numPlanes=C,t.numIntersection=0,k}}function zb(c){let t=new WeakMap;function e(d,p){return p===dl?d.mapping=xo:p===fl&&(d.mapping=_o),d}function s(d){if(d&&d.isTexture&&d.isRenderTargetTexture===!1){const p=d.mapping;if(p===dl||p===fl)if(t.has(d)){const g=t.get(d).texture;return e(g,d.mapping)}else{const g=d.image;if(g&&g.height>0){const _=c.getRenderTarget(),v=new Id(g.height/2);return v.fromEquirectangularTexture(c,d),t.set(d,v),c.setRenderTarget(_),d.addEventListener("dispose",a),e(v.texture,d.mapping)}else return null}}return d}function a(d){const p=d.target;p.removeEventListener("dispose",a);const g=t.get(p);g!==void 0&&(t.delete(p),g.dispose())}function h(){t=new WeakMap}return{get:s,dispose:h}}class Kl extends Yl{constructor(t=-1,e=1,s=1,a=-1,h=.1,d=2e3){super();this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=s,this.bottom=a,this.near=h,this.far=d,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,s,a,h,d){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=s,this.view.offsetY=a,this.view.width=h,this.view.height=d,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),s=(this.right+this.left)/2,a=(this.top+this.bottom)/2;let h=s-t,d=s+t,p=a+e,g=a-e;if(this.view!==null&&this.view.enabled){const _=(this.right-this.left)/this.view.fullWidth/this.zoom,v=(this.top-this.bottom)/this.view.fullHeight/this.zoom;h+=_*this.view.offsetX,d=h+_*this.view.width,p-=v*this.view.offsetY,g=p-v*this.view.height}this.projectionMatrix.makeOrthographic(h,d,p,g,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}Kl.prototype.isOrthographicCamera=!0;class qo extends Di{constructor(t){super(t);this.type="RawShaderMaterial"}}qo.prototype.isRawShaderMaterial=!0;const ms=4,di=8,On=Math.pow(2,di),kd=[.125,.215,.35,.446,.526,.582],Od=di-ms+1+kd.length,gs=20,fi={[qe]:0,[Li]:1,[vl]:2,[dd]:3,[fd]:4,[pd]:5,[yl]:6},Ql=new Kl,{_lodPlanes:pr,_sizeLods:Bd,_sigmas:Yo}=Ub(),zd=new Ht;let tc=null;const Ii=(1+Math.sqrt(5))/2,xs=1/Ii,Nd=[new N(1,1,1),new N(-1,1,1),new N(1,1,-1),new N(-1,1,-1),new N(0,Ii,xs),new N(0,Ii,-xs),new N(xs,0,Ii),new N(-xs,0,Ii),new N(Ii,xs,0),new N(-Ii,xs,0)];class Nb{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._blurMaterial=Hb(gs),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,s=.1,a=100){tc=this._renderer.getRenderTarget();const h=this._allocateTargets();return this._sceneToCubeUV(t,s,a,h),e>0&&this._blur(h,0,0,e),this._applyPMREM(h),this._cleanup(h),h}fromEquirectangular(t){return this._fromTexture(t)}fromCubemap(t){return this._fromTexture(t)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=Hd(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=Ud(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let t=0;t<pr.length;t++)pr[t].dispose()}_cleanup(t){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(tc),t.scissorTest=!1,$o(t,0,0,t.width,t.height)}_fromTexture(t){tc=this._renderer.getRenderTarget();const e=this._allocateTargets(t);return this._textureToCubeUV(t,e),this._applyPMREM(e),this._cleanup(e),e}_allocateTargets(t){const e={magFilter:Ne,minFilter:Ne,generateMipmaps:!1,type:ii,format:j_,encoding:Vb(t)?t.encoding:vl,depthBuffer:!1},s=Vd(e);return s.depthBuffer=!t,this._pingPongRenderTarget=Vd(e),s}_compileMaterial(t){const e=new rn(pr[0],t);this._renderer.compile(e,Ql)}_sceneToCubeUV(t,e,s,a){const h=90,d=1,p=new on(h,d,e,s),g=[1,-1,1,1,1,1],_=[1,1,1,-1,-1,-1],v=this._renderer,b=v.autoClear,M=v.outputEncoding,S=v.toneMapping;v.getClearColor(zd),v.toneMapping=Ai,v.outputEncoding=qe,v.autoClear=!1;const L=new Ul({name:"PMREM.Background",side:ke,depthWrite:!1,depthTest:!1}),C=new rn(new fr,L);let k=!1;const T=t.background;T?T.isColor&&(L.color.copy(T),t.background=null,k=!0):(L.color.copy(zd),k=!0);for(let E=0;E<6;E++){const z=E%3;z==0?(p.up.set(0,g[E],0),p.lookAt(_[E],0,0)):z==1?(p.up.set(0,0,g[E]),p.lookAt(0,_[E],0)):(p.up.set(0,g[E],0),p.lookAt(0,0,_[E])),$o(a,z*On,E>2?On:0,On,On),v.setRenderTarget(a),k&&v.render(C,p),v.render(t,p)}C.geometry.dispose(),C.material.dispose(),v.toneMapping=S,v.outputEncoding=M,v.autoClear=b,t.background=T}_setEncoding(t,e){this._renderer.capabilities.isWebGL2===!0&&e.format===tn&&e.type===ii&&e.encoding===Li?t.value=fi[qe]:t.value=fi[e.encoding]}_textureToCubeUV(t,e){const s=this._renderer;t.isCubeTexture?this._cubemapShader==null&&(this._cubemapShader=Hd()):this._equirectShader==null&&(this._equirectShader=Ud());const a=t.isCubeTexture?this._cubemapShader:this._equirectShader,h=new rn(pr[0],a),d=a.uniforms;d.envMap.value=t,t.isCubeTexture||d.texelSize.value.set(1/t.image.width,1/t.image.height),this._setEncoding(d.inputEncoding,t),this._setEncoding(d.outputEncoding,e.texture),$o(e,0,0,3*On,2*On),s.setRenderTarget(e),s.render(h,Ql)}_applyPMREM(t){const e=this._renderer,s=e.autoClear;e.autoClear=!1;for(let a=1;a<Od;a++){const h=Math.sqrt(Yo[a]*Yo[a]-Yo[a-1]*Yo[a-1]),d=Nd[(a-1)%Nd.length];this._blur(t,a-1,a,h,d)}e.autoClear=s}_blur(t,e,s,a,h){const d=this._pingPongRenderTarget;this._halfBlur(t,d,e,s,a,"latitudinal",h),this._halfBlur(d,t,s,s,a,"longitudinal",h)}_halfBlur(t,e,s,a,h,d,p){const g=this._renderer,_=this._blurMaterial;d!=="latitudinal"&&d!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const v=3,b=new rn(pr[a],_),M=_.uniforms,S=Bd[s]-1,L=isFinite(h)?Math.PI/(2*S):2*Math.PI/(2*gs-1),C=h/L,k=isFinite(h)?1+Math.floor(v*C):gs;k>gs&&console.warn(`sigmaRadians, ${h}, is too large and will clip, as it requested ${k} samples when the maximum is set to ${gs}`);const T=[];let E=0;for(let G=0;G<gs;++G){const F=G/C,K=Math.exp(-F*F/2);T.push(K),G==0?E+=K:G<k&&(E+=2*K)}for(let G=0;G<T.length;G++)T[G]=T[G]/E;M.envMap.value=t.texture,M.samples.value=k,M.weights.value=T,M.latitudinal.value=d==="latitudinal",p&&(M.poleAxis.value=p),M.dTheta.value=L,M.mipInt.value=di-s,this._setEncoding(M.inputEncoding,t.texture),this._setEncoding(M.outputEncoding,t.texture);const z=Bd[a],I=3*Math.max(0,On-2*z),V=(a===0?0:2*On)+2*z*(a>di-ms?a-di+ms:0);$o(e,I,V,3*z,2*z),g.setRenderTarget(e),g.render(b,Ql)}}function Vb(c){return c===void 0||c.type!==ii?!1:c.encoding===qe||c.encoding===Li||c.encoding===yl}function Ub(){const c=[],t=[],e=[];let s=di;for(let a=0;a<Od;a++){const h=Math.pow(2,s);t.push(h);let d=1/h;a>di-ms?d=kd[a-di+ms-1]:a==0&&(d=0),e.push(d);const p=1/(h-1),g=-p/2,_=1+p/2,v=[g,g,_,g,_,_,g,g,_,_,g,_],b=6,M=6,S=3,L=2,C=1,k=new Float32Array(S*M*b),T=new Float32Array(L*M*b),E=new Float32Array(C*M*b);for(let I=0;I<b;I++){const V=I%3*2/3-1,G=I>2?0:-1,F=[V,G,0,V+2/3,G,0,V+2/3,G+1,0,V,G,0,V+2/3,G+1,0,V,G+1,0];k.set(F,S*M*I),T.set(v,L*M*I);const K=[I,I,I,I,I,I];E.set(K,C*M*I)}const z=new ve;z.setAttribute("position",new Oe(k,S)),z.setAttribute("uv",new Oe(T,L)),z.setAttribute("faceIndex",new Oe(E,C)),c.push(z),s>ms&&s--}return{_lodPlanes:c,_sizeLods:t,_sigmas:e}}function Vd(c){const t=new Fn(3*On,3*On,c);return t.texture.mapping=yo,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function $o(c,t,e,s,a){c.viewport.set(t,e,s,a),c.scissor.set(t,e,s,a)}function Hb(c){const t=new Float32Array(c),e=new N(0,1,0);return new qo({name:"SphericalGaussianBlur",defines:{n:c},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:t},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:e},inputEncoding:{value:fi[qe]},outputEncoding:{value:fi[qe]}},vertexShader:ec(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${nc()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:ni,depthTest:!1,depthWrite:!1})}function Ud(){const c=new Mt(1,1);return new qo({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:c},inputEncoding:{value:fi[qe]},outputEncoding:{value:fi[qe]}},vertexShader:ec(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${nc()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:ni,depthTest:!1,depthWrite:!1})}function Hd(){return new qo({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:fi[qe]},outputEncoding:{value:fi[qe]}},vertexShader:ec(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${nc()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:ni,depthTest:!1,depthWrite:!1})}function ec(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function nc(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function Wb(c){let t=new WeakMap,e=null;function s(p){if(p&&p.isTexture&&p.isRenderTargetTexture===!1){const g=p.mapping,_=g===dl||g===fl,v=g===xo||g===_o;if(_||v){if(t.has(p))return t.get(p).texture;{const b=p.image;if(_&&b&&b.height>0||v&&b&&a(b)){const M=c.getRenderTarget();e===null&&(e=new Nb(c));const S=_?e.fromEquirectangular(p):e.fromCubemap(p);return t.set(p,S),c.setRenderTarget(M),p.addEventListener("dispose",h),S.texture}else return null}}}return p}function a(p){let g=0;const _=6;for(let v=0;v<_;v++)p[v]!==void 0&&g++;return g===_}function h(p){const g=p.target;g.removeEventListener("dispose",h);const _=t.get(g);_!==void 0&&(t.delete(g),_.dispose())}function d(){t=new WeakMap,e!==null&&(e.dispose(),e=null)}return{get:s,dispose:d}}function Gb(c){const t={};function e(s){if(t[s]!==void 0)return t[s];let a;switch(s){case"WEBGL_depth_texture":a=c.getExtension("WEBGL_depth_texture")||c.getExtension("MOZ_WEBGL_depth_texture")||c.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":a=c.getExtension("EXT_texture_filter_anisotropic")||c.getExtension("MOZ_EXT_texture_filter_anisotropic")||c.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":a=c.getExtension("WEBGL_compressed_texture_s3tc")||c.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||c.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":a=c.getExtension("WEBGL_compressed_texture_pvrtc")||c.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:a=c.getExtension(s)}return t[s]=a,a}return{has:function(s){return e(s)!==null},init:function(s){s.isWebGL2?e("EXT_color_buffer_float"):(e("WEBGL_depth_texture"),e("OES_texture_float"),e("OES_texture_half_float"),e("OES_texture_half_float_linear"),e("OES_standard_derivatives"),e("OES_element_index_uint"),e("OES_vertex_array_object"),e("ANGLE_instanced_arrays")),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float"),e("EXT_multisampled_render_to_texture")},get:function(s){const a=e(s);return a===null&&console.warn("THREE.WebGLRenderer: "+s+" extension not supported."),a}}}function Xb(c,t,e,s){const a={},h=new WeakMap;function d(b){const M=b.target;M.index!==null&&t.remove(M.index);for(const L in M.attributes)t.remove(M.attributes[L]);M.removeEventListener("dispose",d),delete a[M.id];const S=h.get(M);S&&(t.remove(S),h.delete(M)),s.releaseStatesOfGeometry(M),M.isInstancedBufferGeometry===!0&&delete M._maxInstanceCount,e.memory.geometries--}function p(b,M){return a[M.id]===!0||(M.addEventListener("dispose",d),a[M.id]=!0,e.memory.geometries++),M}function g(b){const M=b.attributes;for(const L in M)t.update(M[L],34962);const S=b.morphAttributes;for(const L in S){const C=S[L];for(let k=0,T=C.length;k<T;k++)t.update(C[k],34962)}}function _(b){const M=[],S=b.index,L=b.attributes.position;let C=0;if(S!==null){const E=S.array;C=S.version;for(let z=0,I=E.length;z<I;z+=3){const V=E[z+0],G=E[z+1],F=E[z+2];M.push(V,G,G,F,F,V)}}else{const E=L.array;C=L.version;for(let z=0,I=E.length/3-1;z<I;z+=3){const V=z+0,G=z+1,F=z+2;M.push(V,G,G,F,F,V)}}const k=new(xd(M)>65535?Pd:Rd)(M,1);k.version=C;const T=h.get(b);T&&t.remove(T),h.set(b,k)}function v(b){const M=h.get(b);if(M){const S=b.index;S!==null&&M.version<S.version&&_(b)}else _(b);return h.get(b)}return{get:p,update:g,getWireframeAttribute:v}}function jb(c,t,e,s){const a=s.isWebGL2;let h;function d(M){h=M}let p,g;function _(M){p=M.type,g=M.bytesPerElement}function v(M,S){c.drawElements(h,S,p,M*g),e.update(S,h,1)}function b(M,S,L){if(L===0)return;let C,k;if(a)C=c,k="drawElementsInstanced";else if(C=t.get("ANGLE_instanced_arrays"),k="drawElementsInstancedANGLE",C===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}C[k](h,S,p,M*g,L),e.update(S,h,L)}this.setMode=d,this.setIndex=_,this.render=v,this.renderInstances=b}function qb(c){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function s(h,d,p){switch(e.calls++,d){case 4:e.triangles+=p*(h/3);break;case 1:e.lines+=p*(h/2);break;case 3:e.lines+=p*(h-1);break;case 2:e.lines+=p*h;break;case 0:e.points+=p*h;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",d);break}}function a(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:a,update:s}}class ic extends Xe{constructor(t=null,e=1,s=1,a=1){super(null);this.image={data:t,width:e,height:s,depth:a},this.magFilter=Ne,this.minFilter=Ne,this.wrapR=ln,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}ic.prototype.isDataTexture2DArray=!0;function Yb(c,t){return c[0]-t[0]}function $b(c,t){return Math.abs(t[1])-Math.abs(c[1])}function Wd(c,t){let e=1;const s=t.isInterleavedBufferAttribute?t.data.array:t.array;s instanceof Int8Array?e=127:s instanceof Int16Array?e=32767:s instanceof Int32Array?e=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",s),c.divideScalar(e)}function Zb(c,t,e){const s={},a=new Float32Array(8),h=new WeakMap,d=new N,p=[];for(let _=0;_<8;_++)p[_]=[_,0];function g(_,v,b,M){const S=_.morphTargetInfluences;if(t.isWebGL2===!0){const L=v.morphAttributes.position.length;let C=h.get(v);if(C===void 0||C.count!==L){C!==void 0&&C.texture.dispose();const E=v.morphAttributes.normal!==void 0,z=v.morphAttributes.position,I=v.morphAttributes.normal||[],V=v.attributes.position.count,G=E===!0?2:1;let F=V*G,K=1;F>t.maxTextureSize&&(K=Math.ceil(F/t.maxTextureSize),F=t.maxTextureSize);const pt=new Float32Array(F*K*4*L),ut=new ic(pt,F,K,L);ut.format=tn,ut.type=si;const X=G*4;for(let ht=0;ht<L;ht++){const it=z[ht],Q=I[ht],rt=F*K*4*ht;for(let tt=0;tt<it.count;tt++){d.fromBufferAttribute(it,tt),it.normalized===!0&&Wd(d,it);const st=tt*X;pt[rt+st+0]=d.x,pt[rt+st+1]=d.y,pt[rt+st+2]=d.z,pt[rt+st+3]=0,E===!0&&(d.fromBufferAttribute(Q,tt),Q.normalized===!0&&Wd(d,Q),pt[rt+st+4]=d.x,pt[rt+st+5]=d.y,pt[rt+st+6]=d.z,pt[rt+st+7]=0)}}C={count:L,texture:ut,size:new Mt(F,K)},h.set(v,C)}let k=0;for(let E=0;E<S.length;E++)k+=S[E];const T=v.morphTargetsRelative?1:1-k;M.getUniforms().setValue(c,"morphTargetBaseInfluence",T),M.getUniforms().setValue(c,"morphTargetInfluences",S),M.getUniforms().setValue(c,"morphTargetsTexture",C.texture,e),M.getUniforms().setValue(c,"morphTargetsTextureSize",C.size)}else{const L=S===void 0?0:S.length;let C=s[v.id];if(C===void 0||C.length!==L){C=[];for(let I=0;I<L;I++)C[I]=[I,0];s[v.id]=C}for(let I=0;I<L;I++){const V=C[I];V[0]=I,V[1]=S[I]}C.sort($b);for(let I=0;I<8;I++)I<L&&C[I][1]?(p[I][0]=C[I][0],p[I][1]=C[I][1]):(p[I][0]=Number.MAX_SAFE_INTEGER,p[I][1]=0);p.sort(Yb);const k=v.morphAttributes.position,T=v.morphAttributes.normal;let E=0;for(let I=0;I<8;I++){const V=p[I],G=V[0],F=V[1];G!==Number.MAX_SAFE_INTEGER&&F?(k&&v.getAttribute("morphTarget"+I)!==k[G]&&v.setAttribute("morphTarget"+I,k[G]),T&&v.getAttribute("morphNormal"+I)!==T[G]&&v.setAttribute("morphNormal"+I,T[G]),a[I]=F,E+=F):(k&&v.hasAttribute("morphTarget"+I)===!0&&v.deleteAttribute("morphTarget"+I),T&&v.hasAttribute("morphNormal"+I)===!0&&v.deleteAttribute("morphNormal"+I),a[I]=0)}const z=v.morphTargetsRelative?1:1-E;M.getUniforms().setValue(c,"morphTargetBaseInfluence",z),M.getUniforms().setValue(c,"morphTargetInfluences",a)}}return{update:g}}function Jb(c,t,e,s){let a=new WeakMap;function h(g){const _=s.render.frame,v=g.geometry,b=t.get(g,v);return a.get(b)!==_&&(t.update(b),a.set(b,_)),g.isInstancedMesh&&(g.hasEventListener("dispose",p)===!1&&g.addEventListener("dispose",p),e.update(g.instanceMatrix,34962),g.instanceColor!==null&&e.update(g.instanceColor,34962)),b}function d(){a=new WeakMap}function p(g){const _=g.target;_.removeEventListener("dispose",p),e.remove(_.instanceMatrix),_.instanceColor!==null&&e.remove(_.instanceColor)}return{update:h,dispose:d}}class Gd extends Xe{constructor(t=null,e=1,s=1,a=1){super(null);this.image={data:t,width:e,height:s,depth:a},this.magFilter=Ne,this.minFilter=Ne,this.wrapR=ln,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Gd.prototype.isDataTexture3D=!0;const Xd=new Xe,Kb=new ic,Qb=new Gd,jd=new Go,qd=[],Yd=[],$d=new Float32Array(16),Zd=new Float32Array(9),Jd=new Float32Array(4);function _s(c,t,e){const s=c[0];if(s<=0||s>0)return c;const a=t*e;let h=qd[a];if(h===void 0&&(h=new Float32Array(a),qd[a]=h),t!==0){s.toArray(h,0);for(let d=1,p=0;d!==t;++d)p+=e,c[d].toArray(h,p)}return h}function en(c,t){if(c.length!==t.length)return!1;for(let e=0,s=c.length;e<s;e++)if(c[e]!==t[e])return!1;return!0}function Ze(c,t){for(let e=0,s=t.length;e<s;e++)c[e]=t[e]}function Kd(c,t){let e=Yd[t];e===void 0&&(e=new Int32Array(t),Yd[t]=e);for(let s=0;s!==t;++s)e[s]=c.allocateTextureUnit();return e}function tM(c,t){const e=this.cache;e[0]!==t&&(c.uniform1f(this.addr,t),e[0]=t)}function eM(c,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(c.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(en(e,t))return;c.uniform2fv(this.addr,t),Ze(e,t)}}function nM(c,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(c.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(c.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(en(e,t))return;c.uniform3fv(this.addr,t),Ze(e,t)}}function iM(c,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(c.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(en(e,t))return;c.uniform4fv(this.addr,t),Ze(e,t)}}function sM(c,t){const e=this.cache,s=t.elements;if(s===void 0){if(en(e,t))return;c.uniformMatrix2fv(this.addr,!1,t),Ze(e,t)}else{if(en(e,s))return;Jd.set(s),c.uniformMatrix2fv(this.addr,!1,Jd),Ze(e,s)}}function rM(c,t){const e=this.cache,s=t.elements;if(s===void 0){if(en(e,t))return;c.uniformMatrix3fv(this.addr,!1,t),Ze(e,t)}else{if(en(e,s))return;Zd.set(s),c.uniformMatrix3fv(this.addr,!1,Zd),Ze(e,s)}}function oM(c,t){const e=this.cache,s=t.elements;if(s===void 0){if(en(e,t))return;c.uniformMatrix4fv(this.addr,!1,t),Ze(e,t)}else{if(en(e,s))return;$d.set(s),c.uniformMatrix4fv(this.addr,!1,$d),Ze(e,s)}}function aM(c,t){const e=this.cache;e[0]!==t&&(c.uniform1i(this.addr,t),e[0]=t)}function lM(c,t){const e=this.cache;en(e,t)||(c.uniform2iv(this.addr,t),Ze(e,t))}function cM(c,t){const e=this.cache;en(e,t)||(c.uniform3iv(this.addr,t),Ze(e,t))}function uM(c,t){const e=this.cache;en(e,t)||(c.uniform4iv(this.addr,t),Ze(e,t))}function hM(c,t){const e=this.cache;e[0]!==t&&(c.uniform1ui(this.addr,t),e[0]=t)}function dM(c,t){const e=this.cache;en(e,t)||(c.uniform2uiv(this.addr,t),Ze(e,t))}function fM(c,t){const e=this.cache;en(e,t)||(c.uniform3uiv(this.addr,t),Ze(e,t))}function pM(c,t){const e=this.cache;en(e,t)||(c.uniform4uiv(this.addr,t),Ze(e,t))}function mM(c,t,e){const s=this.cache,a=e.allocateTextureUnit();s[0]!==a&&(c.uniform1i(this.addr,a),s[0]=a),e.safeSetTexture2D(t||Xd,a)}function gM(c,t,e){const s=this.cache,a=e.allocateTextureUnit();s[0]!==a&&(c.uniform1i(this.addr,a),s[0]=a),e.setTexture3D(t||Qb,a)}function xM(c,t,e){const s=this.cache,a=e.allocateTextureUnit();s[0]!==a&&(c.uniform1i(this.addr,a),s[0]=a),e.safeSetTextureCube(t||jd,a)}function _M(c,t,e){const s=this.cache,a=e.allocateTextureUnit();s[0]!==a&&(c.uniform1i(this.addr,a),s[0]=a),e.setTexture2DArray(t||Kb,a)}function yM(c){switch(c){case 5126:return tM;case 35664:return eM;case 35665:return nM;case 35666:return iM;case 35674:return sM;case 35675:return rM;case 35676:return oM;case 5124:case 35670:return aM;case 35667:case 35671:return lM;case 35668:case 35672:return cM;case 35669:case 35673:return uM;case 5125:return hM;case 36294:return dM;case 36295:return fM;case 36296:return pM;case 35678:case 36198:case 36298:case 36306:case 35682:return mM;case 35679:case 36299:case 36307:return gM;case 35680:case 36300:case 36308:case 36293:return xM;case 36289:case 36303:case 36311:case 36292:return _M}}function vM(c,t){c.uniform1fv(this.addr,t)}function bM(c,t){const e=_s(t,this.size,2);c.uniform2fv(this.addr,e)}function MM(c,t){const e=_s(t,this.size,3);c.uniform3fv(this.addr,e)}function wM(c,t){const e=_s(t,this.size,4);c.uniform4fv(this.addr,e)}function SM(c,t){const e=_s(t,this.size,4);c.uniformMatrix2fv(this.addr,!1,e)}function TM(c,t){const e=_s(t,this.size,9);c.uniformMatrix3fv(this.addr,!1,e)}function EM(c,t){const e=_s(t,this.size,16);c.uniformMatrix4fv(this.addr,!1,e)}function AM(c,t){c.uniform1iv(this.addr,t)}function LM(c,t){c.uniform2iv(this.addr,t)}function CM(c,t){c.uniform3iv(this.addr,t)}function RM(c,t){c.uniform4iv(this.addr,t)}function PM(c,t){c.uniform1uiv(this.addr,t)}function DM(c,t){c.uniform2uiv(this.addr,t)}function IM(c,t){c.uniform3uiv(this.addr,t)}function FM(c,t){c.uniform4uiv(this.addr,t)}function kM(c,t,e){const s=t.length,a=Kd(e,s);c.uniform1iv(this.addr,a);for(let h=0;h!==s;++h)e.safeSetTexture2D(t[h]||Xd,a[h])}function OM(c,t,e){const s=t.length,a=Kd(e,s);c.uniform1iv(this.addr,a);for(let h=0;h!==s;++h)e.safeSetTextureCube(t[h]||jd,a[h])}function BM(c){switch(c){case 5126:return vM;case 35664:return bM;case 35665:return MM;case 35666:return wM;case 35674:return SM;case 35675:return TM;case 35676:return EM;case 5124:case 35670:return AM;case 35667:case 35671:return LM;case 35668:case 35672:return CM;case 35669:case 35673:return RM;case 5125:return PM;case 36294:return DM;case 36295:return IM;case 36296:return FM;case 35678:case 36198:case 36298:case 36306:case 35682:return kM;case 35680:case 36300:case 36308:case 36293:return OM}}function zM(c,t,e){this.id=c,this.addr=e,this.cache=[],this.setValue=yM(t.type)}function Qd(c,t,e){this.id=c,this.addr=e,this.cache=[],this.size=t.size,this.setValue=BM(t.type)}Qd.prototype.updateCache=function(c){const t=this.cache;c instanceof Float32Array&&t.length!==c.length&&(this.cache=new Float32Array(c.length)),Ze(t,c)};function tf(c){this.id=c,this.seq=[],this.map={}}tf.prototype.setValue=function(c,t,e){const s=this.seq;for(let a=0,h=s.length;a!==h;++a){const d=s[a];d.setValue(c,t[d.id],e)}};const sc=/(\w+)(\])?(\[|\.)?/g;function ef(c,t){c.seq.push(t),c.map[t.id]=t}function NM(c,t,e){const s=c.name,a=s.length;for(sc.lastIndex=0;;){const h=sc.exec(s),d=sc.lastIndex;let p=h[1];const g=h[2]==="]",_=h[3];if(g&&(p=p|0),_===void 0||_==="["&&d+2===a){ef(e,_===void 0?new zM(p,c,t):new Qd(p,c,t));break}else{let b=e.map[p];b===void 0&&(b=new tf(p),ef(e,b)),e=b}}}function pi(c,t){this.seq=[],this.map={};const e=c.getProgramParameter(t,35718);for(let s=0;s<e;++s){const a=c.getActiveUniform(t,s),h=c.getUniformLocation(t,a.name);NM(a,h,this)}}pi.prototype.setValue=function(c,t,e,s){const a=this.map[t];a!==void 0&&a.setValue(c,e,s)};pi.prototype.setOptional=function(c,t,e){const s=t[e];s!==void 0&&this.setValue(c,e,s)};pi.upload=function(c,t,e,s){for(let a=0,h=t.length;a!==h;++a){const d=t[a],p=e[d.id];p.needsUpdate!==!1&&d.setValue(c,p.value,s)}};pi.seqWithValue=function(c,t){const e=[];for(let s=0,a=c.length;s!==a;++s){const h=c[s];h.id in t&&e.push(h)}return e};function nf(c,t,e){const s=c.createShader(t);return c.shaderSource(s,e),c.compileShader(s),s}let VM=0;function UM(c){const t=c.split(`
`);for(let e=0;e<t.length;e++)t[e]=e+1+": "+t[e];return t.join(`
`)}function sf(c){switch(c){case qe:return["Linear","( value )"];case Li:return["sRGB","( value )"];case vl:return["RGBE","( value )"];case dd:return["RGBM","( value, 7.0 )"];case fd:return["RGBM","( value, 16.0 )"];case pd:return["RGBD","( value, 256.0 )"];case yl:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case I0:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",c),["Linear","( value )"]}}function rf(c,t,e){const s=c.getShaderParameter(t,35713),a=c.getShaderInfoLog(t).trim();return s&&a===""?"":e.toUpperCase()+`

`+a+`

`+UM(c.getShaderSource(t))}function ys(c,t){const e=sf(t);return"vec4 "+c+"( vec4 value ) { return "+e[0]+"ToLinear"+e[1]+"; }"}function HM(c,t){const e=sf(t);return"vec4 "+c+"( vec4 value ) { return LinearTo"+e[0]+e[1]+"; }"}function WM(c,t){let e;switch(t){case P_:e="Linear";break;case D_:e="Reinhard";break;case I_:e="OptimizedCineon";break;case F_:e="ACESFilmic";break;case k_:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+c+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}function GM(c){return[c.extensionDerivatives||c.envMapCubeUV||c.bumpMap||c.tangentSpaceNormalMap||c.clearcoatNormalMap||c.flatShading||c.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(c.extensionFragDepth||c.logarithmicDepthBuffer)&&c.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",c.extensionDrawBuffers&&c.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(c.extensionShaderTextureLOD||c.envMap||c.transmission)&&c.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(mr).join(`
`)}function XM(c){const t=[];for(const e in c){const s=c[e];s!==!1&&t.push("#define "+e+" "+s)}return t.join(`
`)}function jM(c,t){const e={},s=c.getProgramParameter(t,35721);for(let a=0;a<s;a++){const h=c.getActiveAttrib(t,a),d=h.name;let p=1;h.type===35674&&(p=2),h.type===35675&&(p=3),h.type===35676&&(p=4),e[d]={type:h.type,location:c.getAttribLocation(t,d),locationSize:p}}return e}function mr(c){return c!==""}function of(c,t){return c.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function af(c,t){return c.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const qM=/^[ \t]*#include +<([\w\d./]+)>/gm;function rc(c){return c.replace(qM,YM)}function YM(c,t){const e=se[t];if(e===void 0)throw new Error("Can not resolve #include <"+t+">");return rc(e)}const $M=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,ZM=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function lf(c){return c.replace(ZM,cf).replace($M,JM)}function JM(c,t,e,s){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),cf(c,t,e,s)}function cf(c,t,e,s){let a="";for(let h=parseInt(t);h<parseInt(e);h++)a+=s.replace(/\[\s*i\s*\]/g,"[ "+h+" ]").replace(/UNROLLED_LOOP_INDEX/g,h);return a}function uf(c){let t="precision "+c.precision+` float;
precision `+c.precision+" int;";return c.precision==="highp"?t+=`
#define HIGH_PRECISION`:c.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:c.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function KM(c){let t="SHADOWMAP_TYPE_BASIC";return c.shadowMapType===Wh?t="SHADOWMAP_TYPE_PCF":c.shadowMapType===c_?t="SHADOWMAP_TYPE_PCF_SOFT":c.shadowMapType===ir&&(t="SHADOWMAP_TYPE_VSM"),t}function QM(c){let t="ENVMAP_TYPE_CUBE";if(c.envMap)switch(c.envMapMode){case xo:case _o:t="ENVMAP_TYPE_CUBE";break;case yo:case pl:t="ENVMAP_TYPE_CUBE_UV";break}return t}function tw(c){let t="ENVMAP_MODE_REFLECTION";if(c.envMap)switch(c.envMapMode){case _o:case pl:t="ENVMAP_MODE_REFRACTION";break}return t}function ew(c){let t="ENVMAP_BLENDING_NONE";if(c.envMap)switch(c.combine){case go:t="ENVMAP_BLENDING_MULTIPLY";break;case C_:t="ENVMAP_BLENDING_MIX";break;case R_:t="ENVMAP_BLENDING_ADD";break}return t}function nw(c,t,e,s){const a=c.getContext(),h=e.defines;let d=e.vertexShader,p=e.fragmentShader;const g=KM(e),_=QM(e),v=tw(e),b=ew(e),M=c.gammaFactor>0?c.gammaFactor:1,S=e.isWebGL2?"":GM(e),L=XM(h),C=a.createProgram();let k,T,E=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(k=[L].filter(mr).join(`
`),k.length>0&&(k+=`
`),T=[S,L].filter(mr).join(`
`),T.length>0&&(T+=`
`)):(k=[uf(e),"#define SHADER_NAME "+e.shaderName,L,e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+M,"#define MAX_BONES "+e.maxBones,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+v:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.displacementMap&&e.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularTintMap?"#define USE_SPECULARTINTMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.useVertexTexture?"#define BONE_TEXTURE":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.morphTargets&&e.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",e.morphTargets&&e.isWebGL2?"#define MORPHTARGETS_COUNT "+e.morphTargetsCount:"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+g:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(mr).join(`
`),T=[S,uf(e),"#define SHADER_NAME "+e.shaderName,L,"#define GAMMA_FACTOR "+M,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+_:"",e.envMap?"#define "+v:"",e.envMap?"#define "+b:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularTintMap?"#define USE_SPECULARTINTMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.sheen?"#define USE_SHEEN":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+g:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==Ai?"#define TONE_MAPPING":"",e.toneMapping!==Ai?se.tonemapping_pars_fragment:"",e.toneMapping!==Ai?WM("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.format===ji?"#define OPAQUE":"",se.encodings_pars_fragment,e.map?ys("mapTexelToLinear",e.mapEncoding):"",e.matcap?ys("matcapTexelToLinear",e.matcapEncoding):"",e.envMap?ys("envMapTexelToLinear",e.envMapEncoding):"",e.emissiveMap?ys("emissiveMapTexelToLinear",e.emissiveMapEncoding):"",e.specularTintMap?ys("specularTintMapTexelToLinear",e.specularTintMapEncoding):"",e.lightMap?ys("lightMapTexelToLinear",e.lightMapEncoding):"",HM("linearToOutputTexel",e.outputEncoding),e.depthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(mr).join(`
`)),d=rc(d),d=of(d,e),d=af(d,e),p=rc(p),p=of(p,e),p=af(p,e),d=lf(d),p=lf(p),e.isWebGL2&&e.isRawShaderMaterial!==!0&&(E=`#version 300 es
`,k=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+k,T=["#define varying in",e.glslVersion===md?"":"out highp vec4 pc_fragColor;",e.glslVersion===md?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+T);const z=E+k+d,I=E+T+p,V=nf(a,35633,z),G=nf(a,35632,I);if(a.attachShader(C,V),a.attachShader(C,G),e.index0AttributeName!==void 0?a.bindAttribLocation(C,0,e.index0AttributeName):e.morphTargets===!0&&a.bindAttribLocation(C,0,"position"),a.linkProgram(C),c.debug.checkShaderErrors){const pt=a.getProgramInfoLog(C).trim(),ut=a.getShaderInfoLog(V).trim(),X=a.getShaderInfoLog(G).trim();let ht=!0,it=!0;if(a.getProgramParameter(C,35714)===!1){ht=!1;const Q=rf(a,V,"vertex"),rt=rf(a,G,"fragment");console.error("THREE.WebGLProgram: Shader Error "+a.getError()+" - VALIDATE_STATUS "+a.getProgramParameter(C,35715)+`

Program Info Log: `+pt+`
`+Q+`
`+rt)}else pt!==""?console.warn("THREE.WebGLProgram: Program Info Log:",pt):(ut===""||X==="")&&(it=!1);it&&(this.diagnostics={runnable:ht,programLog:pt,vertexShader:{log:ut,prefix:k},fragmentShader:{log:X,prefix:T}})}a.deleteShader(V),a.deleteShader(G);let F;this.getUniforms=function(){return F===void 0&&(F=new pi(a,C)),F};let K;return this.getAttributes=function(){return K===void 0&&(K=jM(a,C)),K},this.destroy=function(){s.releaseStatesOfProgram(this),a.deleteProgram(C),this.program=void 0},this.name=e.shaderName,this.id=VM++,this.cacheKey=t,this.usedTimes=1,this.program=C,this.vertexShader=V,this.fragmentShader=G,this}function iw(c,t,e,s,a,h,d){const p=[],g=a.isWebGL2,_=a.logarithmicDepthBuffer,v=a.floatVertexTextures,b=a.maxVertexUniforms,M=a.vertexTextures;let S=a.precision;const L={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},C=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoat","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","specularIntensityMap","specularTintMap","specularTintMapEncoding","roughnessMap","metalnessMap","gradientMap","alphaMap","alphaTest","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","morphTargetsCount","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","format","sheen","transmission","transmissionMap","thicknessMap"];function k(F){const pt=F.skeleton.bones;if(v)return 1024;{const X=Math.floor((b-20)/4),ht=Math.min(X,pt.length);return ht<pt.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+pt.length+" bones. This GPU supports "+ht+"."),0):ht}}function T(F){let K;return F&&F.isTexture?K=F.encoding:F&&F.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),K=F.texture.encoding):K=qe,g&&F&&F.isTexture&&F.format===tn&&F.type===ii&&F.encoding===Li&&(K=qe),K}function E(F,K,pt,ut,X){const ht=ut.fog,it=F.isMeshStandardMaterial?ut.environment:null,Q=(F.isMeshStandardMaterial?e:t).get(F.envMap||it),rt=L[F.type],tt=X.isSkinnedMesh?k(X):0;F.precision!==null&&(S=a.getMaxPrecision(F.precision),S!==F.precision&&console.warn("THREE.WebGLProgram.getParameters:",F.precision,"not supported, using",S,"instead."));let st,St;if(rt){const ee=kn[rt];st=ee.vertexShader,St=ee.fragmentShader}else st=F.vertexShader,St=F.fragmentShader;const Bt=c.getRenderTarget(),Wt=F.alphaTest>0,Pt=F.clearcoat>0;return{isWebGL2:g,shaderID:rt,shaderName:F.type,vertexShader:st,fragmentShader:St,defines:F.defines,isRawShaderMaterial:F.isRawShaderMaterial===!0,glslVersion:F.glslVersion,precision:S,instancing:X.isInstancedMesh===!0,instancingColor:X.isInstancedMesh===!0&&X.instanceColor!==null,supportsVertexTextures:M,outputEncoding:Bt!==null?T(Bt.texture):c.outputEncoding,map:!!F.map,mapEncoding:T(F.map),matcap:!!F.matcap,matcapEncoding:T(F.matcap),envMap:!!Q,envMapMode:Q&&Q.mapping,envMapEncoding:T(Q),envMapCubeUV:!!Q&&(Q.mapping===yo||Q.mapping===pl),lightMap:!!F.lightMap,lightMapEncoding:T(F.lightMap),aoMap:!!F.aoMap,emissiveMap:!!F.emissiveMap,emissiveMapEncoding:T(F.emissiveMap),bumpMap:!!F.bumpMap,normalMap:!!F.normalMap,objectSpaceNormalMap:F.normalMapType===O0,tangentSpaceNormalMap:F.normalMapType===Zi,clearcoat:Pt,clearcoatMap:Pt&&!!F.clearcoatMap,clearcoatRoughnessMap:Pt&&!!F.clearcoatRoughnessMap,clearcoatNormalMap:Pt&&!!F.clearcoatNormalMap,displacementMap:!!F.displacementMap,roughnessMap:!!F.roughnessMap,metalnessMap:!!F.metalnessMap,specularMap:!!F.specularMap,specularIntensityMap:!!F.specularIntensityMap,specularTintMap:!!F.specularTintMap,specularTintMapEncoding:T(F.specularTintMap),alphaMap:!!F.alphaMap,alphaTest:Wt,gradientMap:!!F.gradientMap,sheen:F.sheen>0,transmission:F.transmission>0,transmissionMap:!!F.transmissionMap,thicknessMap:!!F.thicknessMap,combine:F.combine,vertexTangents:!!F.normalMap&&!!X.geometry&&!!X.geometry.attributes.tangent,vertexColors:F.vertexColors,vertexAlphas:F.vertexColors===!0&&!!X.geometry&&!!X.geometry.attributes.color&&X.geometry.attributes.color.itemSize===4,vertexUvs:!!F.map||!!F.bumpMap||!!F.normalMap||!!F.specularMap||!!F.alphaMap||!!F.emissiveMap||!!F.roughnessMap||!!F.metalnessMap||!!F.clearcoatMap||!!F.clearcoatRoughnessMap||!!F.clearcoatNormalMap||!!F.displacementMap||!!F.transmissionMap||!!F.thicknessMap||!!F.specularIntensityMap||!!F.specularTintMap,uvsVertexOnly:!(!!F.map||!!F.bumpMap||!!F.normalMap||!!F.specularMap||!!F.alphaMap||!!F.emissiveMap||!!F.roughnessMap||!!F.metalnessMap||!!F.clearcoatNormalMap||F.transmission>0||!!F.transmissionMap||!!F.thicknessMap||!!F.specularIntensityMap||!!F.specularTintMap)&&!!F.displacementMap,fog:!!ht,useFog:F.fog,fogExp2:ht&&ht.isFogExp2,flatShading:!!F.flatShading,sizeAttenuation:F.sizeAttenuation,logarithmicDepthBuffer:_,skinning:X.isSkinnedMesh===!0&&tt>0,maxBones:tt,useVertexTexture:v,morphTargets:!!X.geometry&&!!X.geometry.morphAttributes.position,morphNormals:!!X.geometry&&!!X.geometry.morphAttributes.normal,morphTargetsCount:!!X.geometry&&!!X.geometry.morphAttributes.position?X.geometry.morphAttributes.position.length:0,numDirLights:K.directional.length,numPointLights:K.point.length,numSpotLights:K.spot.length,numRectAreaLights:K.rectArea.length,numHemiLights:K.hemi.length,numDirLightShadows:K.directionalShadowMap.length,numPointLightShadows:K.pointShadowMap.length,numSpotLightShadows:K.spotShadowMap.length,numClippingPlanes:d.numPlanes,numClipIntersection:d.numIntersection,format:F.format,dithering:F.dithering,shadowMapEnabled:c.shadowMap.enabled&&pt.length>0,shadowMapType:c.shadowMap.type,toneMapping:F.toneMapped?c.toneMapping:Ai,physicallyCorrectLights:c.physicallyCorrectLights,premultipliedAlpha:F.premultipliedAlpha,doubleSided:F.side===Wi,flipSided:F.side===ke,depthPacking:F.depthPacking!==void 0?F.depthPacking:!1,index0AttributeName:F.index0AttributeName,extensionDerivatives:F.extensions&&F.extensions.derivatives,extensionFragDepth:F.extensions&&F.extensions.fragDepth,extensionDrawBuffers:F.extensions&&F.extensions.drawBuffers,extensionShaderTextureLOD:F.extensions&&F.extensions.shaderTextureLOD,rendererExtensionFragDepth:g||s.has("EXT_frag_depth"),rendererExtensionDrawBuffers:g||s.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:g||s.has("EXT_shader_texture_lod"),customProgramCacheKey:F.customProgramCacheKey()}}function z(F){const K=[];if(F.shaderID?K.push(F.shaderID):(K.push(F.fragmentShader),K.push(F.vertexShader)),F.defines!==void 0)for(const pt in F.defines)K.push(pt),K.push(F.defines[pt]);if(F.isRawShaderMaterial===!1){for(let pt=0;pt<C.length;pt++)K.push(F[C[pt]]);K.push(c.outputEncoding),K.push(c.gammaFactor)}return K.push(F.customProgramCacheKey),K.join()}function I(F){const K=L[F.type];let pt;if(K){const ut=kn[K];pt=ey.clone(ut.uniforms)}else pt=F.uniforms;return pt}function V(F,K){let pt;for(let ut=0,X=p.length;ut<X;ut++){const ht=p[ut];if(ht.cacheKey===K){pt=ht,++pt.usedTimes;break}}return pt===void 0&&(pt=new nw(c,K,F,h),p.push(pt)),pt}function G(F){if(--F.usedTimes==0){const K=p.indexOf(F);p[K]=p[p.length-1],p.pop(),F.destroy()}}return{getParameters:E,getProgramCacheKey:z,getUniforms:I,acquireProgram:V,releaseProgram:G,programs:p}}function sw(){let c=new WeakMap;function t(h){let d=c.get(h);return d===void 0&&(d={},c.set(h,d)),d}function e(h){c.delete(h)}function s(h,d,p){c.get(h)[d]=p}function a(){c=new WeakMap}return{get:t,remove:e,update:s,dispose:a}}function rw(c,t){return c.groupOrder!==t.groupOrder?c.groupOrder-t.groupOrder:c.renderOrder!==t.renderOrder?c.renderOrder-t.renderOrder:c.program!==t.program?c.program.id-t.program.id:c.material.id!==t.material.id?c.material.id-t.material.id:c.z!==t.z?c.z-t.z:c.id-t.id}function hf(c,t){return c.groupOrder!==t.groupOrder?c.groupOrder-t.groupOrder:c.renderOrder!==t.renderOrder?c.renderOrder-t.renderOrder:c.z!==t.z?t.z-c.z:c.id-t.id}function df(c){const t=[];let e=0;const s=[],a=[],h=[],d={id:-1};function p(){e=0,s.length=0,a.length=0,h.length=0}function g(S,L,C,k,T,E){let z=t[e];const I=c.get(C);return z===void 0?(z={id:S.id,object:S,geometry:L,material:C,program:I.program||d,groupOrder:k,renderOrder:S.renderOrder,z:T,group:E},t[e]=z):(z.id=S.id,z.object=S,z.geometry=L,z.material=C,z.program=I.program||d,z.groupOrder=k,z.renderOrder=S.renderOrder,z.z=T,z.group=E),e++,z}function _(S,L,C,k,T,E){const z=g(S,L,C,k,T,E);C.transmission>0?a.push(z):C.transparent===!0?h.push(z):s.push(z)}function v(S,L,C,k,T,E){const z=g(S,L,C,k,T,E);C.transmission>0?a.unshift(z):C.transparent===!0?h.unshift(z):s.unshift(z)}function b(S,L){s.length>1&&s.sort(S||rw),a.length>1&&a.sort(L||hf),h.length>1&&h.sort(L||hf)}function M(){for(let S=e,L=t.length;S<L;S++){const C=t[S];if(C.id===null)break;C.id=null,C.object=null,C.geometry=null,C.material=null,C.program=null,C.group=null}}return{opaque:s,transmissive:a,transparent:h,init:p,push:_,unshift:v,finish:M,sort:b}}function ow(c){let t=new WeakMap;function e(a,h){let d;return t.has(a)===!1?(d=new df(c),t.set(a,[d])):h>=t.get(a).length?(d=new df(c),t.get(a).push(d)):d=t.get(a)[h],d}function s(){t=new WeakMap}return{get:e,dispose:s}}function aw(){const c={};return{get:function(t){if(c[t.id]!==void 0)return c[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new N,color:new Ht};break;case"SpotLight":e={position:new N,direction:new N,color:new Ht,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new N,color:new Ht,distance:0,decay:0};break;case"HemisphereLight":e={direction:new N,skyColor:new Ht,groundColor:new Ht};break;case"RectAreaLight":e={color:new Ht,position:new N,halfWidth:new N,halfHeight:new N};break}return c[t.id]=e,e}}}function lw(){const c={};return{get:function(t){if(c[t.id]!==void 0)return c[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Mt};break;case"SpotLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Mt};break;case"PointLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Mt,shadowCameraNear:1,shadowCameraFar:1e3};break}return c[t.id]=e,e}}}let cw=0;function uw(c,t){return(t.castShadow?1:0)-(c.castShadow?1:0)}function hw(c,t){const e=new aw,s=lw(),a={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let v=0;v<9;v++)a.probe.push(new N);const h=new N,d=new jt,p=new jt;function g(v,b){let M=0,S=0,L=0;for(let pt=0;pt<9;pt++)a.probe[pt].set(0,0,0);let C=0,k=0,T=0,E=0,z=0,I=0,V=0,G=0;v.sort(uw);const F=b!==!0?Math.PI:1;for(let pt=0,ut=v.length;pt<ut;pt++){const X=v[pt],ht=X.color,it=X.intensity,Q=X.distance,rt=X.shadow&&X.shadow.map?X.shadow.map.texture:null;if(X.isAmbientLight)M+=ht.r*it*F,S+=ht.g*it*F,L+=ht.b*it*F;else if(X.isLightProbe)for(let tt=0;tt<9;tt++)a.probe[tt].addScaledVector(X.sh.coefficients[tt],it);else if(X.isDirectionalLight){const tt=e.get(X);if(tt.color.copy(X.color).multiplyScalar(X.intensity*F),X.castShadow){const st=X.shadow,St=s.get(X);St.shadowBias=st.bias,St.shadowNormalBias=st.normalBias,St.shadowRadius=st.radius,St.shadowMapSize=st.mapSize,a.directionalShadow[C]=St,a.directionalShadowMap[C]=rt,a.directionalShadowMatrix[C]=X.shadow.matrix,I++}a.directional[C]=tt,C++}else if(X.isSpotLight){const tt=e.get(X);if(tt.position.setFromMatrixPosition(X.matrixWorld),tt.color.copy(ht).multiplyScalar(it*F),tt.distance=Q,tt.coneCos=Math.cos(X.angle),tt.penumbraCos=Math.cos(X.angle*(1-X.penumbra)),tt.decay=X.decay,X.castShadow){const st=X.shadow,St=s.get(X);St.shadowBias=st.bias,St.shadowNormalBias=st.normalBias,St.shadowRadius=st.radius,St.shadowMapSize=st.mapSize,a.spotShadow[T]=St,a.spotShadowMap[T]=rt,a.spotShadowMatrix[T]=X.shadow.matrix,G++}a.spot[T]=tt,T++}else if(X.isRectAreaLight){const tt=e.get(X);tt.color.copy(ht).multiplyScalar(it),tt.halfWidth.set(X.width*.5,0,0),tt.halfHeight.set(0,X.height*.5,0),a.rectArea[E]=tt,E++}else if(X.isPointLight){const tt=e.get(X);if(tt.color.copy(X.color).multiplyScalar(X.intensity*F),tt.distance=X.distance,tt.decay=X.decay,X.castShadow){const st=X.shadow,St=s.get(X);St.shadowBias=st.bias,St.shadowNormalBias=st.normalBias,St.shadowRadius=st.radius,St.shadowMapSize=st.mapSize,St.shadowCameraNear=st.camera.near,St.shadowCameraFar=st.camera.far,a.pointShadow[k]=St,a.pointShadowMap[k]=rt,a.pointShadowMatrix[k]=X.shadow.matrix,V++}a.point[k]=tt,k++}else if(X.isHemisphereLight){const tt=e.get(X);tt.skyColor.copy(X.color).multiplyScalar(it*F),tt.groundColor.copy(X.groundColor).multiplyScalar(it*F),a.hemi[z]=tt,z++}}E>0&&(t.isWebGL2||c.has("OES_texture_float_linear")===!0?(a.rectAreaLTC1=Ct.LTC_FLOAT_1,a.rectAreaLTC2=Ct.LTC_FLOAT_2):c.has("OES_texture_half_float_linear")===!0?(a.rectAreaLTC1=Ct.LTC_HALF_1,a.rectAreaLTC2=Ct.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),a.ambient[0]=M,a.ambient[1]=S,a.ambient[2]=L;const K=a.hash;(K.directionalLength!==C||K.pointLength!==k||K.spotLength!==T||K.rectAreaLength!==E||K.hemiLength!==z||K.numDirectionalShadows!==I||K.numPointShadows!==V||K.numSpotShadows!==G)&&(a.directional.length=C,a.spot.length=T,a.rectArea.length=E,a.point.length=k,a.hemi.length=z,a.directionalShadow.length=I,a.directionalShadowMap.length=I,a.pointShadow.length=V,a.pointShadowMap.length=V,a.spotShadow.length=G,a.spotShadowMap.length=G,a.directionalShadowMatrix.length=I,a.pointShadowMatrix.length=V,a.spotShadowMatrix.length=G,K.directionalLength=C,K.pointLength=k,K.spotLength=T,K.rectAreaLength=E,K.hemiLength=z,K.numDirectionalShadows=I,K.numPointShadows=V,K.numSpotShadows=G,a.version=cw++)}function _(v,b){let M=0,S=0,L=0,C=0,k=0;const T=b.matrixWorldInverse;for(let E=0,z=v.length;E<z;E++){const I=v[E];if(I.isDirectionalLight){const V=a.directional[M];V.direction.setFromMatrixPosition(I.matrixWorld),h.setFromMatrixPosition(I.target.matrixWorld),V.direction.sub(h),V.direction.transformDirection(T),M++}else if(I.isSpotLight){const V=a.spot[L];V.position.setFromMatrixPosition(I.matrixWorld),V.position.applyMatrix4(T),V.direction.setFromMatrixPosition(I.matrixWorld),h.setFromMatrixPosition(I.target.matrixWorld),V.direction.sub(h),V.direction.transformDirection(T),L++}else if(I.isRectAreaLight){const V=a.rectArea[C];V.position.setFromMatrixPosition(I.matrixWorld),V.position.applyMatrix4(T),p.identity(),d.copy(I.matrixWorld),d.premultiply(T),p.extractRotation(d),V.halfWidth.set(I.width*.5,0,0),V.halfHeight.set(0,I.height*.5,0),V.halfWidth.applyMatrix4(p),V.halfHeight.applyMatrix4(p),C++}else if(I.isPointLight){const V=a.point[S];V.position.setFromMatrixPosition(I.matrixWorld),V.position.applyMatrix4(T),S++}else if(I.isHemisphereLight){const V=a.hemi[k];V.direction.setFromMatrixPosition(I.matrixWorld),V.direction.transformDirection(T),V.direction.normalize(),k++}}}return{setup:g,setupView:_,state:a}}function ff(c,t){const e=new hw(c,t),s=[],a=[];function h(){s.length=0,a.length=0}function d(b){s.push(b)}function p(b){a.push(b)}function g(b){e.setup(s,b)}function _(b){e.setupView(s,b)}return{init:h,state:{lightsArray:s,shadowsArray:a,lights:e},setupLights:g,setupLightsView:_,pushLight:d,pushShadow:p}}function dw(c,t){let e=new WeakMap;function s(h,d=0){let p;return e.has(h)===!1?(p=new ff(c,t),e.set(h,[p])):d>=e.get(h).length?(p=new ff(c,t),e.get(h).push(p)):p=e.get(h)[d],p}function a(){e=new WeakMap}return{get:s,dispose:a}}class pf extends Ye{constructor(t){super();this.type="MeshDepthMaterial",this.depthPacking=F0,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}pf.prototype.isMeshDepthMaterial=!0;class mf extends Ye{constructor(t){super();this.type="MeshDistanceMaterial",this.referencePosition=new N,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}mf.prototype.isMeshDistanceMaterial=!0;const fw=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,pw=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
uniform float samples;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function gf(c,t,e){let s=new jo;const a=new Mt,h=new Mt,d=new ge,p=new pf({depthPacking:k0}),g=new mf,_={},v=e.maxTextureSize,b={0:ke,1:sr,2:Wi},M=new Di({uniforms:{shadow_pass:{value:null},resolution:{value:new Mt},radius:{value:4},samples:{value:8}},vertexShader:fw,fragmentShader:pw}),S=M.clone();S.defines.HORIZONTAL_PASS=1;const L=new ve;L.setAttribute("position",new Oe(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const C=new rn(L,M),k=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Wh,this.render=function(I,V,G){if(k.enabled===!1||k.autoUpdate===!1&&k.needsUpdate===!1||I.length===0)return;const F=c.getRenderTarget(),K=c.getActiveCubeFace(),pt=c.getActiveMipmapLevel(),ut=c.state;ut.setBlending(ni),ut.buffers.color.setClear(1,1,1,1),ut.buffers.depth.setTest(!0),ut.setScissorTest(!1);for(let X=0,ht=I.length;X<ht;X++){const it=I[X],Q=it.shadow;if(Q===void 0){console.warn("THREE.WebGLShadowMap:",it,"has no shadow.");continue}if(Q.autoUpdate===!1&&Q.needsUpdate===!1)continue;a.copy(Q.mapSize);const rt=Q.getFrameExtents();if(a.multiply(rt),h.copy(Q.mapSize),(a.x>v||a.y>v)&&(a.x>v&&(h.x=Math.floor(v/rt.x),a.x=h.x*rt.x,Q.mapSize.x=h.x),a.y>v&&(h.y=Math.floor(v/rt.y),a.y=h.y*rt.y,Q.mapSize.y=h.y)),Q.map===null&&!Q.isPointLightShadow&&this.type===ir){const st={minFilter:xn,magFilter:xn,format:tn};Q.map=new Fn(a.x,a.y,st),Q.map.texture.name=it.name+".shadowMap",Q.mapPass=new Fn(a.x,a.y,st),Q.camera.updateProjectionMatrix()}if(Q.map===null){const st={minFilter:Ne,magFilter:Ne,format:tn};Q.map=new Fn(a.x,a.y,st),Q.map.texture.name=it.name+".shadowMap",Q.camera.updateProjectionMatrix()}c.setRenderTarget(Q.map),c.clear();const tt=Q.getViewportCount();for(let st=0;st<tt;st++){const St=Q.getViewport(st);d.set(h.x*St.x,h.y*St.y,h.x*St.z,h.y*St.w),ut.viewport(d),Q.updateMatrices(it,st),s=Q.getFrustum(),z(V,G,Q.camera,it,this.type)}!Q.isPointLightShadow&&this.type===ir&&T(Q,G),Q.needsUpdate=!1}k.needsUpdate=!1,c.setRenderTarget(F,K,pt)};function T(I,V){const G=t.update(C);M.uniforms.shadow_pass.value=I.map.texture,M.uniforms.resolution.value=I.mapSize,M.uniforms.radius.value=I.radius,M.uniforms.samples.value=I.blurSamples,c.setRenderTarget(I.mapPass),c.clear(),c.renderBufferDirect(V,null,G,M,C,null),S.uniforms.shadow_pass.value=I.mapPass.texture,S.uniforms.resolution.value=I.mapSize,S.uniforms.radius.value=I.radius,S.uniforms.samples.value=I.blurSamples,c.setRenderTarget(I.map),c.clear(),c.renderBufferDirect(V,null,G,S,C,null)}function E(I,V,G,F,K,pt,ut){let X=null;const ht=F.isPointLight===!0?I.customDistanceMaterial:I.customDepthMaterial;if(ht!==void 0?X=ht:X=F.isPointLight===!0?g:p,c.localClippingEnabled&&G.clipShadows===!0&&G.clippingPlanes.length!==0||G.displacementMap&&G.displacementScale!==0||G.alphaMap&&G.alphaTest>0){const it=X.uuid,Q=G.uuid;let rt=_[it];rt===void 0&&(rt={},_[it]=rt);let tt=rt[Q];tt===void 0&&(tt=X.clone(),rt[Q]=tt),X=tt}return X.visible=G.visible,X.wireframe=G.wireframe,ut===ir?X.side=G.shadowSide!==null?G.shadowSide:G.side:X.side=G.shadowSide!==null?G.shadowSide:b[G.side],X.alphaMap=G.alphaMap,X.alphaTest=G.alphaTest,X.clipShadows=G.clipShadows,X.clippingPlanes=G.clippingPlanes,X.clipIntersection=G.clipIntersection,X.displacementMap=G.displacementMap,X.displacementScale=G.displacementScale,X.displacementBias=G.displacementBias,X.wireframeLinewidth=G.wireframeLinewidth,X.linewidth=G.linewidth,F.isPointLight===!0&&X.isMeshDistanceMaterial===!0&&(X.referencePosition.setFromMatrixPosition(F.matrixWorld),X.nearDistance=K,X.farDistance=pt),X}function z(I,V,G,F,K){if(I.visible===!1)return;if(I.layers.test(V.layers)&&(I.isMesh||I.isLine||I.isPoints)&&(I.castShadow||I.receiveShadow&&K===ir)&&(!I.frustumCulled||s.intersectsObject(I))){I.modelViewMatrix.multiplyMatrices(G.matrixWorldInverse,I.matrixWorld);const X=t.update(I),ht=I.material;if(Array.isArray(ht)){const it=X.groups;for(let Q=0,rt=it.length;Q<rt;Q++){const tt=it[Q],st=ht[tt.materialIndex];if(st&&st.visible){const St=E(I,X,st,F,G.near,G.far,K);c.renderBufferDirect(G,null,X,St,I,tt)}}}else if(ht.visible){const it=E(I,X,ht,F,G.near,G.far,K);c.renderBufferDirect(G,null,X,it,I,null)}}const ut=I.children;for(let X=0,ht=ut.length;X<ht;X++)z(ut[X],V,G,F,K)}}function mw(c,t,e){const s=e.isWebGL2;function a(){let W=!1;const Lt=new ge;let nt=null;const mt=new ge(0,0,0,0);return{setMask:function(kt){nt!==kt&&!W&&(c.colorMask(kt,kt,kt,kt),nt=kt)},setLocked:function(kt){W=kt},setClear:function(kt,Qt,De,Ie,Je){Je===!0&&(kt*=Ie,Qt*=Ie,De*=Ie),Lt.set(kt,Qt,De,Ie),mt.equals(Lt)===!1&&(c.clearColor(kt,Qt,De,Ie),mt.copy(Lt))},reset:function(){W=!1,nt=null,mt.set(-1,0,0,0)}}}function h(){let W=!1,Lt=null,nt=null,mt=null;return{setTest:function(kt){kt?re(2929):xt(2929)},setMask:function(kt){Lt!==kt&&!W&&(c.depthMask(kt),Lt=kt)},setFunc:function(kt){if(nt!==kt){if(kt)switch(kt){case M_:c.depthFunc(512);break;case w_:c.depthFunc(519);break;case S_:c.depthFunc(513);break;case hl:c.depthFunc(515);break;case T_:c.depthFunc(514);break;case E_:c.depthFunc(518);break;case A_:c.depthFunc(516);break;case L_:c.depthFunc(517);break;default:c.depthFunc(515)}else c.depthFunc(515);nt=kt}},setLocked:function(kt){W=kt},setClear:function(kt){mt!==kt&&(c.clearDepth(kt),mt=kt)},reset:function(){W=!1,Lt=null,nt=null,mt=null}}}function d(){let W=!1,Lt=null,nt=null,mt=null,kt=null,Qt=null,De=null,Ie=null,Je=null;return{setTest:function(me){W||(me?re(2960):xt(2960))},setMask:function(me){Lt!==me&&!W&&(c.stencilMask(me),Lt=me)},setFunc:function(me,dn,vn){(nt!==me||mt!==dn||kt!==vn)&&(c.stencilFunc(me,dn,vn),nt=me,mt=dn,kt=vn)},setOp:function(me,dn,vn){(Qt!==me||De!==dn||Ie!==vn)&&(c.stencilOp(me,dn,vn),Qt=me,De=dn,Ie=vn)},setLocked:function(me){W=me},setClear:function(me){Je!==me&&(c.clearStencil(me),Je=me)},reset:function(){W=!1,Lt=null,nt=null,mt=null,kt=null,Qt=null,De=null,Ie=null,Je=null}}}const p=new a,g=new h,_=new d;let v={},b=null,M={},S=null,L=!1,C=null,k=null,T=null,E=null,z=null,I=null,V=null,G=!1,F=null,K=null,pt=null,ut=null,X=null;const ht=c.getParameter(35661);let it=!1,Q=0;const rt=c.getParameter(7938);rt.indexOf("WebGL")!==-1?(Q=parseFloat(/^WebGL (\d)/.exec(rt)[1]),it=Q>=1):rt.indexOf("OpenGL ES")!==-1&&(Q=parseFloat(/^OpenGL ES (\d)/.exec(rt)[1]),it=Q>=2);let tt=null,st={};const St=c.getParameter(3088),Bt=c.getParameter(2978),Wt=new ge().fromArray(St),Pt=new ge().fromArray(Bt);function Zt(W,Lt,nt){const mt=new Uint8Array(4),kt=c.createTexture();c.bindTexture(W,kt),c.texParameteri(W,10241,9728),c.texParameteri(W,10240,9728);for(let Qt=0;Qt<nt;Qt++)c.texImage2D(Lt+Qt,0,6408,1,1,0,6408,5121,mt);return kt}const ee={};ee[3553]=Zt(3553,3553,1),ee[34067]=Zt(34067,34069,6),p.setClear(0,0,0,1),g.setClear(1),_.setClear(0),re(2929),g.setFunc(hl),dt(!1),_t(Hh),re(2884),Jt(ni);function re(W){v[W]!==!0&&(c.enable(W),v[W]=!0)}function xt(W){v[W]!==!1&&(c.disable(W),v[W]=!1)}function Y(W){W!==b&&(c.bindFramebuffer(36160,W),b=W)}function Xt(W,Lt){return Lt===null&&b!==null&&(Lt=b),M[W]!==Lt?(c.bindFramebuffer(W,Lt),M[W]=Lt,s&&(W===36009&&(M[36160]=Lt),W===36160&&(M[36009]=Lt)),!0):!1}function It(W){return S!==W?(c.useProgram(W),S=W,!0):!1}const vt={[Gi]:32774,[h_]:32778,[d_]:32779};if(s)vt[Yh]=32775,vt[$h]=32776;else{const W=t.get("EXT_blend_minmax");W!==null&&(vt[Yh]=W.MIN_EXT,vt[$h]=W.MAX_EXT)}const Ft={[f_]:0,[p_]:1,[m_]:768,[Zh]:770,[b_]:776,[y_]:774,[x_]:772,[g_]:769,[Jh]:771,[v_]:775,[__]:773};function Jt(W,Lt,nt,mt,kt,Qt,De,Ie){if(W===ni){L===!0&&(xt(3042),L=!1);return}if(L===!1&&(re(3042),L=!0),W!==u_){if(W!==C||Ie!==G){if((k!==Gi||z!==Gi)&&(c.blendEquation(32774),k=Gi,z=Gi),Ie)switch(W){case rr:c.blendFuncSeparate(1,771,1,771);break;case Xh:c.blendFunc(1,1);break;case jh:c.blendFuncSeparate(0,0,769,771);break;case qh:c.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",W);break}else switch(W){case rr:c.blendFuncSeparate(770,771,1,771);break;case Xh:c.blendFunc(770,1);break;case jh:c.blendFunc(0,769);break;case qh:c.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",W);break}T=null,E=null,I=null,V=null,C=W,G=Ie}return}kt=kt||Lt,Qt=Qt||nt,De=De||mt,(Lt!==k||kt!==z)&&(c.blendEquationSeparate(vt[Lt],vt[kt]),k=Lt,z=kt),(nt!==T||mt!==E||Qt!==I||De!==V)&&(c.blendFuncSeparate(Ft[nt],Ft[mt],Ft[Qt],Ft[De]),T=nt,E=mt,I=Qt,V=De),C=W,G=null}function ot(W,Lt){W.side===Wi?xt(2884):re(2884);let nt=W.side===ke;Lt&&(nt=!nt),dt(nt),W.blending===rr&&W.transparent===!1?Jt(ni):Jt(W.blending,W.blendEquation,W.blendSrc,W.blendDst,W.blendEquationAlpha,W.blendSrcAlpha,W.blendDstAlpha,W.premultipliedAlpha),g.setFunc(W.depthFunc),g.setTest(W.depthTest),g.setMask(W.depthWrite),p.setMask(W.colorWrite);const mt=W.stencilWrite;_.setTest(mt),mt&&(_.setMask(W.stencilWriteMask),_.setFunc(W.stencilFunc,W.stencilRef,W.stencilFuncMask),_.setOp(W.stencilFail,W.stencilZFail,W.stencilZPass)),Rt(W.polygonOffset,W.polygonOffsetFactor,W.polygonOffsetUnits),W.alphaToCoverage===!0?re(32926):xt(32926)}function dt(W){F!==W&&(W?c.frontFace(2304):c.frontFace(2305),F=W)}function _t(W){W!==a_?(re(2884),W!==K&&(W===Hh?c.cullFace(1029):W===l_?c.cullFace(1028):c.cullFace(1032))):xt(2884),K=W}function Nt(W){W!==pt&&(it&&c.lineWidth(W),pt=W)}function Rt(W,Lt,nt){W?(re(32823),(ut!==Lt||X!==nt)&&(c.polygonOffset(Lt,nt),ut=Lt,X=nt)):xt(32823)}function B(W){W?re(3089):xt(3089)}function D(W){W===void 0&&(W=33984+ht-1),tt!==W&&(c.activeTexture(W),tt=W)}function et(W,Lt){tt===null&&D();let nt=st[tt];nt===void 0&&(nt={type:void 0,texture:void 0},st[tt]=nt),(nt.type!==W||nt.texture!==Lt)&&(c.bindTexture(W,Lt||ee[W]),nt.type=W,nt.texture=Lt)}function bt(){const W=st[tt];W!==void 0&&W.type!==void 0&&(c.bindTexture(W.type,null),W.type=void 0,W.texture=void 0)}function at(){try{c.compressedTexImage2D.apply(c,arguments)}catch(W){console.error("THREE.WebGLState:",W)}}function gt(){try{c.texImage2D.apply(c,arguments)}catch(W){console.error("THREE.WebGLState:",W)}}function Et(){try{c.texImage3D.apply(c,arguments)}catch(W){console.error("THREE.WebGLState:",W)}}function At(W){Wt.equals(W)===!1&&(c.scissor(W.x,W.y,W.z,W.w),Wt.copy(W))}function Vt(W){Pt.equals(W)===!1&&(c.viewport(W.x,W.y,W.z,W.w),Pt.copy(W))}function ft(){c.disable(3042),c.disable(2884),c.disable(2929),c.disable(32823),c.disable(3089),c.disable(2960),c.disable(32926),c.blendEquation(32774),c.blendFunc(1,0),c.blendFuncSeparate(1,0,1,0),c.colorMask(!0,!0,!0,!0),c.clearColor(0,0,0,0),c.depthMask(!0),c.depthFunc(513),c.clearDepth(1),c.stencilMask(4294967295),c.stencilFunc(519,0,4294967295),c.stencilOp(7680,7680,7680),c.clearStencil(0),c.cullFace(1029),c.frontFace(2305),c.polygonOffset(0,0),c.activeTexture(33984),c.bindFramebuffer(36160,null),s===!0&&(c.bindFramebuffer(36009,null),c.bindFramebuffer(36008,null)),c.useProgram(null),c.lineWidth(1),c.scissor(0,0,c.canvas.width,c.canvas.height),c.viewport(0,0,c.canvas.width,c.canvas.height),v={},tt=null,st={},b=null,M={},S=null,L=!1,C=null,k=null,T=null,E=null,z=null,I=null,V=null,G=!1,F=null,K=null,pt=null,ut=null,X=null,Wt.set(0,0,c.canvas.width,c.canvas.height),Pt.set(0,0,c.canvas.width,c.canvas.height),p.reset(),g.reset(),_.reset()}return{buffers:{color:p,depth:g,stencil:_},enable:re,disable:xt,bindFramebuffer:Xt,bindXRFramebuffer:Y,useProgram:It,setBlending:Jt,setMaterial:ot,setFlipSided:dt,setCullFace:_t,setLineWidth:Nt,setPolygonOffset:Rt,setScissorTest:B,activeTexture:D,bindTexture:et,unbindTexture:bt,compressedTexImage2D:at,texImage2D:gt,texImage3D:Et,scissor:At,viewport:Vt,reset:ft}}function gw(c,t,e,s,a,h,d){const p=a.isWebGL2,g=a.maxTextures,_=a.maxCubemapSize,v=a.maxTextureSize,b=a.maxSamples,M=new WeakMap;let S,L=!1;try{L=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch(B){}function C(B,D){return L?new OffscreenCanvas(B,D):Ao("canvas")}function k(B,D,et,bt){let at=1;if((B.width>bt||B.height>bt)&&(at=bt/Math.max(B.width,B.height)),at<1||D===!0)if(typeof HTMLImageElement!="undefined"&&B instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&B instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&B instanceof ImageBitmap){const gt=D?V0:Math.floor,Et=gt(at*B.width),At=gt(at*B.height);S===void 0&&(S=C(Et,At));const Vt=et?C(Et,At):S;return Vt.width=Et,Vt.height=At,Vt.getContext("2d").drawImage(B,0,0,Et,At),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+B.width+"x"+B.height+") to ("+Et+"x"+At+")."),Vt}else return"data"in B&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+B.width+"x"+B.height+")."),B;return B}function T(B){return gd(B.width)&&gd(B.height)}function E(B){return p?!1:B.wrapS!==ln||B.wrapT!==ln||B.minFilter!==Ne&&B.minFilter!==xn}function z(B,D){return B.generateMipmaps&&D&&B.minFilter!==Ne&&B.minFilter!==xn}function I(B,D,et,bt,at=1){c.generateMipmap(B);const gt=s.get(D);gt.__maxMipLevel=Math.log2(Math.max(et,bt,at))}function V(B,D,et,bt){if(p===!1)return D;if(B!==null){if(c[B]!==void 0)return c[B];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+B+"'")}let at=D;return D===6403&&(et===5126&&(at=33326),et===5131&&(at=33325),et===5121&&(at=33321)),D===6407&&(et===5126&&(at=34837),et===5131&&(at=34843),et===5121&&(at=32849)),D===6408&&(et===5126&&(at=34836),et===5131&&(at=34842),et===5121&&(at=bt===Li?35907:32856)),(at===33325||at===33326||at===34842||at===34836)&&t.get("EXT_color_buffer_float"),at}function G(B){return B===Ne||B===Qh||B===td?9728:9729}function F(B){const D=B.target;D.removeEventListener("dispose",F),pt(D),D.isVideoTexture&&M.delete(D),d.memory.textures--}function K(B){const D=B.target;D.removeEventListener("dispose",K),ut(D)}function pt(B){const D=s.get(B);D.__webglInit!==void 0&&(c.deleteTexture(D.__webglTexture),s.remove(B))}function ut(B){const D=B.texture,et=s.get(B),bt=s.get(D);if(!!B){if(bt.__webglTexture!==void 0&&(c.deleteTexture(bt.__webglTexture),d.memory.textures--),B.depthTexture&&B.depthTexture.dispose(),B.isWebGLCubeRenderTarget)for(let at=0;at<6;at++)c.deleteFramebuffer(et.__webglFramebuffer[at]),et.__webglDepthbuffer&&c.deleteRenderbuffer(et.__webglDepthbuffer[at]);else c.deleteFramebuffer(et.__webglFramebuffer),et.__webglDepthbuffer&&c.deleteRenderbuffer(et.__webglDepthbuffer),et.__webglMultisampledFramebuffer&&c.deleteFramebuffer(et.__webglMultisampledFramebuffer),et.__webglColorRenderbuffer&&c.deleteRenderbuffer(et.__webglColorRenderbuffer),et.__webglDepthRenderbuffer&&c.deleteRenderbuffer(et.__webglDepthRenderbuffer);if(B.isWebGLMultipleRenderTargets)for(let at=0,gt=D.length;at<gt;at++){const Et=s.get(D[at]);Et.__webglTexture&&(c.deleteTexture(Et.__webglTexture),d.memory.textures--),s.remove(D[at])}s.remove(D),s.remove(B)}}let X=0;function ht(){X=0}function it(){const B=X;return B>=g&&console.warn("THREE.WebGLTextures: Trying to use "+B+" texture units while this GPU supports only "+g),X+=1,B}function Q(B,D){const et=s.get(B);if(B.isVideoTexture&&ot(B),B.version>0&&et.__version!==B.version){const bt=B.image;if(bt===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(bt.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Zt(et,B,D);return}}e.activeTexture(33984+D),e.bindTexture(3553,et.__webglTexture)}function rt(B,D){const et=s.get(B);if(B.version>0&&et.__version!==B.version){Zt(et,B,D);return}e.activeTexture(33984+D),e.bindTexture(35866,et.__webglTexture)}function tt(B,D){const et=s.get(B);if(B.version>0&&et.__version!==B.version){Zt(et,B,D);return}e.activeTexture(33984+D),e.bindTexture(32879,et.__webglTexture)}function st(B,D){const et=s.get(B);if(B.version>0&&et.__version!==B.version){ee(et,B,D);return}e.activeTexture(33984+D),e.bindTexture(34067,et.__webglTexture)}const St={[ml]:10497,[ln]:33071,[gl]:33648},Bt={[Ne]:9728,[Qh]:9984,[td]:9986,[xn]:9729,[O_]:9985,[vo]:9987};function Wt(B,D,et){if(et?(c.texParameteri(B,10242,St[D.wrapS]),c.texParameteri(B,10243,St[D.wrapT]),(B===32879||B===35866)&&c.texParameteri(B,32882,St[D.wrapR]),c.texParameteri(B,10240,Bt[D.magFilter]),c.texParameteri(B,10241,Bt[D.minFilter])):(c.texParameteri(B,10242,33071),c.texParameteri(B,10243,33071),(B===32879||B===35866)&&c.texParameteri(B,32882,33071),(D.wrapS!==ln||D.wrapT!==ln)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),c.texParameteri(B,10240,G(D.magFilter)),c.texParameteri(B,10241,G(D.minFilter)),D.minFilter!==Ne&&D.minFilter!==xn&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),t.has("EXT_texture_filter_anisotropic")===!0){const bt=t.get("EXT_texture_filter_anisotropic");if(D.type===si&&t.has("OES_texture_float_linear")===!1||p===!1&&D.type===Xi&&t.has("OES_texture_half_float_linear")===!1)return;(D.anisotropy>1||s.get(D).__currentAnisotropy)&&(c.texParameterf(B,bt.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(D.anisotropy,a.getMaxAnisotropy())),s.get(D).__currentAnisotropy=D.anisotropy)}}function Pt(B,D){B.__webglInit===void 0&&(B.__webglInit=!0,D.addEventListener("dispose",F),B.__webglTexture=c.createTexture(),d.memory.textures++)}function Zt(B,D,et){let bt=3553;D.isDataTexture2DArray&&(bt=35866),D.isDataTexture3D&&(bt=32879),Pt(B,D),e.activeTexture(33984+et),e.bindTexture(bt,B.__webglTexture),c.pixelStorei(37440,D.flipY),c.pixelStorei(37441,D.premultiplyAlpha),c.pixelStorei(3317,D.unpackAlignment),c.pixelStorei(37443,0);const at=E(D)&&T(D.image)===!1,gt=k(D.image,at,!1,v),Et=T(gt)||p,At=h.convert(D.format);let Vt=h.convert(D.type),ft=V(D.internalFormat,At,Vt,D.encoding);Wt(bt,D,Et);let W;const Lt=D.mipmaps;if(D.isDepthTexture)ft=6402,p?D.type===si?ft=36012:D.type===Mo?ft=33190:D.type===or?ft=35056:ft=33189:D.type===si&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),D.format===qi&&ft===6402&&D.type!==bo&&D.type!==Mo&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),D.type=bo,Vt=h.convert(D.type)),D.format===ar&&ft===6402&&(ft=34041,D.type!==or&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),D.type=or,Vt=h.convert(D.type))),e.texImage2D(3553,0,ft,gt.width,gt.height,0,At,Vt,null);else if(D.isDataTexture)if(Lt.length>0&&Et){for(let nt=0,mt=Lt.length;nt<mt;nt++)W=Lt[nt],e.texImage2D(3553,nt,ft,W.width,W.height,0,At,Vt,W.data);D.generateMipmaps=!1,B.__maxMipLevel=Lt.length-1}else e.texImage2D(3553,0,ft,gt.width,gt.height,0,At,Vt,gt.data),B.__maxMipLevel=0;else if(D.isCompressedTexture){for(let nt=0,mt=Lt.length;nt<mt;nt++)W=Lt[nt],D.format!==tn&&D.format!==ji?At!==null?e.compressedTexImage2D(3553,nt,ft,W.width,W.height,0,W.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):e.texImage2D(3553,nt,ft,W.width,W.height,0,At,Vt,W.data);B.__maxMipLevel=Lt.length-1}else if(D.isDataTexture2DArray)e.texImage3D(35866,0,ft,gt.width,gt.height,gt.depth,0,At,Vt,gt.data),B.__maxMipLevel=0;else if(D.isDataTexture3D)e.texImage3D(32879,0,ft,gt.width,gt.height,gt.depth,0,At,Vt,gt.data),B.__maxMipLevel=0;else if(Lt.length>0&&Et){for(let nt=0,mt=Lt.length;nt<mt;nt++)W=Lt[nt],e.texImage2D(3553,nt,ft,At,Vt,W);D.generateMipmaps=!1,B.__maxMipLevel=Lt.length-1}else e.texImage2D(3553,0,ft,At,Vt,gt),B.__maxMipLevel=0;z(D,Et)&&I(bt,D,gt.width,gt.height),B.__version=D.version,D.onUpdate&&D.onUpdate(D)}function ee(B,D,et){if(D.image.length!==6)return;Pt(B,D),e.activeTexture(33984+et),e.bindTexture(34067,B.__webglTexture),c.pixelStorei(37440,D.flipY),c.pixelStorei(37441,D.premultiplyAlpha),c.pixelStorei(3317,D.unpackAlignment),c.pixelStorei(37443,0);const bt=D&&(D.isCompressedTexture||D.image[0].isCompressedTexture),at=D.image[0]&&D.image[0].isDataTexture,gt=[];for(let nt=0;nt<6;nt++)!bt&&!at?gt[nt]=k(D.image[nt],!1,!0,_):gt[nt]=at?D.image[nt].image:D.image[nt];const Et=gt[0],At=T(Et)||p,Vt=h.convert(D.format),ft=h.convert(D.type),W=V(D.internalFormat,Vt,ft,D.encoding);Wt(34067,D,At);let Lt;if(bt){for(let nt=0;nt<6;nt++){Lt=gt[nt].mipmaps;for(let mt=0;mt<Lt.length;mt++){const kt=Lt[mt];D.format!==tn&&D.format!==ji?Vt!==null?e.compressedTexImage2D(34069+nt,mt,W,kt.width,kt.height,0,kt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):e.texImage2D(34069+nt,mt,W,kt.width,kt.height,0,Vt,ft,kt.data)}}B.__maxMipLevel=Lt.length-1}else{Lt=D.mipmaps;for(let nt=0;nt<6;nt++)if(at){e.texImage2D(34069+nt,0,W,gt[nt].width,gt[nt].height,0,Vt,ft,gt[nt].data);for(let mt=0;mt<Lt.length;mt++){const Qt=Lt[mt].image[nt].image;e.texImage2D(34069+nt,mt+1,W,Qt.width,Qt.height,0,Vt,ft,Qt.data)}}else{e.texImage2D(34069+nt,0,W,Vt,ft,gt[nt]);for(let mt=0;mt<Lt.length;mt++){const kt=Lt[mt];e.texImage2D(34069+nt,mt+1,W,Vt,ft,kt.image[nt])}}B.__maxMipLevel=Lt.length}z(D,At)&&I(34067,D,Et.width,Et.height),B.__version=D.version,D.onUpdate&&D.onUpdate(D)}function re(B,D,et,bt,at){const gt=h.convert(et.format),Et=h.convert(et.type),At=V(et.internalFormat,gt,Et,et.encoding);at===32879||at===35866?e.texImage3D(at,0,At,D.width,D.height,D.depth,0,gt,Et,null):e.texImage2D(at,0,At,D.width,D.height,0,gt,Et,null),e.bindFramebuffer(36160,B),c.framebufferTexture2D(36160,bt,at,s.get(et).__webglTexture,0),e.bindFramebuffer(36160,null)}function xt(B,D,et){if(c.bindRenderbuffer(36161,B),D.depthBuffer&&!D.stencilBuffer){let bt=33189;if(et){const at=D.depthTexture;at&&at.isDepthTexture&&(at.type===si?bt=36012:at.type===Mo&&(bt=33190));const gt=Jt(D);c.renderbufferStorageMultisample(36161,gt,bt,D.width,D.height)}else c.renderbufferStorage(36161,bt,D.width,D.height);c.framebufferRenderbuffer(36160,36096,36161,B)}else if(D.depthBuffer&&D.stencilBuffer){if(et){const bt=Jt(D);c.renderbufferStorageMultisample(36161,bt,35056,D.width,D.height)}else c.renderbufferStorage(36161,34041,D.width,D.height);c.framebufferRenderbuffer(36160,33306,36161,B)}else{const bt=D.isWebGLMultipleRenderTargets===!0?D.texture[0]:D.texture,at=h.convert(bt.format),gt=h.convert(bt.type),Et=V(bt.internalFormat,at,gt,bt.encoding);if(et){const At=Jt(D);c.renderbufferStorageMultisample(36161,At,Et,D.width,D.height)}else c.renderbufferStorage(36161,Et,D.width,D.height)}c.bindRenderbuffer(36161,null)}function Y(B,D){if(D&&D.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,B),!(D.depthTexture&&D.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!s.get(D.depthTexture).__webglTexture||D.depthTexture.image.width!==D.width||D.depthTexture.image.height!==D.height)&&(D.depthTexture.image.width=D.width,D.depthTexture.image.height=D.height,D.depthTexture.needsUpdate=!0),Q(D.depthTexture,0);const bt=s.get(D.depthTexture).__webglTexture;if(D.depthTexture.format===qi)c.framebufferTexture2D(36160,36096,3553,bt,0);else if(D.depthTexture.format===ar)c.framebufferTexture2D(36160,33306,3553,bt,0);else throw new Error("Unknown depthTexture format")}function Xt(B){const D=s.get(B),et=B.isWebGLCubeRenderTarget===!0;if(B.depthTexture){if(et)throw new Error("target.depthTexture not supported in Cube render targets");Y(D.__webglFramebuffer,B)}else if(et){D.__webglDepthbuffer=[];for(let bt=0;bt<6;bt++)e.bindFramebuffer(36160,D.__webglFramebuffer[bt]),D.__webglDepthbuffer[bt]=c.createRenderbuffer(),xt(D.__webglDepthbuffer[bt],B,!1)}else e.bindFramebuffer(36160,D.__webglFramebuffer),D.__webglDepthbuffer=c.createRenderbuffer(),xt(D.__webglDepthbuffer,B,!1);e.bindFramebuffer(36160,null)}function It(B){const D=B.texture,et=s.get(B),bt=s.get(D);B.addEventListener("dispose",K),B.isWebGLMultipleRenderTargets!==!0&&(bt.__webglTexture=c.createTexture(),bt.__version=D.version,d.memory.textures++);const at=B.isWebGLCubeRenderTarget===!0,gt=B.isWebGLMultipleRenderTargets===!0,Et=B.isWebGLMultisampleRenderTarget===!0,At=D.isDataTexture3D||D.isDataTexture2DArray,Vt=T(B)||p;if(p&&D.format===ji&&(D.type===si||D.type===Xi)&&(D.format=tn,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),at){et.__webglFramebuffer=[];for(let ft=0;ft<6;ft++)et.__webglFramebuffer[ft]=c.createFramebuffer()}else if(et.__webglFramebuffer=c.createFramebuffer(),gt)if(a.drawBuffers){const ft=B.texture;for(let W=0,Lt=ft.length;W<Lt;W++){const nt=s.get(ft[W]);nt.__webglTexture===void 0&&(nt.__webglTexture=c.createTexture(),d.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(Et)if(p){et.__webglMultisampledFramebuffer=c.createFramebuffer(),et.__webglColorRenderbuffer=c.createRenderbuffer(),c.bindRenderbuffer(36161,et.__webglColorRenderbuffer);const ft=h.convert(D.format),W=h.convert(D.type),Lt=V(D.internalFormat,ft,W,D.encoding),nt=Jt(B);c.renderbufferStorageMultisample(36161,nt,Lt,B.width,B.height),e.bindFramebuffer(36160,et.__webglMultisampledFramebuffer),c.framebufferRenderbuffer(36160,36064,36161,et.__webglColorRenderbuffer),c.bindRenderbuffer(36161,null),B.depthBuffer&&(et.__webglDepthRenderbuffer=c.createRenderbuffer(),xt(et.__webglDepthRenderbuffer,B,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(at){e.bindTexture(34067,bt.__webglTexture),Wt(34067,D,Vt);for(let ft=0;ft<6;ft++)re(et.__webglFramebuffer[ft],B,D,36064,34069+ft);z(D,Vt)&&I(34067,D,B.width,B.height),e.unbindTexture()}else if(gt){const ft=B.texture;for(let W=0,Lt=ft.length;W<Lt;W++){const nt=ft[W],mt=s.get(nt);e.bindTexture(3553,mt.__webglTexture),Wt(3553,nt,Vt),re(et.__webglFramebuffer,B,nt,36064+W,3553),z(nt,Vt)&&I(3553,nt,B.width,B.height)}e.unbindTexture()}else{let ft=3553;At&&(p?ft=D.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),e.bindTexture(ft,bt.__webglTexture),Wt(ft,D,Vt),re(et.__webglFramebuffer,B,D,36064,ft),z(D,Vt)&&I(ft,D,B.width,B.height,B.depth),e.unbindTexture()}B.depthBuffer&&Xt(B)}function vt(B){const D=T(B)||p,et=B.isWebGLMultipleRenderTargets===!0?B.texture:[B.texture];for(let bt=0,at=et.length;bt<at;bt++){const gt=et[bt];if(z(gt,D)){const Et=B.isWebGLCubeRenderTarget?34067:3553,At=s.get(gt).__webglTexture;e.bindTexture(Et,At),I(Et,gt,B.width,B.height),e.unbindTexture()}}}function Ft(B){if(B.isWebGLMultisampleRenderTarget)if(p){const D=B.width,et=B.height;let bt=16384;B.depthBuffer&&(bt|=256),B.stencilBuffer&&(bt|=1024);const at=s.get(B);e.bindFramebuffer(36008,at.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,at.__webglFramebuffer),c.blitFramebuffer(0,0,D,et,0,0,D,et,bt,9728),e.bindFramebuffer(36008,null),e.bindFramebuffer(36009,at.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function Jt(B){return p&&B.isWebGLMultisampleRenderTarget?Math.min(b,B.samples):0}function ot(B){const D=d.render.frame;M.get(B)!==D&&(M.set(B,D),B.update())}let dt=!1,_t=!1;function Nt(B,D){B&&B.isWebGLRenderTarget&&(dt===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),dt=!0),B=B.texture),Q(B,D)}function Rt(B,D){B&&B.isWebGLCubeRenderTarget&&(_t===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),_t=!0),B=B.texture),st(B,D)}this.allocateTextureUnit=it,this.resetTextureUnits=ht,this.setTexture2D=Q,this.setTexture2DArray=rt,this.setTexture3D=tt,this.setTextureCube=st,this.setupRenderTarget=It,this.updateRenderTargetMipmap=vt,this.updateMultisampleRenderTarget=Ft,this.safeSetTexture2D=Nt,this.safeSetTextureCube=Rt}function xw(c,t,e){const s=e.isWebGL2;function a(h){let d;if(h===ii)return 5121;if(h===V_)return 32819;if(h===U_)return 32820;if(h===H_)return 33635;if(h===B_)return 5120;if(h===z_)return 5122;if(h===bo)return 5123;if(h===N_)return 5124;if(h===Mo)return 5125;if(h===si)return 5126;if(h===Xi)return s?5131:(d=t.get("OES_texture_half_float"),d!==null?d.HALF_FLOAT_OES:null);if(h===W_)return 6406;if(h===ji)return 6407;if(h===tn)return 6408;if(h===G_)return 6409;if(h===X_)return 6410;if(h===qi)return 6402;if(h===ar)return 34041;if(h===q_)return 6403;if(h===Y_)return 36244;if(h===$_)return 33319;if(h===Z_)return 33320;if(h===J_)return 36248;if(h===K_)return 36249;if(h===ed||h===nd||h===id||h===sd)if(d=t.get("WEBGL_compressed_texture_s3tc"),d!==null){if(h===ed)return d.COMPRESSED_RGB_S3TC_DXT1_EXT;if(h===nd)return d.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(h===id)return d.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(h===sd)return d.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(h===rd||h===od||h===ad||h===ld)if(d=t.get("WEBGL_compressed_texture_pvrtc"),d!==null){if(h===rd)return d.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(h===od)return d.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(h===ad)return d.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(h===ld)return d.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(h===Q_)return d=t.get("WEBGL_compressed_texture_etc1"),d!==null?d.COMPRESSED_RGB_ETC1_WEBGL:null;if((h===cd||h===ud)&&(d=t.get("WEBGL_compressed_texture_etc"),d!==null)){if(h===cd)return d.COMPRESSED_RGB8_ETC2;if(h===ud)return d.COMPRESSED_RGBA8_ETC2_EAC}if(h===t0||h===e0||h===n0||h===i0||h===s0||h===r0||h===o0||h===a0||h===l0||h===c0||h===u0||h===h0||h===d0||h===f0||h===m0||h===g0||h===x0||h===_0||h===y0||h===v0||h===b0||h===M0||h===w0||h===S0||h===T0||h===E0||h===A0||h===L0)return d=t.get("WEBGL_compressed_texture_astc"),d!==null?h:null;if(h===p0)return d=t.get("EXT_texture_compression_bptc"),d!==null?h:null;if(h===or)return s?34042:(d=t.get("WEBGL_depth_texture"),d!==null?d.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:a}}class xf extends on{constructor(t=[]){super();this.cameras=t}}xf.prototype.isArrayCamera=!0;class gr extends de{constructor(){super();this.type="Group"}}gr.prototype.isGroup=!0;const _w={type:"move"};class oc{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new gr,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new gr,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new N,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new N),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new gr,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new N,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new N),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,s){let a=null,h=null,d=null;const p=this._targetRay,g=this._grip,_=this._hand;if(t&&e.session.visibilityState!=="visible-blurred")if(p!==null&&(a=e.getPose(t.targetRaySpace,s),a!==null&&(p.matrix.fromArray(a.transform.matrix),p.matrix.decompose(p.position,p.rotation,p.scale),a.linearVelocity?(p.hasLinearVelocity=!0,p.linearVelocity.copy(a.linearVelocity)):p.hasLinearVelocity=!1,a.angularVelocity?(p.hasAngularVelocity=!0,p.angularVelocity.copy(a.angularVelocity)):p.hasAngularVelocity=!1,this.dispatchEvent(_w))),_&&t.hand){d=!0;for(const C of t.hand.values()){const k=e.getJointPose(C,s);if(_.joints[C.jointName]===void 0){const E=new gr;E.matrixAutoUpdate=!1,E.visible=!1,_.joints[C.jointName]=E,_.add(E)}const T=_.joints[C.jointName];k!==null&&(T.matrix.fromArray(k.transform.matrix),T.matrix.decompose(T.position,T.rotation,T.scale),T.jointRadius=k.radius),T.visible=k!==null}const v=_.joints["index-finger-tip"],b=_.joints["thumb-tip"],M=v.position.distanceTo(b.position),S=.02,L=.005;_.inputState.pinching&&M>S+L?(_.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!_.inputState.pinching&&M<=S-L&&(_.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else g!==null&&t.gripSpace&&(h=e.getPose(t.gripSpace,s),h!==null&&(g.matrix.fromArray(h.transform.matrix),g.matrix.decompose(g.position,g.rotation,g.scale),h.linearVelocity?(g.hasLinearVelocity=!0,g.linearVelocity.copy(h.linearVelocity)):g.hasLinearVelocity=!1,h.angularVelocity?(g.hasAngularVelocity=!0,g.angularVelocity.copy(h.angularVelocity)):g.hasAngularVelocity=!1));return p!==null&&(p.visible=a!==null),g!==null&&(g.visible=h!==null),_!==null&&(_.visible=d!==null),this}}class yw extends Ci{constructor(t,e){super();const s=this,a=t.state;let h=null,d=1,p=null,g="local-floor",_=null,v=null,b=null,M=null,S=null,L=!1,C=null,k=null,T=null,E=null,z=null,I=null;const V=t.extensions.has("EXT_multisampled_render_to_texture");let G=null;const F=[],K=new Map,pt=new on;pt.layers.enable(1),pt.viewport=new ge;const ut=new on;ut.layers.enable(2),ut.viewport=new ge;const X=[pt,ut],ht=new xf;ht.layers.enable(1),ht.layers.enable(2);let it=null,Q=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(xt){let Y=F[xt];return Y===void 0&&(Y=new oc,F[xt]=Y),Y.getTargetRaySpace()},this.getControllerGrip=function(xt){let Y=F[xt];return Y===void 0&&(Y=new oc,F[xt]=Y),Y.getGripSpace()},this.getHand=function(xt){let Y=F[xt];return Y===void 0&&(Y=new oc,F[xt]=Y),Y.getHandSpace()};function rt(xt){const Y=K.get(xt.inputSource);Y&&Y.dispatchEvent({type:xt.type,data:xt.inputSource})}function tt(){K.forEach(function(xt,Y){xt.disconnect(Y)}),K.clear(),it=null,Q=null,a.bindXRFramebuffer(null),t.setRenderTarget(t.getRenderTarget()),b&&e.deleteFramebuffer(b),C&&e.deleteFramebuffer(C),k&&e.deleteRenderbuffer(k),T&&e.deleteRenderbuffer(T),b=null,C=null,k=null,T=null,S=null,M=null,v=null,h=null,re.stop(),s.isPresenting=!1,s.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(xt){d=xt,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(xt){g=xt,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return p},this.getBaseLayer=function(){return M!==null?M:S},this.getBinding=function(){return v},this.getFrame=function(){return E},this.getSession=function(){return h},this.setSession=async function(xt){if(h=xt,h!==null){h.addEventListener("select",rt),h.addEventListener("selectstart",rt),h.addEventListener("selectend",rt),h.addEventListener("squeeze",rt),h.addEventListener("squeezestart",rt),h.addEventListener("squeezeend",rt),h.addEventListener("end",tt),h.addEventListener("inputsourceschange",st);const Y=e.getContextAttributes();if(Y.xrCompatible!==!0&&await e.makeXRCompatible(),h.renderState.layers===void 0){const Xt={antialias:Y.antialias,alpha:Y.alpha,depth:Y.depth,stencil:Y.stencil,framebufferScaleFactor:d};S=new XRWebGLLayer(h,e,Xt),h.updateRenderState({baseLayer:S})}else if(e instanceof WebGLRenderingContext){const Xt={antialias:!0,alpha:Y.alpha,depth:Y.depth,stencil:Y.stencil,framebufferScaleFactor:d};S=new XRWebGLLayer(h,e,Xt),h.updateRenderState({layers:[S]})}else{L=Y.antialias;let Xt=null;Y.depth&&(I=256,Y.stencil&&(I|=1024),z=Y.stencil?33306:36096,Xt=Y.stencil?35056:33190);const It={colorFormat:Y.alpha?32856:32849,depthFormat:Xt,scaleFactor:d};v=new XRWebGLBinding(h,e),M=v.createProjectionLayer(It),b=e.createFramebuffer(),h.updateRenderState({layers:[M]}),L&&V?G=t.extensions.get("EXT_multisampled_render_to_texture"):L&&(C=e.createFramebuffer(),k=e.createRenderbuffer(),e.bindRenderbuffer(36161,k),e.renderbufferStorageMultisample(36161,4,32856,M.textureWidth,M.textureHeight),a.bindFramebuffer(36160,C),e.framebufferRenderbuffer(36160,36064,36161,k),e.bindRenderbuffer(36161,null),Xt!==null&&(T=e.createRenderbuffer(),e.bindRenderbuffer(36161,T),e.renderbufferStorageMultisample(36161,4,Xt,M.textureWidth,M.textureHeight),e.framebufferRenderbuffer(36160,z,36161,T),e.bindRenderbuffer(36161,null)),a.bindFramebuffer(36160,null))}p=await h.requestReferenceSpace(g),re.setContext(h),re.start(),s.isPresenting=!0,s.dispatchEvent({type:"sessionstart"})}};function st(xt){const Y=h.inputSources;for(let Xt=0;Xt<F.length;Xt++)K.set(Y[Xt],F[Xt]);for(let Xt=0;Xt<xt.removed.length;Xt++){const It=xt.removed[Xt],vt=K.get(It);vt&&(vt.dispatchEvent({type:"disconnected",data:It}),K.delete(It))}for(let Xt=0;Xt<xt.added.length;Xt++){const It=xt.added[Xt],vt=K.get(It);vt&&vt.dispatchEvent({type:"connected",data:It})}}const St=new N,Bt=new N;function Wt(xt,Y,Xt){St.setFromMatrixPosition(Y.matrixWorld),Bt.setFromMatrixPosition(Xt.matrixWorld);const It=St.distanceTo(Bt),vt=Y.projectionMatrix.elements,Ft=Xt.projectionMatrix.elements,Jt=vt[14]/(vt[10]-1),ot=vt[14]/(vt[10]+1),dt=(vt[9]+1)/vt[5],_t=(vt[9]-1)/vt[5],Nt=(vt[8]-1)/vt[0],Rt=(Ft[8]+1)/Ft[0],B=Jt*Nt,D=Jt*Rt,et=It/(-Nt+Rt),bt=et*-Nt;Y.matrixWorld.decompose(xt.position,xt.quaternion,xt.scale),xt.translateX(bt),xt.translateZ(et),xt.matrixWorld.compose(xt.position,xt.quaternion,xt.scale),xt.matrixWorldInverse.copy(xt.matrixWorld).invert();const at=Jt+et,gt=ot+et,Et=B-bt,At=D+(It-bt),Vt=dt*ot/gt*at,ft=_t*ot/gt*at;xt.projectionMatrix.makePerspective(Et,At,Vt,ft,at,gt)}function Pt(xt,Y){Y===null?xt.matrixWorld.copy(xt.matrix):xt.matrixWorld.multiplyMatrices(Y.matrixWorld,xt.matrix),xt.matrixWorldInverse.copy(xt.matrixWorld).invert()}this.updateCamera=function(xt){if(h===null)return;ht.near=ut.near=pt.near=xt.near,ht.far=ut.far=pt.far=xt.far,(it!==ht.near||Q!==ht.far)&&(h.updateRenderState({depthNear:ht.near,depthFar:ht.far}),it=ht.near,Q=ht.far);const Y=xt.parent,Xt=ht.cameras;Pt(ht,Y);for(let vt=0;vt<Xt.length;vt++)Pt(Xt[vt],Y);ht.matrixWorld.decompose(ht.position,ht.quaternion,ht.scale),xt.position.copy(ht.position),xt.quaternion.copy(ht.quaternion),xt.scale.copy(ht.scale),xt.matrix.copy(ht.matrix),xt.matrixWorld.copy(ht.matrixWorld);const It=xt.children;for(let vt=0,Ft=It.length;vt<Ft;vt++)It[vt].updateMatrixWorld(!0);Xt.length===2?Wt(ht,pt,ut):ht.projectionMatrix.copy(pt.projectionMatrix)},this.getCamera=function(){return ht},this.getFoveation=function(){if(M!==null)return M.fixedFoveation;if(S!==null)return S.fixedFoveation},this.setFoveation=function(xt){M!==null&&(M.fixedFoveation=xt),S!==null&&S.fixedFoveation!==void 0&&(S.fixedFoveation=xt)};let Zt=null;function ee(xt,Y){if(_=Y.getViewerPose(p),E=Y,_!==null){const It=_.views;S!==null&&a.bindXRFramebuffer(S.framebuffer);let vt=!1;It.length!==ht.cameras.length&&(ht.cameras.length=0,vt=!0);for(let Ft=0;Ft<It.length;Ft++){const Jt=It[Ft];let ot=null;if(S!==null)ot=S.getViewport(Jt);else{const _t=v.getViewSubImage(M,Jt);a.bindXRFramebuffer(b),L&&V?(_t.depthStencilTexture!==void 0&&G.framebufferTexture2DMultisampleEXT(36160,z,3553,_t.depthStencilTexture,0,4),G.framebufferTexture2DMultisampleEXT(36160,36064,3553,_t.colorTexture,0,4)):(_t.depthStencilTexture!==void 0&&e.framebufferTexture2D(36160,z,3553,_t.depthStencilTexture,0),e.framebufferTexture2D(36160,36064,3553,_t.colorTexture,0)),ot=_t.viewport}const dt=X[Ft];dt.matrix.fromArray(Jt.transform.matrix),dt.projectionMatrix.fromArray(Jt.projectionMatrix),dt.viewport.set(ot.x,ot.y,ot.width,ot.height),Ft===0&&ht.matrix.copy(dt.matrix),vt===!0&&ht.cameras.push(dt)}L&&!V&&(a.bindXRFramebuffer(C),I!==null&&e.clear(I))}const Xt=h.inputSources;for(let It=0;It<F.length;It++){const vt=F[It],Ft=Xt[It];vt.update(Ft,Y,p)}if(Zt&&Zt(xt,Y),L&&!V){const It=M.textureWidth,vt=M.textureHeight;a.bindFramebuffer(36008,C),a.bindFramebuffer(36009,b),e.invalidateFramebuffer(36008,[z]),e.invalidateFramebuffer(36009,[z]),e.blitFramebuffer(0,0,It,vt,0,0,It,vt,16384,9728),e.invalidateFramebuffer(36008,[36064]),a.bindFramebuffer(36008,null),a.bindFramebuffer(36009,null),a.bindFramebuffer(36160,C)}E=null}const re=new Fd;re.setAnimationLoop(ee),this.setAnimationLoop=function(xt){Zt=xt},this.dispose=function(){}}}function vw(c){function t(T,E){T.fogColor.value.copy(E.color),E.isFog?(T.fogNear.value=E.near,T.fogFar.value=E.far):E.isFogExp2&&(T.fogDensity.value=E.density)}function e(T,E,z,I,V){E.isMeshBasicMaterial?s(T,E):E.isMeshLambertMaterial?(s(T,E),g(T,E)):E.isMeshToonMaterial?(s(T,E),v(T,E)):E.isMeshPhongMaterial?(s(T,E),_(T,E)):E.isMeshStandardMaterial?(s(T,E),E.isMeshPhysicalMaterial?M(T,E,V):b(T,E)):E.isMeshMatcapMaterial?(s(T,E),S(T,E)):E.isMeshDepthMaterial?(s(T,E),L(T,E)):E.isMeshDistanceMaterial?(s(T,E),C(T,E)):E.isMeshNormalMaterial?(s(T,E),k(T,E)):E.isLineBasicMaterial?(a(T,E),E.isLineDashedMaterial&&h(T,E)):E.isPointsMaterial?d(T,E,z,I):E.isSpriteMaterial?p(T,E):E.isShadowMaterial?(T.color.value.copy(E.color),T.opacity.value=E.opacity):E.isShaderMaterial&&(E.uniformsNeedUpdate=!1)}function s(T,E){T.opacity.value=E.opacity,E.color&&T.diffuse.value.copy(E.color),E.emissive&&T.emissive.value.copy(E.emissive).multiplyScalar(E.emissiveIntensity),E.map&&(T.map.value=E.map),E.alphaMap&&(T.alphaMap.value=E.alphaMap),E.specularMap&&(T.specularMap.value=E.specularMap),E.alphaTest>0&&(T.alphaTest.value=E.alphaTest);const z=c.get(E).envMap;if(z){T.envMap.value=z,T.flipEnvMap.value=z.isCubeTexture&&z.isRenderTargetTexture===!1?-1:1,T.reflectivity.value=E.reflectivity,T.ior.value=E.ior,T.refractionRatio.value=E.refractionRatio;const G=c.get(z).__maxMipLevel;G!==void 0&&(T.maxMipLevel.value=G)}E.lightMap&&(T.lightMap.value=E.lightMap,T.lightMapIntensity.value=E.lightMapIntensity),E.aoMap&&(T.aoMap.value=E.aoMap,T.aoMapIntensity.value=E.aoMapIntensity);let I;E.map?I=E.map:E.specularMap?I=E.specularMap:E.displacementMap?I=E.displacementMap:E.normalMap?I=E.normalMap:E.bumpMap?I=E.bumpMap:E.roughnessMap?I=E.roughnessMap:E.metalnessMap?I=E.metalnessMap:E.alphaMap?I=E.alphaMap:E.emissiveMap?I=E.emissiveMap:E.clearcoatMap?I=E.clearcoatMap:E.clearcoatNormalMap?I=E.clearcoatNormalMap:E.clearcoatRoughnessMap?I=E.clearcoatRoughnessMap:E.specularIntensityMap?I=E.specularIntensityMap:E.specularTintMap?I=E.specularTintMap:E.transmissionMap?I=E.transmissionMap:E.thicknessMap&&(I=E.thicknessMap),I!==void 0&&(I.isWebGLRenderTarget&&(I=I.texture),I.matrixAutoUpdate===!0&&I.updateMatrix(),T.uvTransform.value.copy(I.matrix));let V;E.aoMap?V=E.aoMap:E.lightMap&&(V=E.lightMap),V!==void 0&&(V.isWebGLRenderTarget&&(V=V.texture),V.matrixAutoUpdate===!0&&V.updateMatrix(),T.uv2Transform.value.copy(V.matrix))}function a(T,E){T.diffuse.value.copy(E.color),T.opacity.value=E.opacity}function h(T,E){T.dashSize.value=E.dashSize,T.totalSize.value=E.dashSize+E.gapSize,T.scale.value=E.scale}function d(T,E,z,I){T.diffuse.value.copy(E.color),T.opacity.value=E.opacity,T.size.value=E.size*z,T.scale.value=I*.5,E.map&&(T.map.value=E.map),E.alphaMap&&(T.alphaMap.value=E.alphaMap),E.alphaTest>0&&(T.alphaTest.value=E.alphaTest);let V;E.map?V=E.map:E.alphaMap&&(V=E.alphaMap),V!==void 0&&(V.matrixAutoUpdate===!0&&V.updateMatrix(),T.uvTransform.value.copy(V.matrix))}function p(T,E){T.diffuse.value.copy(E.color),T.opacity.value=E.opacity,T.rotation.value=E.rotation,E.map&&(T.map.value=E.map),E.alphaMap&&(T.alphaMap.value=E.alphaMap),E.alphaTest>0&&(T.alphaTest.value=E.alphaTest);let z;E.map?z=E.map:E.alphaMap&&(z=E.alphaMap),z!==void 0&&(z.matrixAutoUpdate===!0&&z.updateMatrix(),T.uvTransform.value.copy(z.matrix))}function g(T,E){E.emissiveMap&&(T.emissiveMap.value=E.emissiveMap)}function _(T,E){T.specular.value.copy(E.specular),T.shininess.value=Math.max(E.shininess,1e-4),E.emissiveMap&&(T.emissiveMap.value=E.emissiveMap),E.bumpMap&&(T.bumpMap.value=E.bumpMap,T.bumpScale.value=E.bumpScale,E.side===ke&&(T.bumpScale.value*=-1)),E.normalMap&&(T.normalMap.value=E.normalMap,T.normalScale.value.copy(E.normalScale),E.side===ke&&T.normalScale.value.negate()),E.displacementMap&&(T.displacementMap.value=E.displacementMap,T.displacementScale.value=E.displacementScale,T.displacementBias.value=E.displacementBias)}function v(T,E){E.gradientMap&&(T.gradientMap.value=E.gradientMap),E.emissiveMap&&(T.emissiveMap.value=E.emissiveMap),E.bumpMap&&(T.bumpMap.value=E.bumpMap,T.bumpScale.value=E.bumpScale,E.side===ke&&(T.bumpScale.value*=-1)),E.normalMap&&(T.normalMap.value=E.normalMap,T.normalScale.value.copy(E.normalScale),E.side===ke&&T.normalScale.value.negate()),E.displacementMap&&(T.displacementMap.value=E.displacementMap,T.displacementScale.value=E.displacementScale,T.displacementBias.value=E.displacementBias)}function b(T,E){T.roughness.value=E.roughness,T.metalness.value=E.metalness,E.roughnessMap&&(T.roughnessMap.value=E.roughnessMap),E.metalnessMap&&(T.metalnessMap.value=E.metalnessMap),E.emissiveMap&&(T.emissiveMap.value=E.emissiveMap),E.bumpMap&&(T.bumpMap.value=E.bumpMap,T.bumpScale.value=E.bumpScale,E.side===ke&&(T.bumpScale.value*=-1)),E.normalMap&&(T.normalMap.value=E.normalMap,T.normalScale.value.copy(E.normalScale),E.side===ke&&T.normalScale.value.negate()),E.displacementMap&&(T.displacementMap.value=E.displacementMap,T.displacementScale.value=E.displacementScale,T.displacementBias.value=E.displacementBias),c.get(E).envMap&&(T.envMapIntensity.value=E.envMapIntensity)}function M(T,E,z){b(T,E),T.ior.value=E.ior,E.sheen>0&&(T.sheenTint.value.copy(E.sheenTint).multiplyScalar(E.sheen),T.sheenRoughness.value=E.sheenRoughness),E.clearcoat>0&&(T.clearcoat.value=E.clearcoat,T.clearcoatRoughness.value=E.clearcoatRoughness,E.clearcoatMap&&(T.clearcoatMap.value=E.clearcoatMap),E.clearcoatRoughnessMap&&(T.clearcoatRoughnessMap.value=E.clearcoatRoughnessMap),E.clearcoatNormalMap&&(T.clearcoatNormalScale.value.copy(E.clearcoatNormalScale),T.clearcoatNormalMap.value=E.clearcoatNormalMap,E.side===ke&&T.clearcoatNormalScale.value.negate())),E.transmission>0&&(T.transmission.value=E.transmission,T.transmissionSamplerMap.value=z.texture,T.transmissionSamplerSize.value.set(z.width,z.height),E.transmissionMap&&(T.transmissionMap.value=E.transmissionMap),T.thickness.value=E.thickness,E.thicknessMap&&(T.thicknessMap.value=E.thicknessMap),T.attenuationDistance.value=E.attenuationDistance,T.attenuationTint.value.copy(E.attenuationTint)),T.specularIntensity.value=E.specularIntensity,T.specularTint.value.copy(E.specularTint),E.specularIntensityMap&&(T.specularIntensityMap.value=E.specularIntensityMap),E.specularTintMap&&(T.specularTintMap.value=E.specularTintMap)}function S(T,E){E.matcap&&(T.matcap.value=E.matcap),E.bumpMap&&(T.bumpMap.value=E.bumpMap,T.bumpScale.value=E.bumpScale,E.side===ke&&(T.bumpScale.value*=-1)),E.normalMap&&(T.normalMap.value=E.normalMap,T.normalScale.value.copy(E.normalScale),E.side===ke&&T.normalScale.value.negate()),E.displacementMap&&(T.displacementMap.value=E.displacementMap,T.displacementScale.value=E.displacementScale,T.displacementBias.value=E.displacementBias)}function L(T,E){E.displacementMap&&(T.displacementMap.value=E.displacementMap,T.displacementScale.value=E.displacementScale,T.displacementBias.value=E.displacementBias)}function C(T,E){E.displacementMap&&(T.displacementMap.value=E.displacementMap,T.displacementScale.value=E.displacementScale,T.displacementBias.value=E.displacementBias),T.referencePosition.value.copy(E.referencePosition),T.nearDistance.value=E.nearDistance,T.farDistance.value=E.farDistance}function k(T,E){E.bumpMap&&(T.bumpMap.value=E.bumpMap,T.bumpScale.value=E.bumpScale,E.side===ke&&(T.bumpScale.value*=-1)),E.normalMap&&(T.normalMap.value=E.normalMap,T.normalScale.value.copy(E.normalScale),E.side===ke&&T.normalScale.value.negate()),E.displacementMap&&(T.displacementMap.value=E.displacementMap,T.displacementScale.value=E.displacementScale,T.displacementBias.value=E.displacementBias)}return{refreshFogUniforms:t,refreshMaterialUniforms:e}}function bw(){const c=Ao("canvas");return c.style.display="block",c}function xe(c={}){const t=c.canvas!==void 0?c.canvas:bw(),e=c.context!==void 0?c.context:null,s=c.alpha!==void 0?c.alpha:!1,a=c.depth!==void 0?c.depth:!0,h=c.stencil!==void 0?c.stencil:!0,d=c.antialias!==void 0?c.antialias:!1,p=c.premultipliedAlpha!==void 0?c.premultipliedAlpha:!0,g=c.preserveDrawingBuffer!==void 0?c.preserveDrawingBuffer:!1,_=c.powerPreference!==void 0?c.powerPreference:"default",v=c.failIfMajorPerformanceCaveat!==void 0?c.failIfMajorPerformanceCaveat:!1;let b=null,M=null;const S=[],L=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=qe,this.physicallyCorrectLights=!1,this.toneMapping=Ai,this.toneMappingExposure=1;const C=this;let k=!1,T=0,E=0,z=null,I=-1,V=null;const G=new ge,F=new ge;let K=null,pt=t.width,ut=t.height,X=1,ht=null,it=null;const Q=new ge(0,0,pt,ut),rt=new ge(0,0,pt,ut);let tt=!1;const st=[],St=new jo;let Bt=!1,Wt=!1,Pt=null;const Zt=new jt,ee=new N,re={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function xt(){return z===null?X:1}let Y=e;function Xt(P,$){for(let j=0;j<P.length;j++){const J=P[j],lt=t.getContext(J,$);if(lt!==null)return lt}return null}try{const P={alpha:s,depth:a,stencil:h,antialias:d,premultipliedAlpha:p,preserveDrawingBuffer:g,powerPreference:_,failIfMajorPerformanceCaveat:v};if(t.addEventListener("webglcontextlost",De,!1),t.addEventListener("webglcontextrestored",Ie,!1),Y===null){const $=["webgl2","webgl","experimental-webgl"];if(C.isWebGL1Renderer===!0&&$.shift(),Y=Xt($,P),Y===null)throw Xt($)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}Y.getShaderPrecisionFormat===void 0&&(Y.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(P){throw console.error("THREE.WebGLRenderer: "+P.message),P}let It,vt,Ft,Jt,ot,dt,_t,Nt,Rt,B,D,et,bt,at,gt,Et,At,Vt,ft,W,Lt,nt,mt;function kt(){It=new Gb(Y),vt=new Ob(Y,It,c),It.init(vt),nt=new xw(Y,It,vt),Ft=new mw(Y,It,vt),st[0]=1029,Jt=new qb(Y),ot=new sw,dt=new gw(Y,It,Ft,ot,vt,nt,Jt),_t=new zb(C),Nt=new Wb(C),Rt=new oy(Y,vt),mt=new Fb(Y,It,Rt,vt),B=new Xb(Y,Rt,Jt,mt),D=new Jb(Y,B,Rt,Jt),ft=new Zb(Y,vt,dt),Et=new Bb(ot),et=new iw(C,_t,Nt,It,vt,mt,Et),bt=new vw(ot),at=new ow(ot),gt=new dw(It,vt),Vt=new Ib(C,_t,Ft,D,p),At=new gf(C,D,vt),W=new kb(Y,It,Jt,vt),Lt=new jb(Y,It,Jt,vt),Jt.programs=et.programs,C.capabilities=vt,C.extensions=It,C.properties=ot,C.renderLists=at,C.shadowMap=At,C.state=Ft,C.info=Jt}kt();const Qt=new yw(C,Y);this.xr=Qt,this.getContext=function(){return Y},this.getContextAttributes=function(){return Y.getContextAttributes()},this.forceContextLoss=function(){const P=It.get("WEBGL_lose_context");P&&P.loseContext()},this.forceContextRestore=function(){const P=It.get("WEBGL_lose_context");P&&P.restoreContext()},this.getPixelRatio=function(){return X},this.setPixelRatio=function(P){P!==void 0&&(X=P,this.setSize(pt,ut,!1))},this.getSize=function(P){return P.set(pt,ut)},this.setSize=function(P,$,j){if(Qt.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}pt=P,ut=$,t.width=Math.floor(P*X),t.height=Math.floor($*X),j!==!1&&(t.style.width=P+"px",t.style.height=$+"px"),this.setViewport(0,0,P,$)},this.getDrawingBufferSize=function(P){return P.set(pt*X,ut*X).floor()},this.setDrawingBufferSize=function(P,$,j){pt=P,ut=$,X=j,t.width=Math.floor(P*j),t.height=Math.floor($*j),this.setViewport(0,0,P,$)},this.getCurrentViewport=function(P){return P.copy(G)},this.getViewport=function(P){return P.copy(Q)},this.setViewport=function(P,$,j,J){P.isVector4?Q.set(P.x,P.y,P.z,P.w):Q.set(P,$,j,J),Ft.viewport(G.copy(Q).multiplyScalar(X).floor())},this.getScissor=function(P){return P.copy(rt)},this.setScissor=function(P,$,j,J){P.isVector4?rt.set(P.x,P.y,P.z,P.w):rt.set(P,$,j,J),Ft.scissor(F.copy(rt).multiplyScalar(X).floor())},this.getScissorTest=function(){return tt},this.setScissorTest=function(P){Ft.setScissorTest(tt=P)},this.setOpaqueSort=function(P){ht=P},this.setTransparentSort=function(P){it=P},this.getClearColor=function(P){return P.copy(Vt.getClearColor())},this.setClearColor=function(){Vt.setClearColor.apply(Vt,arguments)},this.getClearAlpha=function(){return Vt.getClearAlpha()},this.setClearAlpha=function(){Vt.setClearAlpha.apply(Vt,arguments)},this.clear=function(P,$,j){let J=0;(P===void 0||P)&&(J|=16384),($===void 0||$)&&(J|=256),(j===void 0||j)&&(J|=1024),Y.clear(J)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",De,!1),t.removeEventListener("webglcontextrestored",Ie,!1),at.dispose(),gt.dispose(),ot.dispose(),_t.dispose(),Nt.dispose(),D.dispose(),mt.dispose(),Qt.dispose(),Qt.removeEventListener("sessionstart",Rs),Qt.removeEventListener("sessionend",fn),Pt&&(Pt.dispose(),Pt=null),pn.stop()};function De(P){P.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),k=!0}function Ie(){console.log("THREE.WebGLRenderer: Context Restored."),k=!1;const P=Jt.autoReset,$=At.enabled,j=At.autoUpdate,J=At.needsUpdate,lt=At.type;kt(),Jt.autoReset=P,At.enabled=$,At.autoUpdate=j,At.needsUpdate=J,At.type=lt}function Je(P){const $=P.target;$.removeEventListener("dispose",Je),me($)}function me(P){dn(P),ot.remove(P)}function dn(P){const $=ot.get(P).programs;$!==void 0&&$.forEach(function(j){et.releaseProgram(j)})}function vn(P,$){P.render(function(j){C.renderBufferImmediate(j,$)})}this.renderBufferImmediate=function(P,$){mt.initAttributes();const j=ot.get(P);P.hasPositions&&!j.position&&(j.position=Y.createBuffer()),P.hasNormals&&!j.normal&&(j.normal=Y.createBuffer()),P.hasUvs&&!j.uv&&(j.uv=Y.createBuffer()),P.hasColors&&!j.color&&(j.color=Y.createBuffer());const J=$.getAttributes();P.hasPositions&&(Y.bindBuffer(34962,j.position),Y.bufferData(34962,P.positionArray,35048),mt.enableAttribute(J.position.location),Y.vertexAttribPointer(J.position.location,3,5126,!1,0,0)),P.hasNormals&&(Y.bindBuffer(34962,j.normal),Y.bufferData(34962,P.normalArray,35048),mt.enableAttribute(J.normal.location),Y.vertexAttribPointer(J.normal.location,3,5126,!1,0,0)),P.hasUvs&&(Y.bindBuffer(34962,j.uv),Y.bufferData(34962,P.uvArray,35048),mt.enableAttribute(J.uv.location),Y.vertexAttribPointer(J.uv.location,2,5126,!1,0,0)),P.hasColors&&(Y.bindBuffer(34962,j.color),Y.bufferData(34962,P.colorArray,35048),mt.enableAttribute(J.color.location),Y.vertexAttribPointer(J.color.location,3,5126,!1,0,0)),mt.disableUnusedAttributes(),Y.drawArrays(4,0,P.count),P.count=0},this.renderBufferDirect=function(P,$,j,J,lt,qt){$===null&&($=re);const Gt=lt.isMesh&&lt.matrixWorld.determinant()<0,Ot=Ir(P,$,J,lt);Ft.setMaterial(J,Gt);let Yt=j.index;const ce=j.attributes.position;if(Yt===null){if(ce===void 0||ce.count===0)return}else if(Yt.count===0)return;let ne=1;J.wireframe===!0&&(Yt=B.getWireframeAttribute(j),ne=2),(j.morphAttributes.position!==void 0||j.morphAttributes.normal!==void 0)&&ft.update(lt,j,J,Ot),mt.setup(lt,J,Ot,j,Yt);let te,fe=W;Yt!==null&&(te=Rt.get(Yt),fe=Lt,fe.setIndex(te));const oe=Yt!==null?Yt.count:ce.count,Ln=j.drawRange.start*ne,ue=j.drawRange.count*ne,ze=qt!==null?qt.start*ne:0,qn=qt!==null?qt.count*ne:1/0,an=Math.max(Ln,ze),Cn=Math.min(oe,Ln+ue,ze+qn)-1,be=Math.max(0,Cn-an+1);if(be!==0){if(lt.isMesh)J.wireframe===!0?(Ft.setLineWidth(J.wireframeLinewidth*xt()),fe.setMode(1)):fe.setMode(4);else if(lt.isLine){let Me=J.linewidth;Me===void 0&&(Me=1),Ft.setLineWidth(Me*xt()),lt.isLineSegments?fe.setMode(1):lt.isLineLoop?fe.setMode(2):fe.setMode(3)}else lt.isPoints?fe.setMode(0):lt.isSprite&&fe.setMode(4);if(lt.isInstancedMesh)fe.renderInstances(an,be,lt.count);else if(j.isInstancedBufferGeometry){const Me=Math.min(j.instanceCount,j._maxInstanceCount);fe.renderInstances(an,be,Me)}else fe.render(an,be)}},this.compile=function(P,$){M=gt.get(P),M.init(),L.push(M),P.traverseVisible(function(j){j.isLight&&j.layers.test($.layers)&&(M.pushLight(j),j.castShadow&&M.pushShadow(j))}),M.setupLights(C.physicallyCorrectLights),P.traverse(function(j){const J=j.material;if(J)if(Array.isArray(J))for(let lt=0;lt<J.length;lt++){const qt=J[lt];Nn(qt,P,j)}else Nn(J,P,j)}),L.pop(),M=null};let Cs=null;function fa(P){Cs&&Cs(P)}function Rs(){pn.stop()}function fn(){pn.start()}const pn=new Fd;pn.setAnimationLoop(fa),typeof window!="undefined"&&pn.setContext(window),this.setAnimationLoop=function(P){Cs=P,Qt.setAnimationLoop(P),P===null?pn.stop():pn.start()},Qt.addEventListener("sessionstart",Rs),Qt.addEventListener("sessionend",fn),this.render=function(P,$){if($!==void 0&&$.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(k===!0)return;P.autoUpdate===!0&&P.updateMatrixWorld(),$.parent===null&&$.updateMatrixWorld(),Qt.enabled===!0&&Qt.isPresenting===!0&&(Qt.cameraAutoUpdate===!0&&Qt.updateCamera($),$=Qt.getCamera()),P.isScene===!0&&P.onBeforeRender(C,P,$,z),M=gt.get(P,L.length),M.init(),L.push(M),Zt.multiplyMatrices($.projectionMatrix,$.matrixWorldInverse),St.setFromProjectionMatrix(Zt),Wt=this.localClippingEnabled,Bt=Et.init(this.clippingPlanes,Wt,$),b=at.get(P,S.length),b.init(),S.push(b),Be(P,$,0,C.sortObjects),b.finish(),C.sortObjects===!0&&b.sort(ht,it),Bt===!0&&Et.beginShadows();const j=M.state.shadowsArray;if(At.render(j,P,$),Bt===!0&&Et.endShadows(),this.info.autoReset===!0&&this.info.reset(),Vt.render(b,P),M.setupLights(C.physicallyCorrectLights),$.isArrayCamera){const J=$.cameras;for(let lt=0,qt=J.length;lt<qt;lt++){const Gt=J[lt];An(b,P,Gt,Gt.viewport)}}else An(b,P,$);z!==null&&(dt.updateMultisampleRenderTarget(z),dt.updateRenderTargetMipmap(z)),P.isScene===!0&&P.onAfterRender(C,P,$),Ft.buffers.depth.setTest(!0),Ft.buffers.depth.setMask(!0),Ft.buffers.color.setMask(!0),Ft.setPolygonOffset(!1),mt.resetDefaultState(),I=-1,V=null,L.pop(),L.length>0?M=L[L.length-1]:M=null,S.pop(),S.length>0?b=S[S.length-1]:b=null};function Be(P,$,j,J){if(P.visible===!1)return;if(P.layers.test($.layers)){if(P.isGroup)j=P.renderOrder;else if(P.isLOD)P.autoUpdate===!0&&P.update($);else if(P.isLight)M.pushLight(P),P.castShadow&&M.pushShadow(P);else if(P.isSprite){if(!P.frustumCulled||St.intersectsSprite(P)){J&&ee.setFromMatrixPosition(P.matrixWorld).applyMatrix4(Zt);const Gt=D.update(P),Ot=P.material;Ot.visible&&b.push(P,Gt,Ot,j,ee.z,null)}}else if(P.isImmediateRenderObject)J&&ee.setFromMatrixPosition(P.matrixWorld).applyMatrix4(Zt),b.push(P,null,P.material,j,ee.z,null);else if((P.isMesh||P.isLine||P.isPoints)&&(P.isSkinnedMesh&&P.skeleton.frame!==Jt.render.frame&&(P.skeleton.update(),P.skeleton.frame=Jt.render.frame),!P.frustumCulled||St.intersectsObject(P))){J&&ee.setFromMatrixPosition(P.matrixWorld).applyMatrix4(Zt);const Gt=D.update(P),Ot=P.material;if(Array.isArray(Ot)){const Yt=Gt.groups;for(let ce=0,ne=Yt.length;ce<ne;ce++){const te=Yt[ce],fe=Ot[te.materialIndex];fe&&fe.visible&&b.push(P,Gt,fe,j,ee.z,te)}}else Ot.visible&&b.push(P,Gt,Ot,j,ee.z,null)}}const qt=P.children;for(let Gt=0,Ot=qt.length;Gt<Ot;Gt++)Be(qt[Gt],$,j,J)}function An(P,$,j,J){const lt=P.opaque,qt=P.transmissive,Gt=P.transparent;M.setupLightsView(j),qt.length>0&&Dr(lt,$,j),J&&Ft.viewport(G.copy(J)),lt.length>0&&mn(lt,$,j),qt.length>0&&mn(qt,$,j),Gt.length>0&&mn(Gt,$,j)}function Dr(P,$,j){if(Pt===null){const Gt=d===!0&&vt.isWebGL2===!0?_d:Fn;Pt=new Gt(1024,1024,{generateMipmaps:!0,type:nt.convert(Xi)!==null?Xi:ii,minFilter:vo,magFilter:Ne,wrapS:ln,wrapT:ln})}const J=C.getRenderTarget();C.setRenderTarget(Pt),C.clear();const lt=C.toneMapping;C.toneMapping=Ai,mn(P,$,j),C.toneMapping=lt,dt.updateMultisampleRenderTarget(Pt),dt.updateRenderTargetMipmap(Pt),C.setRenderTarget(J)}function mn(P,$,j){const J=$.isScene===!0?$.overrideMaterial:null;for(let lt=0,qt=P.length;lt<qt;lt++){const Gt=P[lt],Ot=Gt.object,Yt=Gt.geometry,ce=J===null?Gt.material:J,ne=Gt.group;Ot.layers.test(j.layers)&&Ps(Ot,$,j,Yt,ce,ne)}}function Ps(P,$,j,J,lt,qt){if(P.onBeforeRender(C,$,j,J,lt,qt),P.modelViewMatrix.multiplyMatrices(j.matrixWorldInverse,P.matrixWorld),P.normalMatrix.getNormalMatrix(P.modelViewMatrix),lt.onBeforeRender(C,$,j,J,P,qt),P.isImmediateRenderObject){const Gt=Ir(j,$,lt,P);Ft.setMaterial(lt),mt.reset(),vn(P,Gt)}else lt.transparent===!0&&lt.side===Wi?(lt.side=ke,lt.needsUpdate=!0,C.renderBufferDirect(j,$,J,lt,P,qt),lt.side=sr,lt.needsUpdate=!0,C.renderBufferDirect(j,$,J,lt,P,qt),lt.side=Wi):C.renderBufferDirect(j,$,J,lt,P,qt);P.onAfterRender(C,$,j,J,lt,qt)}function Nn(P,$,j){$.isScene!==!0&&($=re);const J=ot.get(P),lt=M.state.lights,qt=M.state.shadowsArray,Gt=lt.state.version,Ot=et.getParameters(P,lt.state,qt,$,j),Yt=et.getProgramCacheKey(Ot);let ce=J.programs;J.environment=P.isMeshStandardMaterial?$.environment:null,J.fog=$.fog,J.envMap=(P.isMeshStandardMaterial?Nt:_t).get(P.envMap||J.environment),ce===void 0&&(P.addEventListener("dispose",Je),ce=new Map,J.programs=ce);let ne=ce.get(Yt);if(ne!==void 0){if(J.currentProgram===ne&&J.lightsStateVersion===Gt)return Fi(P,Ot),ne}else Ot.uniforms=et.getUniforms(P),P.onBuild(Ot,C),P.onBeforeCompile(Ot,C),ne=et.acquireProgram(Ot,Yt),ce.set(Yt,ne),J.uniforms=Ot.uniforms;const te=J.uniforms;(!P.isShaderMaterial&&!P.isRawShaderMaterial||P.clipping===!0)&&(te.clippingPlanes=Et.uniform),Fi(P,Ot),J.needsLights=ye(P),J.lightsStateVersion=Gt,J.needsLights&&(te.ambientLightColor.value=lt.state.ambient,te.lightProbe.value=lt.state.probe,te.directionalLights.value=lt.state.directional,te.directionalLightShadows.value=lt.state.directionalShadow,te.spotLights.value=lt.state.spot,te.spotLightShadows.value=lt.state.spotShadow,te.rectAreaLights.value=lt.state.rectArea,te.ltc_1.value=lt.state.rectAreaLTC1,te.ltc_2.value=lt.state.rectAreaLTC2,te.pointLights.value=lt.state.point,te.pointLightShadows.value=lt.state.pointShadow,te.hemisphereLights.value=lt.state.hemi,te.directionalShadowMap.value=lt.state.directionalShadowMap,te.directionalShadowMatrix.value=lt.state.directionalShadowMatrix,te.spotShadowMap.value=lt.state.spotShadowMap,te.spotShadowMatrix.value=lt.state.spotShadowMatrix,te.pointShadowMap.value=lt.state.pointShadowMap,te.pointShadowMatrix.value=lt.state.pointShadowMatrix);const fe=ne.getUniforms(),oe=pi.seqWithValue(fe.seq,te);return J.currentProgram=ne,J.uniformsList=oe,ne}function Fi(P,$){const j=ot.get(P);j.outputEncoding=$.outputEncoding,j.instancing=$.instancing,j.skinning=$.skinning,j.morphTargets=$.morphTargets,j.morphNormals=$.morphNormals,j.morphTargetsCount=$.morphTargetsCount,j.numClippingPlanes=$.numClippingPlanes,j.numIntersection=$.numClipIntersection,j.vertexAlphas=$.vertexAlphas,j.vertexTangents=$.vertexTangents}function Ir(P,$,j,J){$.isScene!==!0&&($=re),dt.resetTextureUnits();const lt=$.fog,qt=j.isMeshStandardMaterial?$.environment:null,Gt=z===null?C.outputEncoding:z.texture.encoding,Ot=(j.isMeshStandardMaterial?Nt:_t).get(j.envMap||qt),Yt=j.vertexColors===!0&&!!J.geometry&&!!J.geometry.attributes.color&&J.geometry.attributes.color.itemSize===4,ce=!!j.normalMap&&!!J.geometry&&!!J.geometry.attributes.tangent,ne=!!J.geometry&&!!J.geometry.morphAttributes.position,te=!!J.geometry&&!!J.geometry.morphAttributes.normal,fe=!!J.geometry&&!!J.geometry.morphAttributes.position?J.geometry.morphAttributes.position.length:0,oe=ot.get(j),Ln=M.state.lights;if(Bt===!0&&(Wt===!0||P!==V)){const Ue=P===V&&j.id===I;Et.setState(j,P,Ue)}let ue=!1;j.version===oe.__version?(oe.needsLights&&oe.lightsStateVersion!==Ln.state.version||oe.outputEncoding!==Gt||J.isInstancedMesh&&oe.instancing===!1||!J.isInstancedMesh&&oe.instancing===!0||J.isSkinnedMesh&&oe.skinning===!1||!J.isSkinnedMesh&&oe.skinning===!0||oe.envMap!==Ot||j.fog&&oe.fog!==lt||oe.numClippingPlanes!==void 0&&(oe.numClippingPlanes!==Et.numPlanes||oe.numIntersection!==Et.numIntersection)||oe.vertexAlphas!==Yt||oe.vertexTangents!==ce||oe.morphTargets!==ne||oe.morphNormals!==te||vt.isWebGL2===!0&&oe.morphTargetsCount!==fe)&&(ue=!0):(ue=!0,oe.__version=j.version);let ze=oe.currentProgram;ue===!0&&(ze=Nn(j,$,J));let qn=!1,an=!1,Cn=!1;const be=ze.getUniforms(),Me=oe.uniforms;if(Ft.useProgram(ze.program)&&(qn=!0,an=!0,Cn=!0),j.id!==I&&(I=j.id,an=!0),qn||V!==P){if(be.setValue(Y,"projectionMatrix",P.projectionMatrix),vt.logarithmicDepthBuffer&&be.setValue(Y,"logDepthBufFC",2/(Math.log(P.far+1)/Math.LN2)),V!==P&&(V=P,an=!0,Cn=!0),j.isShaderMaterial||j.isMeshPhongMaterial||j.isMeshToonMaterial||j.isMeshStandardMaterial||j.envMap){const Ue=be.map.cameraPosition;Ue!==void 0&&Ue.setValue(Y,ee.setFromMatrixPosition(P.matrixWorld))}(j.isMeshPhongMaterial||j.isMeshToonMaterial||j.isMeshLambertMaterial||j.isMeshBasicMaterial||j.isMeshStandardMaterial||j.isShaderMaterial)&&be.setValue(Y,"isOrthographic",P.isOrthographicCamera===!0),(j.isMeshPhongMaterial||j.isMeshToonMaterial||j.isMeshLambertMaterial||j.isMeshBasicMaterial||j.isMeshStandardMaterial||j.isShaderMaterial||j.isShadowMaterial||J.isSkinnedMesh)&&be.setValue(Y,"viewMatrix",P.matrixWorldInverse)}if(J.isSkinnedMesh){be.setOptional(Y,J,"bindMatrix"),be.setOptional(Y,J,"bindMatrixInverse");const Ue=J.skeleton;Ue&&(vt.floatVertexTextures?(Ue.boneTexture===null&&Ue.computeBoneTexture(),be.setValue(Y,"boneTexture",Ue.boneTexture,dt),be.setValue(Y,"boneTextureSize",Ue.boneTextureSize)):be.setOptional(Y,Ue,"boneMatrices"))}return(an||oe.receiveShadow!==J.receiveShadow)&&(oe.receiveShadow=J.receiveShadow,be.setValue(Y,"receiveShadow",J.receiveShadow)),an&&(be.setValue(Y,"toneMappingExposure",C.toneMappingExposure),oe.needsLights&&ie(Me,Cn),lt&&j.fog&&bt.refreshFogUniforms(Me,lt),bt.refreshMaterialUniforms(Me,j,X,ut,Pt),pi.upload(Y,oe.uniformsList,Me,dt)),j.isShaderMaterial&&j.uniformsNeedUpdate===!0&&(pi.upload(Y,oe.uniformsList,Me,dt),j.uniformsNeedUpdate=!1),j.isSpriteMaterial&&be.setValue(Y,"center",J.center),be.setValue(Y,"modelViewMatrix",J.modelViewMatrix),be.setValue(Y,"normalMatrix",J.normalMatrix),be.setValue(Y,"modelMatrix",J.matrixWorld),ze}function ie(P,$){P.ambientLightColor.needsUpdate=$,P.lightProbe.needsUpdate=$,P.directionalLights.needsUpdate=$,P.directionalLightShadows.needsUpdate=$,P.pointLights.needsUpdate=$,P.pointLightShadows.needsUpdate=$,P.spotLights.needsUpdate=$,P.spotLightShadows.needsUpdate=$,P.rectAreaLights.needsUpdate=$,P.hemisphereLights.needsUpdate=$}function ye(P){return P.isMeshLambertMaterial||P.isMeshToonMaterial||P.isMeshPhongMaterial||P.isMeshStandardMaterial||P.isShadowMaterial||P.isShaderMaterial&&P.lights===!0}this.getActiveCubeFace=function(){return T},this.getActiveMipmapLevel=function(){return E},this.getRenderTarget=function(){return z},this.setRenderTarget=function(P,$=0,j=0){z=P,T=$,E=j,P&&ot.get(P).__webglFramebuffer===void 0&&dt.setupRenderTarget(P);let J=null,lt=!1,qt=!1;if(P){const Ot=P.texture;(Ot.isDataTexture3D||Ot.isDataTexture2DArray)&&(qt=!0);const Yt=ot.get(P).__webglFramebuffer;P.isWebGLCubeRenderTarget?(J=Yt[$],lt=!0):P.isWebGLMultisampleRenderTarget?J=ot.get(P).__webglMultisampledFramebuffer:J=Yt,G.copy(P.viewport),F.copy(P.scissor),K=P.scissorTest}else G.copy(Q).multiplyScalar(X).floor(),F.copy(rt).multiplyScalar(X).floor(),K=tt;if(Ft.bindFramebuffer(36160,J)&&vt.drawBuffers){let Ot=!1;if(P)if(P.isWebGLMultipleRenderTargets){const Yt=P.texture;if(st.length!==Yt.length||st[0]!==36064){for(let ce=0,ne=Yt.length;ce<ne;ce++)st[ce]=36064+ce;st.length=Yt.length,Ot=!0}}else(st.length!==1||st[0]!==36064)&&(st[0]=36064,st.length=1,Ot=!0);else(st.length!==1||st[0]!==1029)&&(st[0]=1029,st.length=1,Ot=!0);Ot&&(vt.isWebGL2?Y.drawBuffers(st):It.get("WEBGL_draw_buffers").drawBuffersWEBGL(st))}if(Ft.viewport(G),Ft.scissor(F),Ft.setScissorTest(K),lt){const Ot=ot.get(P.texture);Y.framebufferTexture2D(36160,36064,34069+$,Ot.__webglTexture,j)}else if(qt){const Ot=ot.get(P.texture),Yt=$||0;Y.framebufferTextureLayer(36160,36064,Ot.__webglTexture,j||0,Yt)}I=-1},this.readRenderTargetPixels=function(P,$,j,J,lt,qt,Gt){if(!(P&&P.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Ot=ot.get(P).__webglFramebuffer;if(P.isWebGLCubeRenderTarget&&Gt!==void 0&&(Ot=Ot[Gt]),Ot){Ft.bindFramebuffer(36160,Ot);try{const Yt=P.texture,ce=Yt.format,ne=Yt.type;if(ce!==tn&&nt.convert(ce)!==Y.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const te=ne===Xi&&(It.has("EXT_color_buffer_half_float")||vt.isWebGL2&&It.has("EXT_color_buffer_float"));if(ne!==ii&&nt.convert(ne)!==Y.getParameter(35738)&&!(ne===si&&(vt.isWebGL2||It.has("OES_texture_float")||It.has("WEBGL_color_buffer_float")))&&!te){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}Y.checkFramebufferStatus(36160)===36053?$>=0&&$<=P.width-J&&j>=0&&j<=P.height-lt&&Y.readPixels($,j,J,lt,nt.convert(ce),nt.convert(ne),qt):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const Yt=z!==null?ot.get(z).__webglFramebuffer:null;Ft.bindFramebuffer(36160,Yt)}}},this.copyFramebufferToTexture=function(P,$,j=0){const J=Math.pow(2,-j),lt=Math.floor($.image.width*J),qt=Math.floor($.image.height*J);let Gt=nt.convert($.format);vt.isWebGL2&&(Gt===6407&&(Gt=32849),Gt===6408&&(Gt=32856)),dt.setTexture2D($,0),Y.copyTexImage2D(3553,j,Gt,P.x,P.y,lt,qt,0),Ft.unbindTexture()},this.copyTextureToTexture=function(P,$,j,J=0){const lt=$.image.width,qt=$.image.height,Gt=nt.convert(j.format),Ot=nt.convert(j.type);dt.setTexture2D(j,0),Y.pixelStorei(37440,j.flipY),Y.pixelStorei(37441,j.premultiplyAlpha),Y.pixelStorei(3317,j.unpackAlignment),$.isDataTexture?Y.texSubImage2D(3553,J,P.x,P.y,lt,qt,Gt,Ot,$.image.data):$.isCompressedTexture?Y.compressedTexSubImage2D(3553,J,P.x,P.y,$.mipmaps[0].width,$.mipmaps[0].height,Gt,$.mipmaps[0].data):Y.texSubImage2D(3553,J,P.x,P.y,Gt,Ot,$.image),J===0&&j.generateMipmaps&&Y.generateMipmap(3553),Ft.unbindTexture()},this.copyTextureToTexture3D=function(P,$,j,J,lt=0){if(C.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const qt=P.max.x-P.min.x+1,Gt=P.max.y-P.min.y+1,Ot=P.max.z-P.min.z+1,Yt=nt.convert(J.format),ce=nt.convert(J.type);let ne;if(J.isDataTexture3D)dt.setTexture3D(J,0),ne=32879;else if(J.isDataTexture2DArray)dt.setTexture2DArray(J,0),ne=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}Y.pixelStorei(37440,J.flipY),Y.pixelStorei(37441,J.premultiplyAlpha),Y.pixelStorei(3317,J.unpackAlignment);const te=Y.getParameter(3314),fe=Y.getParameter(32878),oe=Y.getParameter(3316),Ln=Y.getParameter(3315),ue=Y.getParameter(32877),ze=j.isCompressedTexture?j.mipmaps[0]:j.image;Y.pixelStorei(3314,ze.width),Y.pixelStorei(32878,ze.height),Y.pixelStorei(3316,P.min.x),Y.pixelStorei(3315,P.min.y),Y.pixelStorei(32877,P.min.z),j.isDataTexture||j.isDataTexture3D?Y.texSubImage3D(ne,lt,$.x,$.y,$.z,qt,Gt,Ot,Yt,ce,ze.data):j.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),Y.compressedTexSubImage3D(ne,lt,$.x,$.y,$.z,qt,Gt,Ot,Yt,ze.data)):Y.texSubImage3D(ne,lt,$.x,$.y,$.z,qt,Gt,Ot,Yt,ce,ze),Y.pixelStorei(3314,te),Y.pixelStorei(32878,fe),Y.pixelStorei(3316,oe),Y.pixelStorei(3315,Ln),Y.pixelStorei(32877,ue),lt===0&&J.generateMipmaps&&Y.generateMipmap(ne),Ft.unbindTexture()},this.initTexture=function(P){dt.setTexture2D(P,0),Ft.unbindTexture()},this.resetState=function(){T=0,E=0,z=null,Ft.reset(),mt.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class Mw extends xe{}Mw.prototype.isWebGL1Renderer=!0;class _f extends de{constructor(){super();this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),e}}_f.prototype.isScene=!0;class xr{constructor(t,e){this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=lr,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=In()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,s){t*=this.stride,s*=e.stride;for(let a=0,h=this.stride;a<h;a++)this.array[t+a]=e.array[s+a];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=In()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),s=new this.constructor(e,this.stride);return s.setUsage(this.usage),s}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=In()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}xr.prototype.isInterleavedBuffer=!0;const Le=new N;class _r{constructor(t,e,s,a=!1){this.name="",this.data=t,this.itemSize=e,this.offset=s,this.normalized=a===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,s=this.data.count;e<s;e++)Le.x=this.getX(e),Le.y=this.getY(e),Le.z=this.getZ(e),Le.applyMatrix4(t),this.setXYZ(e,Le.x,Le.y,Le.z);return this}applyNormalMatrix(t){for(let e=0,s=this.count;e<s;e++)Le.x=this.getX(e),Le.y=this.getY(e),Le.z=this.getZ(e),Le.applyNormalMatrix(t),this.setXYZ(e,Le.x,Le.y,Le.z);return this}transformDirection(t){for(let e=0,s=this.count;e<s;e++)Le.x=this.getX(e),Le.y=this.getY(e),Le.z=this.getZ(e),Le.transformDirection(t),this.setXYZ(e,Le.x,Le.y,Le.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,s){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=s,this}setXYZ(t,e,s,a){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=s,this.data.array[t+2]=a,this}setXYZW(t,e,s,a,h){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=s,this.data.array[t+2]=a,this.data.array[t+3]=h,this}clone(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let s=0;s<this.count;s++){const a=s*this.data.stride+this.offset;for(let h=0;h<this.itemSize;h++)e.push(this.data.array[a+h])}return new Oe(new this.array.constructor(e),this.itemSize,this.normalized)}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new _r(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let s=0;s<this.count;s++){const a=s*this.data.stride+this.offset;for(let h=0;h<this.itemSize;h++)e.push(this.data.array[a+h])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}_r.prototype.isInterleavedBufferAttribute=!0;class yf extends Ye{constructor(t){super();this.type="SpriteMaterial",this.color=new Ht(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this}}yf.prototype.isSpriteMaterial=!0;let vs;const yr=new N,bs=new N,Ms=new N,ws=new Mt,vr=new Mt,vf=new jt,Zo=new N,br=new N,Jo=new N,bf=new Mt,ac=new Mt,Mf=new Mt;class ww extends de{constructor(t){super();if(this.type="Sprite",vs===void 0){vs=new ve;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),s=new xr(e,5);vs.setIndex([0,1,2,0,2,3]),vs.setAttribute("position",new _r(s,3,0,!1)),vs.setAttribute("uv",new _r(s,2,3,!1))}this.geometry=vs,this.material=t!==void 0?t:new yf,this.center=new Mt(.5,.5)}raycast(t,e){t.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),bs.setFromMatrixScale(this.matrixWorld),vf.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),Ms.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&bs.multiplyScalar(-Ms.z);const s=this.material.rotation;let a,h;s!==0&&(h=Math.cos(s),a=Math.sin(s));const d=this.center;Ko(Zo.set(-.5,-.5,0),Ms,d,bs,a,h),Ko(br.set(.5,-.5,0),Ms,d,bs,a,h),Ko(Jo.set(.5,.5,0),Ms,d,bs,a,h),bf.set(0,0),ac.set(1,0),Mf.set(1,1);let p=t.ray.intersectTriangle(Zo,br,Jo,!1,yr);if(p===null&&(Ko(br.set(-.5,.5,0),Ms,d,bs,a,h),ac.set(0,1),p=t.ray.intersectTriangle(Zo,Jo,br,!1,yr),p===null))return;const g=t.ray.origin.distanceTo(yr);g<t.near||g>t.far||e.push({distance:g,point:yr.clone(),uv:Pe.getUV(yr,Zo,br,Jo,bf,ac,Mf,new Mt),face:null,object:this})}copy(t){return super.copy(t),t.center!==void 0&&this.center.copy(t.center),this.material=t.material,this}}ww.prototype.isSprite=!0;function Ko(c,t,e,s,a,h){ws.subVectors(c,e).addScalar(.5).multiply(s),a!==void 0?(vr.x=h*ws.x-a*ws.y,vr.y=a*ws.x+h*ws.y):vr.copy(ws),c.copy(t),c.x+=vr.x,c.y+=vr.y,c.applyMatrix4(vf)}const wf=new N,Sf=new ge,Tf=new ge,Sw=new N,Ef=new jt;class Af extends rn{constructor(t,e){super(t,e);this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new jt,this.bindMatrixInverse=new jt}copy(t){return super.copy(t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new ge,e=this.geometry.attributes.skinWeight;for(let s=0,a=e.count;s<a;s++){t.x=e.getX(s),t.y=e.getY(s),t.z=e.getZ(s),t.w=e.getW(s);const h=1/t.manhattanLength();h!==1/0?t.multiplyScalar(h):t.set(1,0,0,0),e.setXYZW(s,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const s=this.skeleton,a=this.geometry;Sf.fromBufferAttribute(a.attributes.skinIndex,t),Tf.fromBufferAttribute(a.attributes.skinWeight,t),wf.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let h=0;h<4;h++){const d=Tf.getComponent(h);if(d!==0){const p=Sf.getComponent(h);Ef.multiplyMatrices(s.bones[p].matrixWorld,s.boneInverses[p]),e.addScaledVector(Sw.copy(wf).applyMatrix4(Ef),d)}}return e.applyMatrix4(this.bindMatrixInverse)}}Af.prototype.isSkinnedMesh=!0;class Tw extends de{constructor(){super();this.type="Bone"}}Tw.prototype.isBone=!0;class Ew extends Xe{constructor(t=null,e=1,s=1,a,h,d,p,g,_=Ne,v=Ne,b,M){super(null,d,p,g,_,v,a,h,b,M);this.image={data:t,width:e,height:s},this.magFilter=_,this.minFilter=v,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Ew.prototype.isDataTexture=!0;class lc extends Oe{constructor(t,e,s,a=1){typeof s=="number"&&(a=s,s=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."));super(t,e,s);this.meshPerAttribute=a}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}lc.prototype.isInstancedBufferAttribute=!0;const Lf=new jt,Cf=new jt,Qo=[],Mr=new rn;class Aw extends rn{constructor(t,e,s){super(t,e);this.instanceMatrix=new lc(new Float32Array(s*16),16),this.instanceColor=null,this.count=s,this.frustumCulled=!1}copy(t){return super.copy(t),this.instanceMatrix.copy(t.instanceMatrix),t.instanceColor!==null&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,t*3)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,t*16)}raycast(t,e){const s=this.matrixWorld,a=this.count;if(Mr.geometry=this.geometry,Mr.material=this.material,Mr.material!==void 0)for(let h=0;h<a;h++){this.getMatrixAt(h,Lf),Cf.multiplyMatrices(s,Lf),Mr.matrixWorld=Cf,Mr.raycast(t,Qo);for(let d=0,p=Qo.length;d<p;d++){const g=Qo[d];g.instanceId=h,g.object=this,e.push(g)}Qo.length=0}}setColorAt(t,e){this.instanceColor===null&&(this.instanceColor=new lc(new Float32Array(this.instanceMatrix.count*3),3)),e.toArray(this.instanceColor.array,t*3)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,t*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}Aw.prototype.isInstancedMesh=!0;class wr extends Ye{constructor(t){super();this.type="LineBasicMaterial",this.color=new Ht(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this}}wr.prototype.isLineBasicMaterial=!0;const Rf=new N,Pf=new N,Df=new jt,cc=new is,ta=new ns;class uc extends de{constructor(t=new ve,e=new wr){super();this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(t.index===null){const e=t.attributes.position,s=[0];for(let a=1,h=e.count;a<h;a++)Rf.fromBufferAttribute(e,a-1),Pf.fromBufferAttribute(e,a),s[a]=s[a-1],s[a]+=Rf.distanceTo(Pf);t.setAttribute("lineDistance",new Ae(s,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(t,e){const s=this.geometry,a=this.matrixWorld,h=t.params.Line.threshold,d=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),ta.copy(s.boundingSphere),ta.applyMatrix4(a),ta.radius+=h,t.ray.intersectsSphere(ta)===!1)return;Df.copy(a).invert(),cc.copy(t.ray).applyMatrix4(Df);const p=h/((this.scale.x+this.scale.y+this.scale.z)/3),g=p*p,_=new N,v=new N,b=new N,M=new N,S=this.isLineSegments?2:1;if(s.isBufferGeometry){const L=s.index,k=s.attributes.position;if(L!==null){const T=Math.max(0,d.start),E=Math.min(L.count,d.start+d.count);for(let z=T,I=E-1;z<I;z+=S){const V=L.getX(z),G=L.getX(z+1);if(_.fromBufferAttribute(k,V),v.fromBufferAttribute(k,G),cc.distanceSqToSegment(_,v,M,b)>g)continue;M.applyMatrix4(this.matrixWorld);const K=t.ray.origin.distanceTo(M);K<t.near||K>t.far||e.push({distance:K,point:b.clone().applyMatrix4(this.matrixWorld),index:z,face:null,faceIndex:null,object:this})}}else{const T=Math.max(0,d.start),E=Math.min(k.count,d.start+d.count);for(let z=T,I=E-1;z<I;z+=S){if(_.fromBufferAttribute(k,z),v.fromBufferAttribute(k,z+1),cc.distanceSqToSegment(_,v,M,b)>g)continue;M.applyMatrix4(this.matrixWorld);const G=t.ray.origin.distanceTo(M);G<t.near||G>t.far||e.push({distance:G,point:b.clone().applyMatrix4(this.matrixWorld),index:z,face:null,faceIndex:null,object:this})}}}else s.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,s=Object.keys(e);if(s.length>0){const a=e[s[0]];if(a!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let h=0,d=a.length;h<d;h++){const p=a[h].name||String(h);this.morphTargetInfluences.push(0),this.morphTargetDictionary[p]=h}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}uc.prototype.isLine=!0;const If=new N,Ff=new N;class hc extends uc{constructor(t,e){super(t,e);this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(t.index===null){const e=t.attributes.position,s=[];for(let a=0,h=e.count;a<h;a+=2)If.fromBufferAttribute(e,a),Ff.fromBufferAttribute(e,a+1),s[a]=a===0?0:s[a-1],s[a+1]=s[a]+If.distanceTo(Ff);t.setAttribute("lineDistance",new Ae(s,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}hc.prototype.isLineSegments=!0;class Lw extends uc{constructor(t,e){super(t,e);this.type="LineLoop"}}Lw.prototype.isLineLoop=!0;class kf extends Ye{constructor(t){super();this.type="PointsMaterial",this.color=new Ht(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this}}kf.prototype.isPointsMaterial=!0;const Of=new jt,dc=new is,ea=new ns,na=new N;class Cw extends de{constructor(t=new ve,e=new kf){super();this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const s=this.geometry,a=this.matrixWorld,h=t.params.Points.threshold,d=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),ea.copy(s.boundingSphere),ea.applyMatrix4(a),ea.radius+=h,t.ray.intersectsSphere(ea)===!1)return;Of.copy(a).invert(),dc.copy(t.ray).applyMatrix4(Of);const p=h/((this.scale.x+this.scale.y+this.scale.z)/3),g=p*p;if(s.isBufferGeometry){const _=s.index,b=s.attributes.position;if(_!==null){const M=Math.max(0,d.start),S=Math.min(_.count,d.start+d.count);for(let L=M,C=S;L<C;L++){const k=_.getX(L);na.fromBufferAttribute(b,k),Bf(na,k,g,a,t,e,this)}}else{const M=Math.max(0,d.start),S=Math.min(b.count,d.start+d.count);for(let L=M,C=S;L<C;L++)na.fromBufferAttribute(b,L),Bf(na,L,g,a,t,e,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,s=Object.keys(e);if(s.length>0){const a=e[s[0]];if(a!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let h=0,d=a.length;h<d;h++){const p=a[h].name||String(h);this.morphTargetInfluences.push(0),this.morphTargetDictionary[p]=h}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Cw.prototype.isPoints=!0;function Bf(c,t,e,s,a,h,d){const p=dc.distanceSqToPoint(c);if(p<e){const g=new N;dc.closestPointToPoint(c,g),g.applyMatrix4(s);const _=a.ray.origin.distanceTo(g);if(_<a.near||_>a.far)return;h.push({distance:_,distanceToRay:Math.sqrt(p),point:g,index:t,face:null,object:d})}}class Rw extends Xe{constructor(t,e,s,a,h,d,p,g,_){super(t,e,s,a,h,d,p,g,_);this.format=p!==void 0?p:ji,this.minFilter=d!==void 0?d:xn,this.magFilter=h!==void 0?h:xn,this.generateMipmaps=!1;const v=this;function b(){v.needsUpdate=!0,t.requestVideoFrameCallback(b)}"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback(b)}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;"requestVideoFrameCallback"in t===!1&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}Rw.prototype.isVideoTexture=!0;class Pw extends Xe{constructor(t,e,s,a,h,d,p,g,_,v,b,M){super(null,d,p,g,_,v,a,h,b,M);this.image={width:e,height:s},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}Pw.prototype.isCompressedTexture=!0;class Dw extends Xe{constructor(t,e,s,a,h,d,p,g,_){super(t,e,s,a,h,d,p,g,_);this.needsUpdate=!0}}Dw.prototype.isCanvasTexture=!0;class Iw extends Xe{constructor(t,e,s,a,h,d,p,g,_,v){if(v=v!==void 0?v:qi,v!==qi&&v!==ar)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");s===void 0&&v===qi&&(s=bo),s===void 0&&v===ar&&(s=or);super(null,a,h,d,p,g,v,s,_);this.image={width:t,height:e},this.magFilter=p!==void 0?p:Ne,this.minFilter=g!==void 0?g:Ne,this.flipY=!1,this.generateMipmaps=!1}}Iw.prototype.isDepthTexture=!0;new N;new N;new N;new Pe;class yn{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const s=this.getUtoTmapping(t);return this.getPoint(s,e)}getPoints(t=5){const e=[];for(let s=0;s<=t;s++)e.push(this.getPoint(s/t));return e}getSpacedPoints(t=5){const e=[];for(let s=0;s<=t;s++)e.push(this.getPointAt(s/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let s,a=this.getPoint(0),h=0;e.push(0);for(let d=1;d<=t;d++)s=this.getPoint(d/t),h+=s.distanceTo(a),e.push(h),a=s;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const s=this.getLengths();let a=0;const h=s.length;let d;e?d=e:d=t*s[h-1];let p=0,g=h-1,_;for(;p<=g;)if(a=Math.floor(p+(g-p)/2),_=s[a]-d,_<0)p=a+1;else if(_>0)g=a-1;else{g=a;break}if(a=g,s[a]===d)return a/(h-1);const v=s[a],M=s[a+1]-v,S=(d-v)/M;return(a+S)/(h-1)}getTangent(t,e){const s=1e-4;let a=t-s,h=t+s;a<0&&(a=0),h>1&&(h=1);const d=this.getPoint(a),p=this.getPoint(h),g=e||(d.isVector2?new Mt:new N);return g.copy(p).sub(d).normalize(),g}getTangentAt(t,e){const s=this.getUtoTmapping(t);return this.getTangent(s,e)}computeFrenetFrames(t,e){const s=new N,a=[],h=[],d=[],p=new N,g=new jt;for(let S=0;S<=t;S++){const L=S/t;a[S]=this.getTangentAt(L,new N)}h[0]=new N,d[0]=new N;let _=Number.MAX_VALUE;const v=Math.abs(a[0].x),b=Math.abs(a[0].y),M=Math.abs(a[0].z);v<=_&&(_=v,s.set(1,0,0)),b<=_&&(_=b,s.set(0,1,0)),M<=_&&s.set(0,0,1),p.crossVectors(a[0],s).normalize(),h[0].crossVectors(a[0],p),d[0].crossVectors(a[0],h[0]);for(let S=1;S<=t;S++){if(h[S]=h[S-1].clone(),d[S]=d[S-1].clone(),p.crossVectors(a[S-1],a[S]),p.length()>Number.EPSILON){p.normalize();const L=Math.acos(cn(a[S-1].dot(a[S]),-1,1));h[S].applyMatrix4(g.makeRotationAxis(p,L))}d[S].crossVectors(a[S],h[S])}if(e===!0){let S=Math.acos(cn(h[0].dot(h[t]),-1,1));S/=t,a[0].dot(p.crossVectors(h[0],h[t]))>0&&(S=-S);for(let L=1;L<=t;L++)h[L].applyMatrix4(g.makeRotationAxis(a[L],S*L)),d[L].crossVectors(a[L],h[L])}return{tangents:a,normals:h,binormals:d}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class ia extends yn{constructor(t=0,e=0,s=1,a=1,h=0,d=Math.PI*2,p=!1,g=0){super();this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=s,this.yRadius=a,this.aStartAngle=h,this.aEndAngle=d,this.aClockwise=p,this.aRotation=g}getPoint(t,e){const s=e||new Mt,a=Math.PI*2;let h=this.aEndAngle-this.aStartAngle;const d=Math.abs(h)<Number.EPSILON;for(;h<0;)h+=a;for(;h>a;)h-=a;h<Number.EPSILON&&(d?h=0:h=a),this.aClockwise===!0&&!d&&(h===a?h=-a:h=h-a);const p=this.aStartAngle+t*h;let g=this.aX+this.xRadius*Math.cos(p),_=this.aY+this.yRadius*Math.sin(p);if(this.aRotation!==0){const v=Math.cos(this.aRotation),b=Math.sin(this.aRotation),M=g-this.aX,S=_-this.aY;g=M*v-S*b+this.aX,_=M*b+S*v+this.aY}return s.set(g,_)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}ia.prototype.isEllipseCurve=!0;class zf extends ia{constructor(t,e,s,a,h,d){super(t,e,s,s,a,h,d);this.type="ArcCurve"}}zf.prototype.isArcCurve=!0;function fc(){let c=0,t=0,e=0,s=0;function a(h,d,p,g){c=h,t=p,e=-3*h+3*d-2*p-g,s=2*h-2*d+p+g}return{initCatmullRom:function(h,d,p,g,_){a(d,p,_*(p-h),_*(g-d))},initNonuniformCatmullRom:function(h,d,p,g,_,v,b){let M=(d-h)/_-(p-h)/(_+v)+(p-d)/v,S=(p-d)/v-(g-d)/(v+b)+(g-p)/b;M*=v,S*=v,a(d,p,M,S)},calc:function(h){const d=h*h,p=d*h;return c+t*h+e*d+s*p}}}const sa=new N,pc=new fc,mc=new fc,gc=new fc;class Nf extends yn{constructor(t=[],e=!1,s="centripetal",a=.5){super();this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=s,this.tension=a}getPoint(t,e=new N){const s=e,a=this.points,h=a.length,d=(h-(this.closed?0:1))*t;let p=Math.floor(d),g=d-p;this.closed?p+=p>0?0:(Math.floor(Math.abs(p)/h)+1)*h:g===0&&p===h-1&&(p=h-2,g=1);let _,v;this.closed||p>0?_=a[(p-1)%h]:(sa.subVectors(a[0],a[1]).add(a[0]),_=sa);const b=a[p%h],M=a[(p+1)%h];if(this.closed||p+2<h?v=a[(p+2)%h]:(sa.subVectors(a[h-1],a[h-2]).add(a[h-1]),v=sa),this.curveType==="centripetal"||this.curveType==="chordal"){const S=this.curveType==="chordal"?.5:.25;let L=Math.pow(_.distanceToSquared(b),S),C=Math.pow(b.distanceToSquared(M),S),k=Math.pow(M.distanceToSquared(v),S);C<1e-4&&(C=1),L<1e-4&&(L=C),k<1e-4&&(k=C),pc.initNonuniformCatmullRom(_.x,b.x,M.x,v.x,L,C,k),mc.initNonuniformCatmullRom(_.y,b.y,M.y,v.y,L,C,k),gc.initNonuniformCatmullRom(_.z,b.z,M.z,v.z,L,C,k)}else this.curveType==="catmullrom"&&(pc.initCatmullRom(_.x,b.x,M.x,v.x,this.tension),mc.initCatmullRom(_.y,b.y,M.y,v.y,this.tension),gc.initCatmullRom(_.z,b.z,M.z,v.z,this.tension));return s.set(pc.calc(g),mc.calc(g),gc.calc(g)),s}copy(t){super.copy(t),this.points=[];for(let e=0,s=t.points.length;e<s;e++){const a=t.points[e];this.points.push(a.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,s=this.points.length;e<s;e++){const a=this.points[e];t.points.push(a.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,s=t.points.length;e<s;e++){const a=t.points[e];this.points.push(new N().fromArray(a))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}Nf.prototype.isCatmullRomCurve3=!0;function Vf(c,t,e,s,a){const h=(s-t)*.5,d=(a-e)*.5,p=c*c,g=c*p;return(2*e-2*s+h+d)*g+(-3*e+3*s-2*h-d)*p+h*c+e}function Fw(c,t){const e=1-c;return e*e*t}function kw(c,t){return 2*(1-c)*c*t}function Ow(c,t){return c*c*t}function Sr(c,t,e,s){return Fw(c,t)+kw(c,e)+Ow(c,s)}function Bw(c,t){const e=1-c;return e*e*e*t}function zw(c,t){const e=1-c;return 3*e*e*c*t}function Nw(c,t){return 3*(1-c)*c*c*t}function Vw(c,t){return c*c*c*t}function Tr(c,t,e,s,a){return Bw(c,t)+zw(c,e)+Nw(c,s)+Vw(c,a)}class xc extends yn{constructor(t=new Mt,e=new Mt,s=new Mt,a=new Mt){super();this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=s,this.v3=a}getPoint(t,e=new Mt){const s=e,a=this.v0,h=this.v1,d=this.v2,p=this.v3;return s.set(Tr(t,a.x,h.x,d.x,p.x),Tr(t,a.y,h.y,d.y,p.y)),s}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}xc.prototype.isCubicBezierCurve=!0;class Uf extends yn{constructor(t=new N,e=new N,s=new N,a=new N){super();this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=s,this.v3=a}getPoint(t,e=new N){const s=e,a=this.v0,h=this.v1,d=this.v2,p=this.v3;return s.set(Tr(t,a.x,h.x,d.x,p.x),Tr(t,a.y,h.y,d.y,p.y),Tr(t,a.z,h.z,d.z,p.z)),s}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Uf.prototype.isCubicBezierCurve3=!0;class ra extends yn{constructor(t=new Mt,e=new Mt){super();this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new Mt){const s=e;return t===1?s.copy(this.v2):(s.copy(this.v2).sub(this.v1),s.multiplyScalar(t).add(this.v1)),s}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const s=e||new Mt;return s.copy(this.v2).sub(this.v1).normalize(),s}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}ra.prototype.isLineCurve=!0;class Uw extends yn{constructor(t=new N,e=new N){super();this.type="LineCurve3",this.isLineCurve3=!0,this.v1=t,this.v2=e}getPoint(t,e=new N){const s=e;return t===1?s.copy(this.v2):(s.copy(this.v2).sub(this.v1),s.multiplyScalar(t).add(this.v1)),s}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class _c extends yn{constructor(t=new Mt,e=new Mt,s=new Mt){super();this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=s}getPoint(t,e=new Mt){const s=e,a=this.v0,h=this.v1,d=this.v2;return s.set(Sr(t,a.x,h.x,d.x),Sr(t,a.y,h.y,d.y)),s}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}_c.prototype.isQuadraticBezierCurve=!0;class Hf extends yn{constructor(t=new N,e=new N,s=new N){super();this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=s}getPoint(t,e=new N){const s=e,a=this.v0,h=this.v1,d=this.v2;return s.set(Sr(t,a.x,h.x,d.x),Sr(t,a.y,h.y,d.y),Sr(t,a.z,h.z,d.z)),s}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Hf.prototype.isQuadraticBezierCurve3=!0;class yc extends yn{constructor(t=[]){super();this.type="SplineCurve",this.points=t}getPoint(t,e=new Mt){const s=e,a=this.points,h=(a.length-1)*t,d=Math.floor(h),p=h-d,g=a[d===0?d:d-1],_=a[d],v=a[d>a.length-2?a.length-1:d+1],b=a[d>a.length-3?a.length-1:d+2];return s.set(Vf(p,g.x,_.x,v.x,b.x),Vf(p,g.y,_.y,v.y,b.y)),s}copy(t){super.copy(t),this.points=[];for(let e=0,s=t.points.length;e<s;e++){const a=t.points[e];this.points.push(a.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,s=this.points.length;e<s;e++){const a=this.points[e];t.points.push(a.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,s=t.points.length;e<s;e++){const a=t.points[e];this.points.push(new Mt().fromArray(a))}return this}}yc.prototype.isSplineCurve=!0;var Wf=Object.freeze({__proto__:null,ArcCurve:zf,CatmullRomCurve3:Nf,CubicBezierCurve:xc,CubicBezierCurve3:Uf,EllipseCurve:ia,LineCurve:ra,LineCurve3:Uw,QuadraticBezierCurve:_c,QuadraticBezierCurve3:Hf,SplineCurve:yc});class Hw extends yn{constructor(){super();this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new ra(e,t))}getPoint(t,e){const s=t*this.getLength(),a=this.getCurveLengths();let h=0;for(;h<a.length;){if(a[h]>=s){const d=a[h]-s,p=this.curves[h],g=p.getLength(),_=g===0?0:1-d/g;return p.getPointAt(_,e)}h++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let s=0,a=this.curves.length;s<a;s++)e+=this.curves[s].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let s=0;s<=t;s++)e.push(this.getPoint(s/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let s;for(let a=0,h=this.curves;a<h.length;a++){const d=h[a],p=d&&d.isEllipseCurve?t*2:d&&(d.isLineCurve||d.isLineCurve3)?1:d&&d.isSplineCurve?t*d.points.length:t,g=d.getPoints(p);for(let _=0;_<g.length;_++){const v=g[_];s&&s.equals(v)||(e.push(v),s=v)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,s=t.curves.length;e<s;e++){const a=t.curves[e];this.curves.push(a.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,s=this.curves.length;e<s;e++){const a=this.curves[e];t.curves.push(a.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,s=t.curves.length;e<s;e++){const a=t.curves[e];this.curves.push(new Wf[a.type]().fromJSON(a))}return this}}class vc extends Hw{constructor(t){super();this.type="Path",this.currentPoint=new Mt,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,s=t.length;e<s;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const s=new ra(this.currentPoint.clone(),new Mt(t,e));return this.curves.push(s),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,s,a){const h=new _c(this.currentPoint.clone(),new Mt(t,e),new Mt(s,a));return this.curves.push(h),this.currentPoint.set(s,a),this}bezierCurveTo(t,e,s,a,h,d){const p=new xc(this.currentPoint.clone(),new Mt(t,e),new Mt(s,a),new Mt(h,d));return this.curves.push(p),this.currentPoint.set(h,d),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),s=new yc(e);return this.curves.push(s),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,s,a,h,d){const p=this.currentPoint.x,g=this.currentPoint.y;return this.absarc(t+p,e+g,s,a,h,d),this}absarc(t,e,s,a,h,d){return this.absellipse(t,e,s,s,a,h,d),this}ellipse(t,e,s,a,h,d,p,g){const _=this.currentPoint.x,v=this.currentPoint.y;return this.absellipse(t+_,e+v,s,a,h,d,p,g),this}absellipse(t,e,s,a,h,d,p,g){const _=new ia(t,e,s,a,h,d,p,g);if(this.curves.length>0){const b=_.getPoint(0);b.equals(this.currentPoint)||this.lineTo(b.x,b.y)}this.curves.push(_);const v=_.getPoint(1);return this.currentPoint.copy(v),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class Er extends vc{constructor(t){super(t);this.uuid=In(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let s=0,a=this.holes.length;s<a;s++)e[s]=this.holes[s].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,s=t.holes.length;e<s;e++){const a=t.holes[e];this.holes.push(a.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,s=this.holes.length;e<s;e++){const a=this.holes[e];t.holes.push(a.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,s=t.holes.length;e<s;e++){const a=t.holes[e];this.holes.push(new vc().fromJSON(a))}return this}}const Ww={triangulate:function(c,t,e=2){const s=t&&t.length,a=s?t[0]*e:c.length;let h=Gf(c,0,a,e,!0);const d=[];if(!h||h.next===h.prev)return d;let p,g,_,v,b,M,S;if(s&&(h=Yw(c,t,h,e)),c.length>80*e){p=_=c[0],g=v=c[1];for(let L=e;L<a;L+=e)b=c[L],M=c[L+1],b<p&&(p=b),M<g&&(g=M),b>_&&(_=b),M>v&&(v=M);S=Math.max(_-p,v-g),S=S!==0?1/S:0}return Ar(h,d,e,p,g,S),d}};function Gf(c,t,e,s,a){let h,d;if(a===rS(c,t,e,s)>0)for(h=t;h<e;h+=s)d=qf(h,c[h],c[h+1],d);else for(h=e-s;h>=t;h-=s)d=qf(h,c[h],c[h+1],d);return d&&oa(d,d.next)&&(Cr(d),d=d.next),d}function mi(c,t){if(!c)return c;t||(t=c);let e=c,s;do if(s=!1,!e.steiner&&(oa(e,e.next)||Te(e.prev,e,e.next)===0)){if(Cr(e),e=t=e.prev,e===e.next)break;s=!0}else e=e.next;while(s||e!==t);return t}function Ar(c,t,e,s,a,h,d){if(!c)return;!d&&h&&Qw(c,s,a,h);let p=c,g,_;for(;c.prev!==c.next;){if(g=c.prev,_=c.next,h?Xw(c,s,a,h):Gw(c)){t.push(g.i/e),t.push(c.i/e),t.push(_.i/e),Cr(c),c=_.next,p=_.next;continue}if(c=_,c===p){d?d===1?(c=jw(mi(c),t,e),Ar(c,t,e,s,a,h,2)):d===2&&qw(c,t,e,s,a,h):Ar(mi(c),t,e,s,a,h,1);break}}}function Gw(c){const t=c.prev,e=c,s=c.next;if(Te(t,e,s)>=0)return!1;let a=c.next.next;for(;a!==c.prev;){if(Ss(t.x,t.y,e.x,e.y,s.x,s.y,a.x,a.y)&&Te(a.prev,a,a.next)>=0)return!1;a=a.next}return!0}function Xw(c,t,e,s){const a=c.prev,h=c,d=c.next;if(Te(a,h,d)>=0)return!1;const p=a.x<h.x?a.x<d.x?a.x:d.x:h.x<d.x?h.x:d.x,g=a.y<h.y?a.y<d.y?a.y:d.y:h.y<d.y?h.y:d.y,_=a.x>h.x?a.x>d.x?a.x:d.x:h.x>d.x?h.x:d.x,v=a.y>h.y?a.y>d.y?a.y:d.y:h.y>d.y?h.y:d.y,b=bc(p,g,t,e,s),M=bc(_,v,t,e,s);let S=c.prevZ,L=c.nextZ;for(;S&&S.z>=b&&L&&L.z<=M;){if(S!==c.prev&&S!==c.next&&Ss(a.x,a.y,h.x,h.y,d.x,d.y,S.x,S.y)&&Te(S.prev,S,S.next)>=0||(S=S.prevZ,L!==c.prev&&L!==c.next&&Ss(a.x,a.y,h.x,h.y,d.x,d.y,L.x,L.y)&&Te(L.prev,L,L.next)>=0))return!1;L=L.nextZ}for(;S&&S.z>=b;){if(S!==c.prev&&S!==c.next&&Ss(a.x,a.y,h.x,h.y,d.x,d.y,S.x,S.y)&&Te(S.prev,S,S.next)>=0)return!1;S=S.prevZ}for(;L&&L.z<=M;){if(L!==c.prev&&L!==c.next&&Ss(a.x,a.y,h.x,h.y,d.x,d.y,L.x,L.y)&&Te(L.prev,L,L.next)>=0)return!1;L=L.nextZ}return!0}function jw(c,t,e){let s=c;do{const a=s.prev,h=s.next.next;!oa(a,h)&&Xf(a,s,s.next,h)&&Lr(a,h)&&Lr(h,a)&&(t.push(a.i/e),t.push(s.i/e),t.push(h.i/e),Cr(s),Cr(s.next),s=c=h),s=s.next}while(s!==c);return mi(s)}function qw(c,t,e,s,a,h){let d=c;do{let p=d.next.next;for(;p!==d.prev;){if(d.i!==p.i&&nS(d,p)){let g=jf(d,p);d=mi(d,d.next),g=mi(g,g.next),Ar(d,t,e,s,a,h),Ar(g,t,e,s,a,h);return}p=p.next}d=d.next}while(d!==c)}function Yw(c,t,e,s){const a=[];let h,d,p,g,_;for(h=0,d=t.length;h<d;h++)p=t[h]*s,g=h<d-1?t[h+1]*s:c.length,_=Gf(c,p,g,s,!1),_===_.next&&(_.steiner=!0),a.push(eS(_));for(a.sort($w),h=0;h<a.length;h++)Zw(a[h],e),e=mi(e,e.next);return e}function $w(c,t){return c.x-t.x}function Zw(c,t){if(t=Jw(c,t),t){const e=jf(t,c);mi(t,t.next),mi(e,e.next)}}function Jw(c,t){let e=t;const s=c.x,a=c.y;let h=-1/0,d;do{if(a<=e.y&&a>=e.next.y&&e.next.y!==e.y){const M=e.x+(a-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(M<=s&&M>h){if(h=M,M===s){if(a===e.y)return e;if(a===e.next.y)return e.next}d=e.x<e.next.x?e:e.next}}e=e.next}while(e!==t);if(!d)return null;if(s===h)return d;const p=d,g=d.x,_=d.y;let v=1/0,b;e=d;do s>=e.x&&e.x>=g&&s!==e.x&&Ss(a<_?s:h,a,g,_,a<_?h:s,a,e.x,e.y)&&(b=Math.abs(a-e.y)/(s-e.x),Lr(e,c)&&(b<v||b===v&&(e.x>d.x||e.x===d.x&&Kw(d,e)))&&(d=e,v=b)),e=e.next;while(e!==p);return d}function Kw(c,t){return Te(c.prev,c,t.prev)<0&&Te(t.next,c,c.next)<0}function Qw(c,t,e,s){let a=c;do a.z===null&&(a.z=bc(a.x,a.y,t,e,s)),a.prevZ=a.prev,a.nextZ=a.next,a=a.next;while(a!==c);a.prevZ.nextZ=null,a.prevZ=null,tS(a)}function tS(c){let t,e,s,a,h,d,p,g,_=1;do{for(e=c,c=null,h=null,d=0;e;){for(d++,s=e,p=0,t=0;t<_&&(p++,s=s.nextZ,!!s);t++);for(g=_;p>0||g>0&&s;)p!==0&&(g===0||!s||e.z<=s.z)?(a=e,e=e.nextZ,p--):(a=s,s=s.nextZ,g--),h?h.nextZ=a:c=a,a.prevZ=h,h=a;e=s}h.nextZ=null,_*=2}while(d>1);return c}function bc(c,t,e,s,a){return c=32767*(c-e)*a,t=32767*(t-s)*a,c=(c|c<<8)&16711935,c=(c|c<<4)&252645135,c=(c|c<<2)&858993459,c=(c|c<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,c|t<<1}function eS(c){let t=c,e=c;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==c);return e}function Ss(c,t,e,s,a,h,d,p){return(a-d)*(t-p)-(c-d)*(h-p)>=0&&(c-d)*(s-p)-(e-d)*(t-p)>=0&&(e-d)*(h-p)-(a-d)*(s-p)>=0}function nS(c,t){return c.next.i!==t.i&&c.prev.i!==t.i&&!iS(c,t)&&(Lr(c,t)&&Lr(t,c)&&sS(c,t)&&(Te(c.prev,c,t.prev)||Te(c,t.prev,t))||oa(c,t)&&Te(c.prev,c,c.next)>0&&Te(t.prev,t,t.next)>0)}function Te(c,t,e){return(t.y-c.y)*(e.x-t.x)-(t.x-c.x)*(e.y-t.y)}function oa(c,t){return c.x===t.x&&c.y===t.y}function Xf(c,t,e,s){const a=la(Te(c,t,e)),h=la(Te(c,t,s)),d=la(Te(e,s,c)),p=la(Te(e,s,t));return!!(a!==h&&d!==p||a===0&&aa(c,e,t)||h===0&&aa(c,s,t)||d===0&&aa(e,c,s)||p===0&&aa(e,t,s))}function aa(c,t,e){return t.x<=Math.max(c.x,e.x)&&t.x>=Math.min(c.x,e.x)&&t.y<=Math.max(c.y,e.y)&&t.y>=Math.min(c.y,e.y)}function la(c){return c>0?1:c<0?-1:0}function iS(c,t){let e=c;do{if(e.i!==c.i&&e.next.i!==c.i&&e.i!==t.i&&e.next.i!==t.i&&Xf(e,e.next,c,t))return!0;e=e.next}while(e!==c);return!1}function Lr(c,t){return Te(c.prev,c,c.next)<0?Te(c,t,c.next)>=0&&Te(c,c.prev,t)>=0:Te(c,t,c.prev)<0||Te(c,c.next,t)<0}function sS(c,t){let e=c,s=!1;const a=(c.x+t.x)/2,h=(c.y+t.y)/2;do e.y>h!=e.next.y>h&&e.next.y!==e.y&&a<(e.next.x-e.x)*(h-e.y)/(e.next.y-e.y)+e.x&&(s=!s),e=e.next;while(e!==c);return s}function jf(c,t){const e=new Mc(c.i,c.x,c.y),s=new Mc(t.i,t.x,t.y),a=c.next,h=t.prev;return c.next=t,t.prev=c,e.next=a,a.prev=e,s.next=e,e.prev=s,h.next=s,s.prev=h,s}function qf(c,t,e,s){const a=new Mc(c,t,e);return s?(a.next=s.next,a.prev=s,s.next.prev=a,s.next=a):(a.prev=a,a.next=a),a}function Cr(c){c.next.prev=c.prev,c.prev.next=c.next,c.prevZ&&(c.prevZ.nextZ=c.nextZ),c.nextZ&&(c.nextZ.prevZ=c.prevZ)}function Mc(c,t,e){this.i=c,this.x=t,this.y=e,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function rS(c,t,e,s){let a=0;for(let h=t,d=e-s;h<e;h+=s)a+=(c[d]-c[h])*(c[h+1]+c[d+1]),d=h;return a}class gi{static area(t){const e=t.length;let s=0;for(let a=e-1,h=0;h<e;a=h++)s+=t[a].x*t[h].y-t[h].x*t[a].y;return s*.5}static isClockWise(t){return gi.area(t)<0}static triangulateShape(t,e){const s=[],a=[],h=[];Yf(t),$f(s,t);let d=t.length;e.forEach(Yf);for(let g=0;g<e.length;g++)a.push(d),d+=e[g].length,$f(s,e[g]);const p=Ww.triangulate(s,a);for(let g=0;g<p.length;g+=3)h.push(p.slice(g,g+3));return h}}function Yf(c){const t=c.length;t>2&&c[t-1].equals(c[0])&&c.pop()}function $f(c,t){for(let e=0;e<t.length;e++)c.push(t[e].x),c.push(t[e].y)}class Ts extends ve{constructor(t=new Er([new Mt(.5,.5),new Mt(-.5,.5),new Mt(-.5,-.5),new Mt(.5,-.5)]),e={}){super();this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const s=this,a=[],h=[];for(let p=0,g=t.length;p<g;p++){const _=t[p];d(_)}this.setAttribute("position",new Ae(a,3)),this.setAttribute("uv",new Ae(h,2)),this.computeVertexNormals();function d(p){const g=[],_=e.curveSegments!==void 0?e.curveSegments:12,v=e.steps!==void 0?e.steps:1;let b=e.depth!==void 0?e.depth:1,M=e.bevelEnabled!==void 0?e.bevelEnabled:!0,S=e.bevelThickness!==void 0?e.bevelThickness:.2,L=e.bevelSize!==void 0?e.bevelSize:S-.1,C=e.bevelOffset!==void 0?e.bevelOffset:0,k=e.bevelSegments!==void 0?e.bevelSegments:3;const T=e.extrudePath,E=e.UVGenerator!==void 0?e.UVGenerator:oS;e.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),b=e.amount);let z,I=!1,V,G,F,K;T&&(z=T.getSpacedPoints(v),I=!0,M=!1,V=T.computeFrenetFrames(v,!1),G=new N,F=new N,K=new N),M||(k=0,S=0,L=0,C=0);const pt=p.extractPoints(_);let ut=pt.shape;const X=pt.holes;if(!gi.isClockWise(ut)){ut=ut.reverse();for(let ot=0,dt=X.length;ot<dt;ot++){const _t=X[ot];gi.isClockWise(_t)&&(X[ot]=_t.reverse())}}const it=gi.triangulateShape(ut,X),Q=ut;for(let ot=0,dt=X.length;ot<dt;ot++){const _t=X[ot];ut=ut.concat(_t)}function rt(ot,dt,_t){return dt||console.error("THREE.ExtrudeGeometry: vec does not exist"),dt.clone().multiplyScalar(_t).add(ot)}const tt=ut.length,st=it.length;function St(ot,dt,_t){let Nt,Rt,B;const D=ot.x-dt.x,et=ot.y-dt.y,bt=_t.x-ot.x,at=_t.y-ot.y,gt=D*D+et*et,Et=D*at-et*bt;if(Math.abs(Et)>Number.EPSILON){const At=Math.sqrt(gt),Vt=Math.sqrt(bt*bt+at*at),ft=dt.x-et/At,W=dt.y+D/At,Lt=_t.x-at/Vt,nt=_t.y+bt/Vt,mt=((Lt-ft)*at-(nt-W)*bt)/(D*at-et*bt);Nt=ft+D*mt-ot.x,Rt=W+et*mt-ot.y;const kt=Nt*Nt+Rt*Rt;if(kt<=2)return new Mt(Nt,Rt);B=Math.sqrt(kt/2)}else{let At=!1;D>Number.EPSILON?bt>Number.EPSILON&&(At=!0):D<-Number.EPSILON?bt<-Number.EPSILON&&(At=!0):Math.sign(et)===Math.sign(at)&&(At=!0),At?(Nt=-et,Rt=D,B=Math.sqrt(gt)):(Nt=D,Rt=et,B=Math.sqrt(gt/2))}return new Mt(Nt/B,Rt/B)}const Bt=[];for(let ot=0,dt=Q.length,_t=dt-1,Nt=ot+1;ot<dt;ot++,_t++,Nt++)_t===dt&&(_t=0),Nt===dt&&(Nt=0),Bt[ot]=St(Q[ot],Q[_t],Q[Nt]);const Wt=[];let Pt,Zt=Bt.concat();for(let ot=0,dt=X.length;ot<dt;ot++){const _t=X[ot];Pt=[];for(let Nt=0,Rt=_t.length,B=Rt-1,D=Nt+1;Nt<Rt;Nt++,B++,D++)B===Rt&&(B=0),D===Rt&&(D=0),Pt[Nt]=St(_t[Nt],_t[B],_t[D]);Wt.push(Pt),Zt=Zt.concat(Pt)}for(let ot=0;ot<k;ot++){const dt=ot/k,_t=S*Math.cos(dt*Math.PI/2),Nt=L*Math.sin(dt*Math.PI/2)+C;for(let Rt=0,B=Q.length;Rt<B;Rt++){const D=rt(Q[Rt],Bt[Rt],Nt);Xt(D.x,D.y,-_t)}for(let Rt=0,B=X.length;Rt<B;Rt++){const D=X[Rt];Pt=Wt[Rt];for(let et=0,bt=D.length;et<bt;et++){const at=rt(D[et],Pt[et],Nt);Xt(at.x,at.y,-_t)}}}const ee=L+C;for(let ot=0;ot<tt;ot++){const dt=M?rt(ut[ot],Zt[ot],ee):ut[ot];I?(F.copy(V.normals[0]).multiplyScalar(dt.x),G.copy(V.binormals[0]).multiplyScalar(dt.y),K.copy(z[0]).add(F).add(G),Xt(K.x,K.y,K.z)):Xt(dt.x,dt.y,0)}for(let ot=1;ot<=v;ot++)for(let dt=0;dt<tt;dt++){const _t=M?rt(ut[dt],Zt[dt],ee):ut[dt];I?(F.copy(V.normals[ot]).multiplyScalar(_t.x),G.copy(V.binormals[ot]).multiplyScalar(_t.y),K.copy(z[ot]).add(F).add(G),Xt(K.x,K.y,K.z)):Xt(_t.x,_t.y,b/v*ot)}for(let ot=k-1;ot>=0;ot--){const dt=ot/k,_t=S*Math.cos(dt*Math.PI/2),Nt=L*Math.sin(dt*Math.PI/2)+C;for(let Rt=0,B=Q.length;Rt<B;Rt++){const D=rt(Q[Rt],Bt[Rt],Nt);Xt(D.x,D.y,b+_t)}for(let Rt=0,B=X.length;Rt<B;Rt++){const D=X[Rt];Pt=Wt[Rt];for(let et=0,bt=D.length;et<bt;et++){const at=rt(D[et],Pt[et],Nt);I?Xt(at.x,at.y+z[v-1].y,z[v-1].x+_t):Xt(at.x,at.y,b+_t)}}}re(),xt();function re(){const ot=a.length/3;if(M){let dt=0,_t=tt*dt;for(let Nt=0;Nt<st;Nt++){const Rt=it[Nt];It(Rt[2]+_t,Rt[1]+_t,Rt[0]+_t)}dt=v+k*2,_t=tt*dt;for(let Nt=0;Nt<st;Nt++){const Rt=it[Nt];It(Rt[0]+_t,Rt[1]+_t,Rt[2]+_t)}}else{for(let dt=0;dt<st;dt++){const _t=it[dt];It(_t[2],_t[1],_t[0])}for(let dt=0;dt<st;dt++){const _t=it[dt];It(_t[0]+tt*v,_t[1]+tt*v,_t[2]+tt*v)}}s.addGroup(ot,a.length/3-ot,0)}function xt(){const ot=a.length/3;let dt=0;Y(Q,dt),dt+=Q.length;for(let _t=0,Nt=X.length;_t<Nt;_t++){const Rt=X[_t];Y(Rt,dt),dt+=Rt.length}s.addGroup(ot,a.length/3-ot,1)}function Y(ot,dt){let _t=ot.length;for(;--_t>=0;){const Nt=_t;let Rt=_t-1;Rt<0&&(Rt=ot.length-1);for(let B=0,D=v+k*2;B<D;B++){const et=tt*B,bt=tt*(B+1),at=dt+Nt+et,gt=dt+Rt+et,Et=dt+Rt+bt,At=dt+Nt+bt;vt(at,gt,Et,At)}}}function Xt(ot,dt,_t){g.push(ot),g.push(dt),g.push(_t)}function It(ot,dt,_t){Ft(ot),Ft(dt),Ft(_t);const Nt=a.length/3,Rt=E.generateTopUV(s,a,Nt-3,Nt-2,Nt-1);Jt(Rt[0]),Jt(Rt[1]),Jt(Rt[2])}function vt(ot,dt,_t,Nt){Ft(ot),Ft(dt),Ft(Nt),Ft(dt),Ft(_t),Ft(Nt);const Rt=a.length/3,B=E.generateSideWallUV(s,a,Rt-6,Rt-3,Rt-2,Rt-1);Jt(B[0]),Jt(B[1]),Jt(B[3]),Jt(B[1]),Jt(B[2]),Jt(B[3])}function Ft(ot){a.push(g[ot*3+0]),a.push(g[ot*3+1]),a.push(g[ot*3+2])}function Jt(ot){h.push(ot.x),h.push(ot.y)}}}toJSON(){const t=super.toJSON(),e=this.parameters.shapes,s=this.parameters.options;return aS(e,s,t)}static fromJSON(t,e){const s=[];for(let h=0,d=t.shapes.length;h<d;h++){const p=e[t.shapes[h]];s.push(p)}const a=t.options.extrudePath;return a!==void 0&&(t.options.extrudePath=new Wf[a.type]().fromJSON(a)),new Ts(s,t.options)}}const oS={generateTopUV:function(c,t,e,s,a){const h=t[e*3],d=t[e*3+1],p=t[s*3],g=t[s*3+1],_=t[a*3],v=t[a*3+1];return[new Mt(h,d),new Mt(p,g),new Mt(_,v)]},generateSideWallUV:function(c,t,e,s,a,h){const d=t[e*3],p=t[e*3+1],g=t[e*3+2],_=t[s*3],v=t[s*3+1],b=t[s*3+2],M=t[a*3],S=t[a*3+1],L=t[a*3+2],C=t[h*3],k=t[h*3+1],T=t[h*3+2];return Math.abs(p-v)<Math.abs(d-_)?[new Mt(d,1-g),new Mt(_,1-b),new Mt(M,1-L),new Mt(C,1-T)]:[new Mt(p,1-g),new Mt(v,1-b),new Mt(S,1-L),new Mt(k,1-T)]}};function aS(c,t,e){if(e.shapes=[],Array.isArray(c))for(let s=0,a=c.length;s<a;s++){const h=c[s];e.shapes.push(h.uuid)}else e.shapes.push(c.uuid);return t.extrudePath!==void 0&&(e.options.extrudePath=t.extrudePath.toJSON()),e}class wc extends ve{constructor(t=new Er([new Mt(0,.5),new Mt(-.5,-.5),new Mt(.5,-.5)]),e=12){super();this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const s=[],a=[],h=[],d=[];let p=0,g=0;if(Array.isArray(t)===!1)_(t);else for(let v=0;v<t.length;v++)_(t[v]),this.addGroup(p,g,v),p+=g,g=0;this.setIndex(s),this.setAttribute("position",new Ae(a,3)),this.setAttribute("normal",new Ae(h,3)),this.setAttribute("uv",new Ae(d,2));function _(v){const b=a.length/3,M=v.extractPoints(e);let S=M.shape;const L=M.holes;gi.isClockWise(S)===!1&&(S=S.reverse());for(let k=0,T=L.length;k<T;k++){const E=L[k];gi.isClockWise(E)===!0&&(L[k]=E.reverse())}const C=gi.triangulateShape(S,L);for(let k=0,T=L.length;k<T;k++){const E=L[k];S=S.concat(E)}for(let k=0,T=S.length;k<T;k++){const E=S[k];a.push(E.x,E.y,0),h.push(0,0,1),d.push(E.x,E.y)}for(let k=0,T=C.length;k<T;k++){const E=C[k],z=E[0]+b,I=E[1]+b,V=E[2]+b;s.push(z,I,V),g+=3}}}toJSON(){const t=super.toJSON(),e=this.parameters.shapes;return lS(e,t)}static fromJSON(t,e){const s=[];for(let a=0,h=t.shapes.length;a<h;a++){const d=e[t.shapes[a]];s.push(d)}return new wc(s,t.curveSegments)}}function lS(c,t){if(t.shapes=[],Array.isArray(c))for(let e=0,s=c.length;e<s;e++){const a=c[e];t.shapes.push(a.uuid)}else t.shapes.push(c.uuid);return t}class Zf extends ve{constructor(t=1,e=32,s=16,a=0,h=Math.PI*2,d=0,p=Math.PI){super();this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:s,phiStart:a,phiLength:h,thetaStart:d,thetaLength:p},e=Math.max(3,Math.floor(e)),s=Math.max(2,Math.floor(s));const g=Math.min(d+p,Math.PI);let _=0;const v=[],b=new N,M=new N,S=[],L=[],C=[],k=[];for(let T=0;T<=s;T++){const E=[],z=T/s;let I=0;T==0&&d==0?I=.5/e:T==s&&g==Math.PI&&(I=-.5/e);for(let V=0;V<=e;V++){const G=V/e;b.x=-t*Math.cos(a+G*h)*Math.sin(d+z*p),b.y=t*Math.cos(d+z*p),b.z=t*Math.sin(a+G*h)*Math.sin(d+z*p),L.push(b.x,b.y,b.z),M.copy(b).normalize(),C.push(M.x,M.y,M.z),k.push(G+I,1-z),E.push(_++)}v.push(E)}for(let T=0;T<s;T++)for(let E=0;E<e;E++){const z=v[T][E+1],I=v[T][E],V=v[T+1][E],G=v[T+1][E+1];(T!==0||d>0)&&S.push(z,I,G),(T!==s-1||g<Math.PI)&&S.push(I,V,G)}this.setIndex(S),this.setAttribute("position",new Ae(L,3)),this.setAttribute("normal",new Ae(C,3)),this.setAttribute("uv",new Ae(k,2))}static fromJSON(t){return new Zf(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class cS extends Ye{constructor(t){super();this.type="ShadowMaterial",this.color=new Ht(0),this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this}}cS.prototype.isShadowMaterial=!0;class Jf extends Ye{constructor(t){super();this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Ht(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ht(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zi,this.normalScale=new Mt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}Jf.prototype.isMeshStandardMaterial=!0;class uS extends Jf{constructor(t){super();this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Mt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return cn(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.sheenTint=new Ht(0),this.sheenRoughness=1,this.transmissionMap=null,this.thickness=.01,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationTint=new Ht(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularTint=new Ht(1,1,1),this.specularTintMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(t)}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.sheen=t.sheen,this.sheenTint.copy(t.sheenTint),this.sheenRoughness=t.sheenRoughness,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationTint.copy(t.attenuationTint),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularTint.copy(t.specularTint),this.specularTintMap=t.specularTintMap,this}}uS.prototype.isMeshPhysicalMaterial=!0;class hS extends Ye{constructor(t){super();this.type="MeshPhongMaterial",this.color=new Ht(16777215),this.specular=new Ht(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ht(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zi,this.normalScale=new Mt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=go,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}hS.prototype.isMeshPhongMaterial=!0;class dS extends Ye{constructor(t){super();this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Ht(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ht(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zi,this.normalScale=new Mt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}dS.prototype.isMeshToonMaterial=!0;class fS extends Ye{constructor(t){super();this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zi,this.normalScale=new Mt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}fS.prototype.isMeshNormalMaterial=!0;class pS extends Ye{constructor(t){super();this.type="MeshLambertMaterial",this.color=new Ht(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ht(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=go,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}pS.prototype.isMeshLambertMaterial=!0;class mS extends Ye{constructor(t){super();this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Ht(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zi,this.normalScale=new Mt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this}}mS.prototype.isMeshMatcapMaterial=!0;class gS extends wr{constructor(t){super();this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}gS.prototype.isLineDashedMaterial=!0;const we={arraySlice:function(c,t,e){return we.isTypedArray(c)?new c.constructor(c.subarray(t,e!==void 0?e:c.length)):c.slice(t,e)},convertArray:function(c,t,e){return!c||!e&&c.constructor===t?c:typeof t.BYTES_PER_ELEMENT=="number"?new t(c):Array.prototype.slice.call(c)},isTypedArray:function(c){return ArrayBuffer.isView(c)&&!(c instanceof DataView)},getKeyframeOrder:function(c){function t(a,h){return c[a]-c[h]}const e=c.length,s=new Array(e);for(let a=0;a!==e;++a)s[a]=a;return s.sort(t),s},sortedArray:function(c,t,e){const s=c.length,a=new c.constructor(s);for(let h=0,d=0;d!==s;++h){const p=e[h]*t;for(let g=0;g!==t;++g)a[d++]=c[p+g]}return a},flattenJSON:function(c,t,e,s){let a=1,h=c[0];for(;h!==void 0&&h[s]===void 0;)h=c[a++];if(h===void 0)return;let d=h[s];if(d!==void 0)if(Array.isArray(d))do d=h[s],d!==void 0&&(t.push(h.time),e.push.apply(e,d)),h=c[a++];while(h!==void 0);else if(d.toArray!==void 0)do d=h[s],d!==void 0&&(t.push(h.time),d.toArray(e,e.length)),h=c[a++];while(h!==void 0);else do d=h[s],d!==void 0&&(t.push(h.time),e.push(d)),h=c[a++];while(h!==void 0)},subclip:function(c,t,e,s,a=30){const h=c.clone();h.name=t;const d=[];for(let g=0;g<h.tracks.length;++g){const _=h.tracks[g],v=_.getValueSize(),b=[],M=[];for(let S=0;S<_.times.length;++S){const L=_.times[S]*a;if(!(L<e||L>=s)){b.push(_.times[S]);for(let C=0;C<v;++C)M.push(_.values[S*v+C])}}b.length!==0&&(_.times=we.convertArray(b,_.times.constructor),_.values=we.convertArray(M,_.values.constructor),d.push(_))}h.tracks=d;let p=1/0;for(let g=0;g<h.tracks.length;++g)p>h.tracks[g].times[0]&&(p=h.tracks[g].times[0]);for(let g=0;g<h.tracks.length;++g)h.tracks[g].shift(-1*p);return h.resetDuration(),h},makeClipAdditive:function(c,t=0,e=c,s=30){s<=0&&(s=30);const a=e.tracks.length,h=t/s;for(let d=0;d<a;++d){const p=e.tracks[d],g=p.ValueTypeName;if(g==="bool"||g==="string")continue;const _=c.tracks.find(function(T){return T.name===p.name&&T.ValueTypeName===g});if(_===void 0)continue;let v=0;const b=p.getValueSize();p.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(v=b/3);let M=0;const S=_.getValueSize();_.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(M=S/3);const L=p.times.length-1;let C;if(h<=p.times[0]){const T=v,E=b-v;C=we.arraySlice(p.values,T,E)}else if(h>=p.times[L]){const T=L*b+v,E=T+b-v;C=we.arraySlice(p.values,T,E)}else{const T=p.createInterpolant(),E=v,z=b-v;T.evaluate(h),C=we.arraySlice(T.resultBuffer,E,z)}g==="quaternion"&&new sn().fromArray(C).normalize().conjugate().toArray(C);const k=_.times.length;for(let T=0;T<k;++T){const E=T*S+M;if(g==="quaternion")sn.multiplyQuaternionsFlat(_.values,E,C,0,_.values,E);else{const z=S-M*2;for(let I=0;I<z;++I)_.values[E+I]-=C[I]}}}return c.blendMode=hd,c}};class xi{constructor(t,e,s,a){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=a!==void 0?a:new e.constructor(s),this.sampleValues=e,this.valueSize=s,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let s=this._cachedIndex,a=e[s],h=e[s-1];t:{e:{let d;n:{i:if(!(t<a)){for(let p=s+2;;){if(a===void 0){if(t<h)break i;return s=e.length,this._cachedIndex=s,this.afterEnd_(s-1,t,h)}if(s===p)break;if(h=a,a=e[++s],t<a)break e}d=e.length;break n}if(!(t>=h)){const p=e[1];t<p&&(s=2,h=p);for(let g=s-2;;){if(h===void 0)return this._cachedIndex=0,this.beforeStart_(0,t,a);if(s===g)break;if(a=h,h=e[--s-1],t>=h)break e}d=s,s=0;break n}break t}for(;s<d;){const p=s+d>>>1;t<e[p]?d=p:s=p+1}if(a=e[s],h=e[s-1],h===void 0)return this._cachedIndex=0,this.beforeStart_(0,t,a);if(a===void 0)return s=e.length,this._cachedIndex=s,this.afterEnd_(s-1,h,t)}this._cachedIndex=s,this.intervalChanged_(s,h,a)}return this.interpolate_(s,h,t,a)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,s=this.sampleValues,a=this.valueSize,h=t*a;for(let d=0;d!==a;++d)e[d]=s[h+d];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}xi.prototype.beforeStart_=xi.prototype.copySampleValue_;xi.prototype.afterEnd_=xi.prototype.copySampleValue_;class xS extends xi{constructor(t,e,s,a){super(t,e,s,a);this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Yi,endingEnd:Yi}}intervalChanged_(t,e,s){const a=this.parameterPositions;let h=t-2,d=t+1,p=a[h],g=a[d];if(p===void 0)switch(this.getSettings_().endingStart){case $i:h=t,p=2*e-s;break;case To:h=a.length-2,p=e+a[h]-a[h+1];break;default:h=t,p=s}if(g===void 0)switch(this.getSettings_().endingEnd){case $i:d=t,g=2*s-e;break;case To:d=1,g=s+a[1]-a[0];break;default:d=t-1,g=e}const _=(s-e)*.5,v=this.valueSize;this._weightPrev=_/(e-p),this._weightNext=_/(g-s),this._offsetPrev=h*v,this._offsetNext=d*v}interpolate_(t,e,s,a){const h=this.resultBuffer,d=this.sampleValues,p=this.valueSize,g=t*p,_=g-p,v=this._offsetPrev,b=this._offsetNext,M=this._weightPrev,S=this._weightNext,L=(s-e)/(a-e),C=L*L,k=C*L,T=-M*k+2*M*C-M*L,E=(1+M)*k+(-1.5-2*M)*C+(-.5+M)*L+1,z=(-1-S)*k+(1.5+S)*C+.5*L,I=S*k-S*C;for(let V=0;V!==p;++V)h[V]=T*d[v+V]+E*d[_+V]+z*d[g+V]+I*d[b+V];return h}}class Kf extends xi{constructor(t,e,s,a){super(t,e,s,a)}interpolate_(t,e,s,a){const h=this.resultBuffer,d=this.sampleValues,p=this.valueSize,g=t*p,_=g-p,v=(s-e)/(a-e),b=1-v;for(let M=0;M!==p;++M)h[M]=d[_+M]*b+d[g+M]*v;return h}}class _S extends xi{constructor(t,e,s,a){super(t,e,s,a)}interpolate_(t){return this.copySampleValue_(t-1)}}class Bn{constructor(t,e,s,a){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=we.convertArray(e,this.TimeBufferType),this.values=we.convertArray(s,this.ValueBufferType),this.setInterpolation(a||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let s;if(e.toJSON!==this.toJSON)s=e.toJSON(t);else{s={name:t.name,times:we.convertArray(t.times,Array),values:we.convertArray(t.values,Array)};const a=t.getInterpolation();a!==t.DefaultInterpolation&&(s.interpolation=a)}return s.type=t.ValueTypeName,s}InterpolantFactoryMethodDiscrete(t){return new _S(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new Kf(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new xS(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case wo:e=this.InterpolantFactoryMethodDiscrete;break;case So:e=this.InterpolantFactoryMethodLinear;break;case xl:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const s="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(s);return console.warn("THREE.KeyframeTrack:",s),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return wo;case this.InterpolantFactoryMethodLinear:return So;case this.InterpolantFactoryMethodSmooth:return xl}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let s=0,a=e.length;s!==a;++s)e[s]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let s=0,a=e.length;s!==a;++s)e[s]*=t}return this}trim(t,e){const s=this.times,a=s.length;let h=0,d=a-1;for(;h!==a&&s[h]<t;)++h;for(;d!==-1&&s[d]>e;)--d;if(++d,h!==0||d!==a){h>=d&&(d=Math.max(d,1),h=d-1);const p=this.getValueSize();this.times=we.arraySlice(s,h,d),this.values=we.arraySlice(this.values,h*p,d*p)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const s=this.times,a=this.values,h=s.length;h===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let d=null;for(let p=0;p!==h;p++){const g=s[p];if(typeof g=="number"&&isNaN(g)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,p,g),t=!1;break}if(d!==null&&d>g){console.error("THREE.KeyframeTrack: Out of order keys.",this,p,g,d),t=!1;break}d=g}if(a!==void 0&&we.isTypedArray(a))for(let p=0,g=a.length;p!==g;++p){const _=a[p];if(isNaN(_)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,p,_),t=!1;break}}return t}optimize(){const t=we.arraySlice(this.times),e=we.arraySlice(this.values),s=this.getValueSize(),a=this.getInterpolation()===xl,h=t.length-1;let d=1;for(let p=1;p<h;++p){let g=!1;const _=t[p],v=t[p+1];if(_!==v&&(p!==1||_!==t[0]))if(a)g=!0;else{const b=p*s,M=b-s,S=b+s;for(let L=0;L!==s;++L){const C=e[b+L];if(C!==e[M+L]||C!==e[S+L]){g=!0;break}}}if(g){if(p!==d){t[d]=t[p];const b=p*s,M=d*s;for(let S=0;S!==s;++S)e[M+S]=e[b+S]}++d}}if(h>0){t[d]=t[h];for(let p=h*s,g=d*s,_=0;_!==s;++_)e[g+_]=e[p+_];++d}return d!==t.length?(this.times=we.arraySlice(t,0,d),this.values=we.arraySlice(e,0,d*s)):(this.times=t,this.values=e),this}clone(){const t=we.arraySlice(this.times,0),e=we.arraySlice(this.values,0),s=this.constructor,a=new s(this.name,t,e);return a.createInterpolant=this.createInterpolant,a}}Bn.prototype.TimeBufferType=Float32Array;Bn.prototype.ValueBufferType=Float32Array;Bn.prototype.DefaultInterpolation=So;class Es extends Bn{}Es.prototype.ValueTypeName="bool";Es.prototype.ValueBufferType=Array;Es.prototype.DefaultInterpolation=wo;Es.prototype.InterpolantFactoryMethodLinear=void 0;Es.prototype.InterpolantFactoryMethodSmooth=void 0;class Qf extends Bn{}Qf.prototype.ValueTypeName="color";class ca extends Bn{}ca.prototype.ValueTypeName="number";class yS extends xi{constructor(t,e,s,a){super(t,e,s,a)}interpolate_(t,e,s,a){const h=this.resultBuffer,d=this.sampleValues,p=this.valueSize,g=(s-e)/(a-e);let _=t*p;for(let v=_+p;_!==v;_+=4)sn.slerpFlat(h,0,d,_-p,d,_,g);return h}}class Rr extends Bn{InterpolantFactoryMethodLinear(t){return new yS(this.times,this.values,this.getValueSize(),t)}}Rr.prototype.ValueTypeName="quaternion";Rr.prototype.DefaultInterpolation=So;Rr.prototype.InterpolantFactoryMethodSmooth=void 0;class As extends Bn{}As.prototype.ValueTypeName="string";As.prototype.ValueBufferType=Array;As.prototype.DefaultInterpolation=wo;As.prototype.InterpolantFactoryMethodLinear=void 0;As.prototype.InterpolantFactoryMethodSmooth=void 0;class ua extends Bn{}ua.prototype.ValueTypeName="vector";class tp{constructor(t,e=-1,s,a=_l){this.name=t,this.tracks=s,this.duration=e,this.blendMode=a,this.uuid=In(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],s=t.tracks,a=1/(t.fps||1);for(let d=0,p=s.length;d!==p;++d)e.push(bS(s[d]).scale(a));const h=new this(t.name,t.duration,e,t.blendMode);return h.uuid=t.uuid,h}static toJSON(t){const e=[],s=t.tracks,a={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let h=0,d=s.length;h!==d;++h)e.push(Bn.toJSON(s[h]));return a}static CreateFromMorphTargetSequence(t,e,s,a){const h=e.length,d=[];for(let p=0;p<h;p++){let g=[],_=[];g.push((p+h-1)%h,p,(p+1)%h),_.push(0,1,0);const v=we.getKeyframeOrder(g);g=we.sortedArray(g,1,v),_=we.sortedArray(_,1,v),!a&&g[0]===0&&(g.push(h),_.push(_[0])),d.push(new ca(".morphTargetInfluences["+e[p].name+"]",g,_).scale(1/s))}return new this(t,-1,d)}static findByName(t,e){let s=t;if(!Array.isArray(t)){const a=t;s=a.geometry&&a.geometry.animations||a.animations}for(let a=0;a<s.length;a++)if(s[a].name===e)return s[a];return null}static CreateClipsFromMorphTargetSequences(t,e,s){const a={},h=/^([\w-]*?)([\d]+)$/;for(let p=0,g=t.length;p<g;p++){const _=t[p],v=_.name.match(h);if(v&&v.length>1){const b=v[1];let M=a[b];M||(a[b]=M=[]),M.push(_)}}const d=[];for(const p in a)d.push(this.CreateFromMorphTargetSequence(p,a[p],e,s));return d}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const s=function(b,M,S,L,C){if(S.length!==0){const k=[],T=[];we.flattenJSON(S,k,T,L),k.length!==0&&C.push(new b(M,k,T))}},a=[],h=t.name||"default",d=t.fps||30,p=t.blendMode;let g=t.length||-1;const _=t.hierarchy||[];for(let b=0;b<_.length;b++){const M=_[b].keys;if(!(!M||M.length===0))if(M[0].morphTargets){const S={};let L;for(L=0;L<M.length;L++)if(M[L].morphTargets)for(let C=0;C<M[L].morphTargets.length;C++)S[M[L].morphTargets[C]]=-1;for(const C in S){const k=[],T=[];for(let E=0;E!==M[L].morphTargets.length;++E){const z=M[L];k.push(z.time),T.push(z.morphTarget===C?1:0)}a.push(new ca(".morphTargetInfluence["+C+"]",k,T))}g=S.length*(d||1)}else{const S=".bones["+e[b].name+"]";s(ua,S+".position",M,"pos",a),s(Rr,S+".quaternion",M,"rot",a),s(ua,S+".scale",M,"scl",a)}}return a.length===0?null:new this(h,g,a,p)}resetDuration(){const t=this.tracks;let e=0;for(let s=0,a=t.length;s!==a;++s){const h=this.tracks[s];e=Math.max(e,h.times[h.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function vS(c){switch(c.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return ca;case"vector":case"vector2":case"vector3":case"vector4":return ua;case"color":return Qf;case"quaternion":return Rr;case"bool":case"boolean":return Es;case"string":return As}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+c)}function bS(c){if(c.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=vS(c.type);if(c.times===void 0){const e=[],s=[];we.flattenJSON(c.keys,e,s,"value"),c.times=e,c.values=s}return t.parse!==void 0?t.parse(c):new t(c.name,c.times,c.values,c.interpolation)}const Ls={enabled:!1,files:{},add:function(c,t){this.enabled!==!1&&(this.files[c]=t)},get:function(c){if(this.enabled!==!1)return this.files[c]},remove:function(c){delete this.files[c]},clear:function(){this.files={}}};class MS{constructor(t,e,s){const a=this;let h=!1,d=0,p=0,g;const _=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=s,this.itemStart=function(v){p++,h===!1&&a.onStart!==void 0&&a.onStart(v,d,p),h=!0},this.itemEnd=function(v){d++,a.onProgress!==void 0&&a.onProgress(v,d,p),d===p&&(h=!1,a.onLoad!==void 0&&a.onLoad())},this.itemError=function(v){a.onError!==void 0&&a.onError(v)},this.resolveURL=function(v){return g?g(v):v},this.setURLModifier=function(v){return g=v,this},this.addHandler=function(v,b){return _.push(v,b),this},this.removeHandler=function(v){const b=_.indexOf(v);return b!==-1&&_.splice(b,2),this},this.getHandler=function(v){for(let b=0,M=_.length;b<M;b+=2){const S=_[b],L=_[b+1];if(S.global&&(S.lastIndex=0),S.test(v))return L}return null}}}const wS=new MS;class _i{constructor(t){this.manager=t!==void 0?t:wS,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const s=this;return new Promise(function(a,h){s.load(t,a,e,h)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const En={};class SS extends _i{constructor(t){super(t)}load(t,e,s,a){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const h=this,d=Ls.get(t);if(d!==void 0)return h.manager.itemStart(t),setTimeout(function(){e&&e(d),h.manager.itemEnd(t)},0),d;if(En[t]!==void 0){En[t].push({onLoad:e,onProgress:s,onError:a});return}const p=/^data:(.*?)(;base64)?,(.*)$/,g=t.match(p);let _;if(g){const v=g[1],b=!!g[2];let M=g[3];M=decodeURIComponent(M),b&&(M=atob(M));try{let S;const L=(this.responseType||"").toLowerCase();switch(L){case"arraybuffer":case"blob":const C=new Uint8Array(M.length);for(let T=0;T<M.length;T++)C[T]=M.charCodeAt(T);L==="blob"?S=new Blob([C.buffer],{type:v}):S=C.buffer;break;case"document":S=new DOMParser().parseFromString(M,v);break;case"json":S=JSON.parse(M);break;default:S=M;break}setTimeout(function(){e&&e(S),h.manager.itemEnd(t)},0)}catch(S){setTimeout(function(){a&&a(S),h.manager.itemError(t),h.manager.itemEnd(t)},0)}}else{En[t]=[],En[t].push({onLoad:e,onProgress:s,onError:a}),_=new XMLHttpRequest,_.open("GET",t,!0),_.addEventListener("load",function(v){const b=this.response,M=En[t];if(delete En[t],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),Ls.add(t,b);for(let S=0,L=M.length;S<L;S++){const C=M[S];C.onLoad&&C.onLoad(b)}h.manager.itemEnd(t)}else{for(let S=0,L=M.length;S<L;S++){const C=M[S];C.onError&&C.onError(v)}h.manager.itemError(t),h.manager.itemEnd(t)}},!1),_.addEventListener("progress",function(v){const b=En[t];for(let M=0,S=b.length;M<S;M++){const L=b[M];L.onProgress&&L.onProgress(v)}},!1),_.addEventListener("error",function(v){const b=En[t];delete En[t];for(let M=0,S=b.length;M<S;M++){const L=b[M];L.onError&&L.onError(v)}h.manager.itemError(t),h.manager.itemEnd(t)},!1),_.addEventListener("abort",function(v){const b=En[t];delete En[t];for(let M=0,S=b.length;M<S;M++){const L=b[M];L.onError&&L.onError(v)}h.manager.itemError(t),h.manager.itemEnd(t)},!1),this.responseType!==void 0&&(_.responseType=this.responseType),this.withCredentials!==void 0&&(_.withCredentials=this.withCredentials),_.overrideMimeType&&_.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const v in this.requestHeader)_.setRequestHeader(v,this.requestHeader[v]);_.send(null)}return h.manager.itemStart(t),_}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class ep extends _i{constructor(t){super(t)}load(t,e,s,a){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const h=this,d=Ls.get(t);if(d!==void 0)return h.manager.itemStart(t),setTimeout(function(){e&&e(d),h.manager.itemEnd(t)},0),d;const p=Ao("img");function g(){p.removeEventListener("load",g,!1),p.removeEventListener("error",_,!1),Ls.add(t,this),e&&e(this),h.manager.itemEnd(t)}function _(v){p.removeEventListener("load",g,!1),p.removeEventListener("error",_,!1),a&&a(v),h.manager.itemError(t),h.manager.itemEnd(t)}return p.addEventListener("load",g,!1),p.addEventListener("error",_,!1),t.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(p.crossOrigin=this.crossOrigin),h.manager.itemStart(t),p.src=t,p}}class TS extends _i{constructor(t){super(t)}load(t,e,s,a){const h=new Go,d=new ep(this.manager);d.setCrossOrigin(this.crossOrigin),d.setPath(this.path);let p=0;function g(_){d.load(t[_],function(v){h.images[_]=v,p++,p===6&&(h.needsUpdate=!0,e&&e(h))},void 0,a)}for(let _=0;_<t.length;++_)g(_);return h}}class ES extends _i{constructor(t){super(t)}load(t,e,s,a){const h=new Xe,d=new ep(this.manager);return d.setCrossOrigin(this.crossOrigin),d.setPath(this.path),d.load(t,function(p){h.image=p,h.needsUpdate=!0,e!==void 0&&e(h)},s,a),h}}class zn extends de{constructor(t,e=1){super();this.type="Light",this.color=new Ht(t),this.intensity=e}dispose(){}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}zn.prototype.isLight=!0;class AS extends zn{constructor(t,e,s){super(t,s);this.type="HemisphereLight",this.position.copy(de.DefaultUp),this.updateMatrix(),this.groundColor=new Ht(e)}copy(t){return zn.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}AS.prototype.isHemisphereLight=!0;const np=new jt,ip=new N,sp=new N;class Sc{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Mt(512,512),this.map=null,this.mapPass=null,this.matrix=new jt,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new jo,this._frameExtents=new Mt(1,1),this._viewportCount=1,this._viewports=[new ge(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,s=this.matrix;ip.setFromMatrixPosition(t.matrixWorld),e.position.copy(ip),sp.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(sp),e.updateMatrixWorld(),np.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(np),s.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),s.multiply(e.projectionMatrix),s.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class rp extends Sc{constructor(){super(new on(50,1,.5,500));this.focus=1}updateMatrices(t){const e=this.camera,s=wl*2*t.angle*this.focus,a=this.mapSize.width/this.mapSize.height,h=t.distance||e.far;(s!==e.fov||a!==e.aspect||h!==e.far)&&(e.fov=s,e.aspect=a,e.far=h,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}rp.prototype.isSpotLightShadow=!0;class LS extends zn{constructor(t,e,s=0,a=Math.PI/3,h=0,d=1){super(t,e);this.type="SpotLight",this.position.copy(de.DefaultUp),this.updateMatrix(),this.target=new de,this.distance=s,this.angle=a,this.penumbra=h,this.decay=d,this.shadow=new rp}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}LS.prototype.isSpotLight=!0;const op=new jt,Pr=new N,Tc=new N;class ap extends Sc{constructor(){super(new on(90,1,.5,500));this._frameExtents=new Mt(4,2),this._viewportCount=6,this._viewports=[new ge(2,1,1,1),new ge(0,1,1,1),new ge(3,1,1,1),new ge(1,1,1,1),new ge(3,0,1,1),new ge(1,0,1,1)],this._cubeDirections=[new N(1,0,0),new N(-1,0,0),new N(0,0,1),new N(0,0,-1),new N(0,1,0),new N(0,-1,0)],this._cubeUps=[new N(0,1,0),new N(0,1,0),new N(0,1,0),new N(0,1,0),new N(0,0,1),new N(0,0,-1)]}updateMatrices(t,e=0){const s=this.camera,a=this.matrix,h=t.distance||s.far;h!==s.far&&(s.far=h,s.updateProjectionMatrix()),Pr.setFromMatrixPosition(t.matrixWorld),s.position.copy(Pr),Tc.copy(s.position),Tc.add(this._cubeDirections[e]),s.up.copy(this._cubeUps[e]),s.lookAt(Tc),s.updateMatrixWorld(),a.makeTranslation(-Pr.x,-Pr.y,-Pr.z),op.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),this._frustum.setFromProjectionMatrix(op)}}ap.prototype.isPointLightShadow=!0;class CS extends zn{constructor(t,e,s=0,a=1){super(t,e);this.type="PointLight",this.distance=s,this.decay=a,this.shadow=new ap}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}CS.prototype.isPointLight=!0;class lp extends Sc{constructor(){super(new Kl(-5,5,5,-5,.5,500))}}lp.prototype.isDirectionalLightShadow=!0;class RS extends zn{constructor(t,e){super(t,e);this.type="DirectionalLight",this.position.copy(de.DefaultUp),this.updateMatrix(),this.target=new de,this.shadow=new lp}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}RS.prototype.isDirectionalLight=!0;class PS extends zn{constructor(t,e){super(t,e);this.type="AmbientLight"}}PS.prototype.isAmbientLight=!0;class DS extends zn{constructor(t,e,s=10,a=10){super(t,e);this.type="RectAreaLight",this.width=s,this.height=a}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}DS.prototype.isRectAreaLight=!0;class cp{constructor(){this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new N)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const s=t.x,a=t.y,h=t.z,d=this.coefficients;return e.copy(d[0]).multiplyScalar(.282095),e.addScaledVector(d[1],.488603*a),e.addScaledVector(d[2],.488603*h),e.addScaledVector(d[3],.488603*s),e.addScaledVector(d[4],1.092548*(s*a)),e.addScaledVector(d[5],1.092548*(a*h)),e.addScaledVector(d[6],.315392*(3*h*h-1)),e.addScaledVector(d[7],1.092548*(s*h)),e.addScaledVector(d[8],.546274*(s*s-a*a)),e}getIrradianceAt(t,e){const s=t.x,a=t.y,h=t.z,d=this.coefficients;return e.copy(d[0]).multiplyScalar(.886227),e.addScaledVector(d[1],2*.511664*a),e.addScaledVector(d[2],2*.511664*h),e.addScaledVector(d[3],2*.511664*s),e.addScaledVector(d[4],2*.429043*s*a),e.addScaledVector(d[5],2*.429043*a*h),e.addScaledVector(d[6],.743125*h*h-.247708),e.addScaledVector(d[7],2*.429043*s*h),e.addScaledVector(d[8],.429043*(s*s-a*a)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let s=0;s<9;s++)this.coefficients[s].addScaledVector(t.coefficients[s],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let s=0;s<9;s++)this.coefficients[s].lerp(t.coefficients[s],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(t,e=0){const s=this.coefficients;for(let a=0;a<9;a++)s[a].fromArray(t,e+a*3);return this}toArray(t=[],e=0){const s=this.coefficients;for(let a=0;a<9;a++)s[a].toArray(t,e+a*3);return t}static getBasisAt(t,e){const s=t.x,a=t.y,h=t.z;e[0]=.282095,e[1]=.488603*a,e[2]=.488603*h,e[3]=.488603*s,e[4]=1.092548*s*a,e[5]=1.092548*a*h,e[6]=.315392*(3*h*h-1),e[7]=1.092548*s*h,e[8]=.546274*(s*s-a*a)}}cp.prototype.isSphericalHarmonics3=!0;class Ec extends zn{constructor(t=new cp,e=1){super(void 0,e);this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}Ec.prototype.isLightProbe=!0;class IS{static decodeText(t){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(t);let e="";for(let s=0,a=t.length;s<a;s++)e+=String.fromCharCode(t[s]);try{return decodeURIComponent(escape(e))}catch(s){return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return e===-1?"./":t.substr(0,e+1)}}class FS extends ve{constructor(){super();this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}FS.prototype.isInstancedBufferGeometry=!0;class kS extends _i{constructor(t){super(t);typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,s,a){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const h=this,d=Ls.get(t);if(d!==void 0)return h.manager.itemStart(t),setTimeout(function(){e&&e(d),h.manager.itemEnd(t)},0),d;const p={};p.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",p.headers=this.requestHeader,fetch(t,p).then(function(g){return g.blob()}).then(function(g){return createImageBitmap(g,Object.assign(h.options,{colorSpaceConversion:"none"}))}).then(function(g){Ls.add(t,g),e&&e(g),h.manager.itemEnd(t)}).catch(function(g){a&&a(g),h.manager.itemError(t),h.manager.itemEnd(t)}),h.manager.itemStart(t)}}kS.prototype.isImageBitmapLoader=!0;let ha;const OS={getContext:function(){return ha===void 0&&(ha=new(window.AudioContext||window.webkitAudioContext)),ha},setContext:function(c){ha=c}};class BS extends _i{constructor(t){super(t)}load(t,e,s,a){const h=this,d=new SS(this.manager);d.setResponseType("arraybuffer"),d.setPath(this.path),d.setRequestHeader(this.requestHeader),d.setWithCredentials(this.withCredentials),d.load(t,function(p){try{const g=p.slice(0);OS.getContext().decodeAudioData(g,function(v){e(v)})}catch(g){a?a(g):console.error(g),h.manager.itemError(t)}},s,a)}}class zS extends Ec{constructor(t,e,s=1){super(void 0,s);const a=new Ht().set(t),h=new Ht().set(e),d=new N(a.r,a.g,a.b),p=new N(h.r,h.g,h.b),g=Math.sqrt(Math.PI),_=g*Math.sqrt(.75);this.sh.coefficients[0].copy(d).add(p).multiplyScalar(g),this.sh.coefficients[1].copy(d).sub(p).multiplyScalar(_)}}zS.prototype.isHemisphereLightProbe=!0;class NS extends Ec{constructor(t,e=1){super(void 0,e);const s=new Ht().set(t);this.sh.coefficients[0].set(s.r,s.g,s.b).multiplyScalar(2*Math.sqrt(Math.PI))}}NS.prototype.isAmbientLightProbe=!0;class VS extends de{constructor(t){super();this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),this._connected===!0?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=t,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=t,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}class US{constructor(t,e,s){this.binding=t,this.valueSize=s;let a,h,d;switch(e){case"quaternion":a=this._slerp,h=this._slerpAdditive,d=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(s*6),this._workIndex=5;break;case"string":case"bool":a=this._select,h=this._select,d=this._setAdditiveIdentityOther,this.buffer=new Array(s*5);break;default:a=this._lerp,h=this._lerpAdditive,d=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(s*5)}this._mixBufferRegion=a,this._mixBufferRegionAdditive=h,this._setIdentity=d,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const s=this.buffer,a=this.valueSize,h=t*a+a;let d=this.cumulativeWeight;if(d===0){for(let p=0;p!==a;++p)s[h+p]=s[p];d=e}else{d+=e;const p=e/d;this._mixBufferRegion(s,h,0,p,a)}this.cumulativeWeight=d}accumulateAdditive(t){const e=this.buffer,s=this.valueSize,a=s*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,a,0,t,s),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,s=this.buffer,a=t*e+e,h=this.cumulativeWeight,d=this.cumulativeWeightAdditive,p=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,h<1){const g=e*this._origIndex;this._mixBufferRegion(s,a,g,1-h,e)}d>0&&this._mixBufferRegionAdditive(s,a,this._addIndex*e,1,e);for(let g=e,_=e+e;g!==_;++g)if(s[g]!==s[g+e]){p.setValue(s,a);break}}saveOriginalState(){const t=this.binding,e=this.buffer,s=this.valueSize,a=s*this._origIndex;t.getValue(e,a);for(let h=s,d=a;h!==d;++h)e[h]=e[a+h%s];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=this.valueSize*3;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let s=t;s<e;s++)this.buffer[s]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let s=0;s<this.valueSize;s++)this.buffer[e+s]=this.buffer[t+s]}_select(t,e,s,a,h){if(a>=.5)for(let d=0;d!==h;++d)t[e+d]=t[s+d]}_slerp(t,e,s,a){sn.slerpFlat(t,e,t,e,t,s,a)}_slerpAdditive(t,e,s,a,h){const d=this._workIndex*h;sn.multiplyQuaternionsFlat(t,d,t,e,t,s),sn.slerpFlat(t,e,t,e,t,d,a)}_lerp(t,e,s,a,h){const d=1-a;for(let p=0;p!==h;++p){const g=e+p;t[g]=t[g]*d+t[s+p]*a}}_lerpAdditive(t,e,s,a,h){for(let d=0;d!==h;++d){const p=e+d;t[p]=t[p]+t[s+d]*a}}}const Ac="\\[\\]\\.:\\/",HS=new RegExp("["+Ac+"]","g"),Lc="[^"+Ac+"]",WS="[^"+Ac.replace("\\.","")+"]",GS=/((?:WC+[\/:])*)/.source.replace("WC",Lc),XS=/(WCOD+)?/.source.replace("WCOD",WS),jS=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Lc),qS=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Lc),YS=new RegExp("^"+GS+XS+jS+qS+"$"),$S=["material","materials","bones"];class ZS{constructor(t,e,s){const a=s||pe.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,a)}getValue(t,e){this.bind();const s=this._targetGroup.nCachedObjects_,a=this._bindings[s];a!==void 0&&a.getValue(t,e)}setValue(t,e){const s=this._bindings;for(let a=this._targetGroup.nCachedObjects_,h=s.length;a!==h;++a)s[a].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,s=t.length;e!==s;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,s=t.length;e!==s;++e)t[e].unbind()}}class pe{constructor(t,e,s){this.path=e,this.parsedPath=s||pe.parseTrackName(e),this.node=pe.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,s){return t&&t.isAnimationObjectGroup?new pe.Composite(t,e,s):new pe(t,e,s)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(HS,"")}static parseTrackName(t){const e=YS.exec(t);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const s={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},a=s.nodeName&&s.nodeName.lastIndexOf(".");if(a!==void 0&&a!==-1){const h=s.nodeName.substring(a+1);$S.indexOf(h)!==-1&&(s.nodeName=s.nodeName.substring(0,a),s.objectName=h)}if(s.propertyName===null||s.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return s}static findNode(t,e){if(!e||e===""||e==="."||e===-1||e===t.name||e===t.uuid)return t;if(t.skeleton){const s=t.skeleton.getBoneByName(e);if(s!==void 0)return s}if(t.children){const s=function(h){for(let d=0;d<h.length;d++){const p=h[d];if(p.name===e||p.uuid===e)return p;const g=s(p.children);if(g)return g}return null},a=s(t.children);if(a)return a}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const s=this.resolvedProperty;for(let a=0,h=s.length;a!==h;++a)t[e++]=s[a]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const s=this.resolvedProperty;for(let a=0,h=s.length;a!==h;++a)s[a]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const s=this.resolvedProperty;for(let a=0,h=s.length;a!==h;++a)s[a]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const s=this.resolvedProperty;for(let a=0,h=s.length;a!==h;++a)s[a]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,s=e.objectName,a=e.propertyName;let h=e.propertyIndex;if(t||(t=pe.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(s){let _=e.objectIndex;switch(s){case"materials":if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}t=t.material.materials;break;case"bones":if(!t.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}t=t.skeleton.bones;for(let v=0;v<t.length;v++)if(t[v].name===_){_=v;break}break;default:if(t[s]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}t=t[s]}if(_!==void 0){if(t[_]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);return}t=t[_]}}const d=t[a];if(d===void 0){const _=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+_+"."+a+" but it wasn't found.",t);return}let p=this.Versioning.None;this.targetObject=t,t.needsUpdate!==void 0?p=this.Versioning.NeedsUpdate:t.matrixWorldNeedsUpdate!==void 0&&(p=this.Versioning.MatrixWorldNeedsUpdate);let g=this.BindingType.Direct;if(h!==void 0){if(a==="morphTargetInfluences"){if(!t.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(t.geometry.isBufferGeometry){if(!t.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}t.morphTargetDictionary[h]!==void 0&&(h=t.morphTargetDictionary[h])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}g=this.BindingType.ArrayElement,this.resolvedProperty=d,this.propertyIndex=h}else d.fromArray!==void 0&&d.toArray!==void 0?(g=this.BindingType.HasFromToArray,this.resolvedProperty=d):Array.isArray(d)?(g=this.BindingType.EntireArray,this.resolvedProperty=d):this.propertyName=a;this.getValue=this.GetterByBindingType[g],this.setValue=this.SetterByBindingTypeAndVersioning[g][p]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}pe.Composite=ZS;pe.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};pe.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};pe.prototype.GetterByBindingType=[pe.prototype._getValue_direct,pe.prototype._getValue_array,pe.prototype._getValue_arrayElement,pe.prototype._getValue_toArray];pe.prototype.SetterByBindingTypeAndVersioning=[[pe.prototype._setValue_direct,pe.prototype._setValue_direct_setNeedsUpdate,pe.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[pe.prototype._setValue_array,pe.prototype._setValue_array_setNeedsUpdate,pe.prototype._setValue_array_setMatrixWorldNeedsUpdate],[pe.prototype._setValue_arrayElement,pe.prototype._setValue_arrayElement_setNeedsUpdate,pe.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[pe.prototype._setValue_fromArray,pe.prototype._setValue_fromArray_setNeedsUpdate,pe.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class JS{constructor(t,e,s=null,a=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=s,this.blendMode=a;const h=e.tracks,d=h.length,p=new Array(d),g={endingStart:Yi,endingEnd:Yi};for(let _=0;_!==d;++_){const v=h[_].createInterpolant(null);p[_]=v,v.settings=g}this._interpolantSettings=g,this._interpolants=p,this._propertyBindings=new Array(d),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=R0,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,s){if(t.fadeOut(e),this.fadeIn(e),s){const a=this._clip.duration,h=t._clip.duration,d=h/a,p=a/h;t.warp(1,d,e),this.warp(p,1,e)}return this}crossFadeTo(t,e,s){return t.crossFadeFrom(this,e,s)}stopFading(){const t=this._weightInterpolant;return t!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,s){const a=this._mixer,h=a.time,d=this.timeScale;let p=this._timeScaleInterpolant;p===null&&(p=a._lendControlInterpolant(),this._timeScaleInterpolant=p);const g=p.parameterPositions,_=p.sampleValues;return g[0]=h,g[1]=h+s,_[0]=t/d,_[1]=e/d,this}stopWarping(){const t=this._timeScaleInterpolant;return t!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,s,a){if(!this.enabled){this._updateWeight(t);return}const h=this._startTime;if(h!==null){const g=(t-h)*s;if(g<0||s===0)return;this._startTime=null,e=s*g}e*=this._updateTimeScale(t);const d=this._updateTime(e),p=this._updateWeight(t);if(p>0){const g=this._interpolants,_=this._propertyBindings;switch(this.blendMode){case hd:for(let v=0,b=g.length;v!==b;++v)g[v].evaluate(d),_[v].accumulateAdditive(p);break;case _l:default:for(let v=0,b=g.length;v!==b;++v)g[v].evaluate(d),_[v].accumulate(a,p)}}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const s=this._weightInterpolant;if(s!==null){const a=s.evaluate(t)[0];e*=a,t>s.parameterPositions[1]&&(this.stopFading(),a===0&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const s=this._timeScaleInterpolant;s!==null&&(e*=s.evaluate(t)[0],t>s.parameterPositions[1]&&(this.stopWarping(),e===0?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,s=this.loop;let a=this.time+t,h=this._loopCount;const d=s===P0;if(t===0)return h===-1?a:d&&(h&1)==1?e-a:a;if(s===C0){h===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(a>=e)a=e;else if(a<0)a=0;else{this.time=a;break t}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=a,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(h===-1&&(t>=0?(h=0,this._setEndings(!0,this.repetitions===0,d)):this._setEndings(this.repetitions===0,!0,d)),a>=e||a<0){const p=Math.floor(a/e);a-=e*p,h+=Math.abs(p);const g=this.repetitions-h;if(g<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,a=t>0?e:0,this.time=a,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(g===1){const _=t<0;this._setEndings(_,!_,d)}else this._setEndings(!1,!1,d);this._loopCount=h,this.time=a,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:p})}}else this.time=a;if(d&&(h&1)==1)return e-a}return a}_setEndings(t,e,s){const a=this._interpolantSettings;s?(a.endingStart=$i,a.endingEnd=$i):(t?a.endingStart=this.zeroSlopeAtStart?$i:Yi:a.endingStart=To,e?a.endingEnd=this.zeroSlopeAtEnd?$i:Yi:a.endingEnd=To)}_scheduleFading(t,e,s){const a=this._mixer,h=a.time;let d=this._weightInterpolant;d===null&&(d=a._lendControlInterpolant(),this._weightInterpolant=d);const p=d.parameterPositions,g=d.sampleValues;return p[0]=h,g[0]=e,p[1]=h+t,g[1]=s,this}}class KS extends Ci{constructor(t){super();this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const s=t._localRoot||this._root,a=t._clip.tracks,h=a.length,d=t._propertyBindings,p=t._interpolants,g=s.uuid,_=this._bindingsByRootAndName;let v=_[g];v===void 0&&(v={},_[g]=v);for(let b=0;b!==h;++b){const M=a[b],S=M.name;let L=v[S];if(L!==void 0)d[b]=L;else{if(L=d[b],L!==void 0){L._cacheIndex===null&&(++L.referenceCount,this._addInactiveBinding(L,g,S));continue}const C=e&&e._propertyBindings[b].binding.parsedPath;L=new US(pe.create(s,S,C),M.ValueTypeName,M.getValueSize()),++L.referenceCount,this._addInactiveBinding(L,g,S),d[b]=L}p[b].resultBuffer=L.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(t._cacheIndex===null){const s=(t._localRoot||this._root).uuid,a=t._clip.uuid,h=this._actionsByClip[a];this._bindAction(t,h&&h.knownActions[0]),this._addInactiveAction(t,a,s)}const e=t._propertyBindings;for(let s=0,a=e.length;s!==a;++s){const h=e[s];h.useCount++==0&&(this._lendBinding(h),h.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let s=0,a=e.length;s!==a;++s){const h=e[s];--h.useCount==0&&(h.restoreOriginalState(),this._takeBackBinding(h))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return e!==null&&e<this._nActiveActions}_addInactiveAction(t,e,s){const a=this._actions,h=this._actionsByClip;let d=h[e];if(d===void 0)d={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,h[e]=d;else{const p=d.knownActions;t._byClipCacheIndex=p.length,p.push(t)}t._cacheIndex=a.length,a.push(t),d.actionByRoot[s]=t}_removeInactiveAction(t){const e=this._actions,s=e[e.length-1],a=t._cacheIndex;s._cacheIndex=a,e[a]=s,e.pop(),t._cacheIndex=null;const h=t._clip.uuid,d=this._actionsByClip,p=d[h],g=p.knownActions,_=g[g.length-1],v=t._byClipCacheIndex;_._byClipCacheIndex=v,g[v]=_,g.pop(),t._byClipCacheIndex=null;const b=p.actionByRoot,M=(t._localRoot||this._root).uuid;delete b[M],g.length===0&&delete d[h],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let s=0,a=e.length;s!==a;++s){const h=e[s];--h.referenceCount==0&&this._removeInactiveBinding(h)}}_lendAction(t){const e=this._actions,s=t._cacheIndex,a=this._nActiveActions++,h=e[a];t._cacheIndex=a,e[a]=t,h._cacheIndex=s,e[s]=h}_takeBackAction(t){const e=this._actions,s=t._cacheIndex,a=--this._nActiveActions,h=e[a];t._cacheIndex=a,e[a]=t,h._cacheIndex=s,e[s]=h}_addInactiveBinding(t,e,s){const a=this._bindingsByRootAndName,h=this._bindings;let d=a[e];d===void 0&&(d={},a[e]=d),d[s]=t,t._cacheIndex=h.length,h.push(t)}_removeInactiveBinding(t){const e=this._bindings,s=t.binding,a=s.rootNode.uuid,h=s.path,d=this._bindingsByRootAndName,p=d[a],g=e[e.length-1],_=t._cacheIndex;g._cacheIndex=_,e[_]=g,e.pop(),delete p[h],Object.keys(p).length===0&&delete d[a]}_lendBinding(t){const e=this._bindings,s=t._cacheIndex,a=this._nActiveBindings++,h=e[a];t._cacheIndex=a,e[a]=t,h._cacheIndex=s,e[s]=h}_takeBackBinding(t){const e=this._bindings,s=t._cacheIndex,a=--this._nActiveBindings,h=e[a];t._cacheIndex=a,e[a]=t,h._cacheIndex=s,e[s]=h}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let s=t[e];return s===void 0&&(s=new Kf(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),s.__cacheIndex=e,t[e]=s),s}_takeBackControlInterpolant(t){const e=this._controlInterpolants,s=t.__cacheIndex,a=--this._nActiveControlInterpolants,h=e[a];t.__cacheIndex=a,e[a]=t,h.__cacheIndex=s,e[s]=h}clipAction(t,e,s){const a=e||this._root,h=a.uuid;let d=typeof t=="string"?tp.findByName(a,t):t;const p=d!==null?d.uuid:t,g=this._actionsByClip[p];let _=null;if(s===void 0&&(d!==null?s=d.blendMode:s=_l),g!==void 0){const b=g.actionByRoot[h];if(b!==void 0&&b.blendMode===s)return b;_=g.knownActions[0],d===null&&(d=_._clip)}if(d===null)return null;const v=new JS(this,d,e,s);return this._bindAction(v,_),this._addInactiveAction(v,p,h),v}existingAction(t,e){const s=e||this._root,a=s.uuid,h=typeof t=="string"?tp.findByName(s,t):t,d=h?h.uuid:t,p=this._actionsByClip[d];return p!==void 0&&p.actionByRoot[a]||null}stopAllAction(){const t=this._actions,e=this._nActiveActions;for(let s=e-1;s>=0;--s)t[s].stop();return this}update(t){t*=this.timeScale;const e=this._actions,s=this._nActiveActions,a=this.time+=t,h=Math.sign(t),d=this._accuIndex^=1;for(let _=0;_!==s;++_)e[_]._update(a,t,h,d);const p=this._bindings,g=this._nActiveBindings;for(let _=0;_!==g;++_)p[_].apply(d);return this}setTime(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,s=t.uuid,a=this._actionsByClip,h=a[s];if(h!==void 0){const d=h.knownActions;for(let p=0,g=d.length;p!==g;++p){const _=d[p];this._deactivateAction(_);const v=_._cacheIndex,b=e[e.length-1];_._cacheIndex=null,_._byClipCacheIndex=null,b._cacheIndex=v,e[v]=b,e.pop(),this._removeInactiveBindingsForAction(_)}delete a[s]}}uncacheRoot(t){const e=t.uuid,s=this._actionsByClip;for(const d in s){const p=s[d].actionByRoot,g=p[e];g!==void 0&&(this._deactivateAction(g),this._removeInactiveAction(g))}const a=this._bindingsByRootAndName,h=a[e];if(h!==void 0)for(const d in h){const p=h[d];p.restoreOriginalState(),this._removeInactiveBinding(p)}}uncacheAction(t,e){const s=this.existingAction(t,e);s!==null&&(this._deactivateAction(s),this._removeInactiveAction(s))}}KS.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class QS extends xr{constructor(t,e,s=1){super(t,e);this.meshPerAttribute=s}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}QS.prototype.isInstancedInterleavedBuffer=!0;class tT extends de{constructor(t){super();this.material=t,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}}tT.prototype.isImmediateRenderObject=!0;const yi=new N,da=new jt,Cc=new jt;class eT extends hc{constructor(t){const e=up(t),s=new ve,a=[],h=[],d=new Ht(0,0,1),p=new Ht(0,1,0);for(let _=0;_<e.length;_++){const v=e[_];v.parent&&v.parent.isBone&&(a.push(0,0,0),a.push(0,0,0),h.push(d.r,d.g,d.b),h.push(p.r,p.g,p.b))}s.setAttribute("position",new Ae(a,3)),s.setAttribute("color",new Ae(h,3));const g=new wr({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(s,g);this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,s=this.geometry,a=s.getAttribute("position");Cc.copy(this.root.matrixWorld).invert();for(let h=0,d=0;h<e.length;h++){const p=e[h];p.parent&&p.parent.isBone&&(da.multiplyMatrices(Cc,p.matrixWorld),yi.setFromMatrixPosition(da),a.setXYZ(d,yi.x,yi.y,yi.z),da.multiplyMatrices(Cc,p.parent.matrixWorld),yi.setFromMatrixPosition(da),a.setXYZ(d+1,yi.x,yi.y,yi.z),d+=2)}s.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function up(c){const t=[];c&&c.isBone&&t.push(c);for(let e=0;e<c.children.length;e++)t.push.apply(t,up(c.children[e]));return t}class nT extends hc{constructor(t=10,e=10,s=4473924,a=8947848){s=new Ht(s),a=new Ht(a);const h=e/2,d=t/e,p=t/2,g=[],_=[];for(let M=0,S=0,L=-p;M<=e;M++,L+=d){g.push(-p,0,L,p,0,L),g.push(L,0,-p,L,0,p);const C=M===h?s:a;C.toArray(_,S),S+=3,C.toArray(_,S),S+=3,C.toArray(_,S),S+=3,C.toArray(_,S),S+=3}const v=new ve;v.setAttribute("position",new Ae(g,3)),v.setAttribute("color",new Ae(_,3));const b=new wr({vertexColors:!0,toneMapped:!1});super(v,b);this.type="GridHelper"}}const iT=new Float32Array(1);new Int32Array(iT.buffer);yn.create=function(c,t){return console.log("THREE.Curve.create() has been deprecated"),c.prototype=Object.create(yn.prototype),c.prototype.constructor=c,c.prototype.getPoint=t,c};vc.prototype.fromPoints=function(c){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(c)};nT.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};eT.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};_i.prototype.extractUrlBase=function(c){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),IS.extractUrlBase(c)};_i.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};Mn.prototype.center=function(c){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(c)};Mn.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};Mn.prototype.isIntersectionBox=function(c){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(c)};Mn.prototype.isIntersectionSphere=function(c){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(c)};Mn.prototype.size=function(c){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(c)};ns.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};jo.prototype.setFromMatrix=function(c){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(c)};Ge.prototype.flattenToArrayOffset=function(c,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(c,t)};Ge.prototype.multiplyVector3=function(c){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),c.applyMatrix3(this)};Ge.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};Ge.prototype.applyToBufferAttribute=function(c){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),c.applyMatrix3(this)};Ge.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};Ge.prototype.getInverse=function(c){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(c).invert()};jt.prototype.extractPosition=function(c){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(c)};jt.prototype.flattenToArrayOffset=function(c,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(c,t)};jt.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new N().setFromMatrixColumn(this,3)};jt.prototype.setRotationFromQuaternion=function(c){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(c)};jt.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};jt.prototype.multiplyVector3=function(c){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),c.applyMatrix4(this)};jt.prototype.multiplyVector4=function(c){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),c.applyMatrix4(this)};jt.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};jt.prototype.rotateAxis=function(c){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),c.transformDirection(this)};jt.prototype.crossVector=function(c){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),c.applyMatrix4(this)};jt.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};jt.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};jt.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};jt.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};jt.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};jt.prototype.applyToBufferAttribute=function(c){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),c.applyMatrix4(this)};jt.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};jt.prototype.makeFrustum=function(c,t,e,s,a,h){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(c,t,s,e,a,h)};jt.prototype.getInverse=function(c){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(c).invert()};jn.prototype.isIntersectionLine=function(c){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(c)};sn.prototype.multiplyVector3=function(c){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),c.applyQuaternion(this)};sn.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};is.prototype.isIntersectionBox=function(c){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(c)};is.prototype.isIntersectionPlane=function(c){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(c)};is.prototype.isIntersectionSphere=function(c){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(c)};Pe.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};Pe.prototype.barycoordFromPoint=function(c,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(c,t)};Pe.prototype.midpoint=function(c){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(c)};Pe.prototypenormal=function(c){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(c)};Pe.prototype.plane=function(c){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(c)};Pe.barycoordFromPoint=function(c,t,e,s,a){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Pe.getBarycoord(c,t,e,s,a)};Pe.normal=function(c,t,e,s){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Pe.getNormal(c,t,e,s)};Er.prototype.extractAllPoints=function(c){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(c)};Er.prototype.extrude=function(c){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Ts(this,c)};Er.prototype.makeGeometry=function(c){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new wc(this,c)};Mt.prototype.fromAttribute=function(c,t,e){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(c,t,e)};Mt.prototype.distanceToManhattan=function(c){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(c)};Mt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};N.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};N.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};N.prototype.getPositionFromMatrix=function(c){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(c)};N.prototype.getScaleFromMatrix=function(c){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(c)};N.prototype.getColumnFromMatrix=function(c,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,c)};N.prototype.applyProjection=function(c){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(c)};N.prototype.fromAttribute=function(c,t,e){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(c,t,e)};N.prototype.distanceToManhattan=function(c){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(c)};N.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};ge.prototype.fromAttribute=function(c,t,e){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(c,t,e)};ge.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};de.prototype.getChildByName=function(c){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(c)};de.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};de.prototype.translate=function(c,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,c)};de.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};de.prototype.applyMatrix=function(c){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(c)};Object.defineProperties(de.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(c){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=c}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});rn.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(rn.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),D0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});Af.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};on.prototype.setLens=function(c,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),t!==void 0&&(this.filmGauge=t),this.setFocalLength(c)};Object.defineProperties(zn.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(c){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=c}},shadowCameraLeft:{set:function(c){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=c}},shadowCameraRight:{set:function(c){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=c}},shadowCameraTop:{set:function(c){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=c}},shadowCameraBottom:{set:function(c){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=c}},shadowCameraNear:{set:function(c){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=c}},shadowCameraFar:{set:function(c){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=c}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(c){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=c}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(c){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=c}},shadowMapHeight:{set:function(c){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=c}}});Object.defineProperties(Oe.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===Eo},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(Eo)}}});Oe.prototype.setDynamic=function(c){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(c===!0?Eo:lr),this};Oe.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},Oe.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};ve.prototype.addIndex=function(c){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(c)};ve.prototype.addAttribute=function(c,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(t&&t.isBufferAttribute)&&!(t&&t.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(c,new Oe(arguments[1],arguments[2]))):c==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(c,t)};ve.prototype.addDrawCall=function(c,t,e){e!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(c,t)};ve.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};ve.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};ve.prototype.removeAttribute=function(c){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(c)};ve.prototype.applyMatrix=function(c){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(c)};Object.defineProperties(ve.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});xr.prototype.setDynamic=function(c){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(c===!0?Eo:lr),this};xr.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};Ts.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};Ts.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};Ts.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};_f.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};Object.defineProperties(Ye.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Ht}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(c){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=c===Gh}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(c){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=c}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}});Object.defineProperties(Di.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(c){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=c}}});xe.prototype.clearTarget=function(c,t,e,s){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(c),this.clear(t,e,s)};xe.prototype.animate=function(c){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(c)};xe.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};xe.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};xe.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};xe.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};xe.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};xe.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};xe.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};xe.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};xe.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};xe.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};xe.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};xe.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};xe.prototype.enableScissorTest=function(c){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(c)};xe.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};xe.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};xe.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};xe.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};xe.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};xe.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};xe.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};xe.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};xe.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};xe.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(xe.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(c){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=c}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(c){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=c}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(c){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=c===!0?Li:qe}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties(gf.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(Fn.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(c){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=c}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(c){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=c}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(c){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=c}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(c){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=c}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(c){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=c}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(c){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=c}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(c){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=c}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(c){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=c}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(c){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=c}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(c){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=c}}});VS.prototype.load=function(c){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const t=this;return new BS().load(c,function(s){t.setBuffer(s)}),this};$l.prototype.updateCubeMap=function(c,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(c,t)};$l.prototype.clear=function(c,t,e,s){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(c,t,e,s)};Ki.crossOrigin=void 0;Ki.loadTexture=function(c,t,e,s){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const a=new ES;a.setCrossOrigin(this.crossOrigin);const h=a.load(c,e,void 0,s);return t&&(h.mapping=t),h};Ki.loadTextureCube=function(c,t,e,s){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const a=new TS;a.setCrossOrigin(this.crossOrigin);const h=a.load(c,e,void 0,s);return t&&(h.mapping=t),h};Ki.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};Ki.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Uh}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Uh);var sT=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{},hp={exports:{}};/*!
 * Chart.js v3.5.1
 * https://www.chartjs.org
 * (c) 2021 Chart.js Contributors
 * Released under the MIT License
 */(function(c,t){(function(e,s){c.exports=s()})(sT,function(){function e(r,n,i){return n+" "+r+"px "+i}const s=function(){return typeof window=="undefined"?function(r){return r()}:window.requestAnimationFrame}();function a(r,n,i){const o=i||(f=>Array.prototype.slice.call(f));let l=!1,u=[];return function(...f){u=o(f),l||(l=!0,s.call(window,()=>{l=!1,r.apply(n,u)}))}}function h(r,n){let i;return function(){return n?(clearTimeout(i),i=setTimeout(r,n)):r(),n}}const d=r=>r==="start"?"left":r==="end"?"right":"center",p=(r,n,i)=>r==="start"?n:r==="end"?i:(n+i)/2,g=(r,n,i,o)=>r===(o?"left":"right")?i:r==="center"?(n+i)/2:n;class _{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(n,i,o,l){const u=i.listeners[l],f=i.duration;u.forEach(m=>m({chart:n,initial:i.initial,numSteps:f,currentStep:Math.min(o-i.start,f)}))}_refresh(){const n=this;n._request||(n._running=!0,n._request=s.call(window,()=>{n._update(),n._request=null,n._running&&n._refresh()}))}_update(n=Date.now()){const i=this;let o=0;i._charts.forEach((l,u)=>{if(!l.running||!l.items.length)return;const f=l.items;let m=f.length-1,x=!1,y;for(;m>=0;--m)y=f[m],y._active?(y._total>l.duration&&(l.duration=y._total),y.tick(n),x=!0):(f[m]=f[f.length-1],f.pop());x&&(u.draw(),i._notify(u,l,n,"progress")),f.length||(l.running=!1,i._notify(u,l,n,"complete"),l.initial=!1),o+=f.length}),i._lastDate=n,o===0&&(i._running=!1)}_getAnims(n){const i=this._charts;let o=i.get(n);return o||(o={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},i.set(n,o)),o}listen(n,i,o){this._getAnims(n).listeners[i].push(o)}add(n,i){!i||!i.length||this._getAnims(n).items.push(...i)}has(n){return this._getAnims(n).items.length>0}start(n){const i=this._charts.get(n);!i||(i.running=!0,i.start=Date.now(),i.duration=i.items.reduce((o,l)=>Math.max(o,l._duration),0),this._refresh())}running(n){if(!this._running)return!1;const i=this._charts.get(n);return!(!i||!i.running||!i.items.length)}stop(n){const i=this._charts.get(n);if(!i||!i.items.length)return;const o=i.items;let l=o.length-1;for(;l>=0;--l)o[l].cancel();i.items=[],this._notify(n,i,Date.now(),"complete")}remove(n){return this._charts.delete(n)}}var v=new _;/*!
 * @kurkle/color v0.1.9
 * https://github.com/kurkle/color#readme
 * (c) 2020 Jukka Kurkela
 * Released under the MIT License
 */const b={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},M="0123456789ABCDEF",S=r=>M[r&15],L=r=>M[(r&240)>>4]+M[r&15],C=r=>(r&240)>>4==(r&15);function k(r){return C(r.r)&&C(r.g)&&C(r.b)&&C(r.a)}function T(r){var n=r.length,i;return r[0]==="#"&&(n===4||n===5?i={r:255&b[r[1]]*17,g:255&b[r[2]]*17,b:255&b[r[3]]*17,a:n===5?b[r[4]]*17:255}:(n===7||n===9)&&(i={r:b[r[1]]<<4|b[r[2]],g:b[r[3]]<<4|b[r[4]],b:b[r[5]]<<4|b[r[6]],a:n===9?b[r[7]]<<4|b[r[8]]:255})),i}function E(r){var n=k(r)?S:L;return r&&"#"+n(r.r)+n(r.g)+n(r.b)+(r.a<255?n(r.a):"")}function z(r){return r+.5|0}const I=(r,n,i)=>Math.max(Math.min(r,i),n);function V(r){return I(z(r*2.55),0,255)}function G(r){return I(z(r*255),0,255)}function F(r){return I(z(r/2.55)/100,0,1)}function K(r){return I(z(r*100),0,100)}const pt=/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;function ut(r){const n=pt.exec(r);let i=255,o,l,u;if(!!n){if(n[7]!==o){const f=+n[7];i=255&(n[8]?V(f):f*255)}return o=+n[1],l=+n[3],u=+n[5],o=255&(n[2]?V(o):o),l=255&(n[4]?V(l):l),u=255&(n[6]?V(u):u),{r:o,g:l,b:u,a:i}}}function X(r){return r&&(r.a<255?`rgba(${r.r}, ${r.g}, ${r.b}, ${F(r.a)})`:`rgb(${r.r}, ${r.g}, ${r.b})`)}const ht=/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;function it(r,n,i){const o=n*Math.min(i,1-i),l=(u,f=(u+r/30)%12)=>i-o*Math.max(Math.min(f-3,9-f,1),-1);return[l(0),l(8),l(4)]}function Q(r,n,i){const o=(l,u=(l+r/60)%6)=>i-i*n*Math.max(Math.min(u,4-u,1),0);return[o(5),o(3),o(1)]}function rt(r,n,i){const o=it(r,1,.5);let l;for(n+i>1&&(l=1/(n+i),n*=l,i*=l),l=0;l<3;l++)o[l]*=1-n-i,o[l]+=n;return o}function tt(r){const n=255,i=r.r/n,o=r.g/n,l=r.b/n,u=Math.max(i,o,l),f=Math.min(i,o,l),m=(u+f)/2;let x,y,w;return u!==f&&(w=u-f,y=m>.5?w/(2-u-f):w/(u+f),x=u===i?(o-l)/w+(o<l?6:0):u===o?(l-i)/w+2:(i-o)/w+4,x=x*60+.5),[x|0,y||0,m]}function st(r,n,i,o){return(Array.isArray(n)?r(n[0],n[1],n[2]):r(n,i,o)).map(G)}function St(r,n,i){return st(it,r,n,i)}function Bt(r,n,i){return st(rt,r,n,i)}function Wt(r,n,i){return st(Q,r,n,i)}function Pt(r){return(r%360+360)%360}function Zt(r){const n=ht.exec(r);let i=255,o;if(!n)return;n[5]!==o&&(i=n[6]?V(+n[5]):G(+n[5]));const l=Pt(+n[2]),u=+n[3]/100,f=+n[4]/100;return n[1]==="hwb"?o=Bt(l,u,f):n[1]==="hsv"?o=Wt(l,u,f):o=St(l,u,f),{r:o[0],g:o[1],b:o[2],a:i}}function ee(r,n){var i=tt(r);i[0]=Pt(i[0]+n),i=St(i),r.r=i[0],r.g=i[1],r.b=i[2]}function re(r){if(!r)return;const n=tt(r),i=n[0],o=K(n[1]),l=K(n[2]);return r.a<255?`hsla(${i}, ${o}%, ${l}%, ${F(r.a)})`:`hsl(${i}, ${o}%, ${l}%)`}const xt={x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"},Y={OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};function Xt(){const r={},n=Object.keys(Y),i=Object.keys(xt);let o,l,u,f,m;for(o=0;o<n.length;o++){for(f=m=n[o],l=0;l<i.length;l++)u=i[l],m=m.replace(u,xt[u]);u=parseInt(Y[f],16),r[m]=[u>>16&255,u>>8&255,u&255]}return r}let It;function vt(r){It||(It=Xt(),It.transparent=[0,0,0,0]);const n=It[r.toLowerCase()];return n&&{r:n[0],g:n[1],b:n[2],a:n.length===4?n[3]:255}}function Ft(r,n,i){if(r){let o=tt(r);o[n]=Math.max(0,Math.min(o[n]+o[n]*i,n===0?360:1)),o=St(o),r.r=o[0],r.g=o[1],r.b=o[2]}}function Jt(r,n){return r&&Object.assign(n||{},r)}function ot(r){var n={r:0,g:0,b:0,a:255};return Array.isArray(r)?r.length>=3&&(n={r:r[0],g:r[1],b:r[2],a:255},r.length>3&&(n.a=G(r[3]))):(n=Jt(r,{r:0,g:0,b:0,a:1}),n.a=G(n.a)),n}function dt(r){return r.charAt(0)==="r"?ut(r):Zt(r)}class _t{constructor(n){if(n instanceof _t)return n;const i=typeof n;let o;i==="object"?o=ot(n):i==="string"&&(o=T(n)||vt(n)||dt(n)),this._rgb=o,this._valid=!!o}get valid(){return this._valid}get rgb(){var n=Jt(this._rgb);return n&&(n.a=F(n.a)),n}set rgb(n){this._rgb=ot(n)}rgbString(){return this._valid?X(this._rgb):this._rgb}hexString(){return this._valid?E(this._rgb):this._rgb}hslString(){return this._valid?re(this._rgb):this._rgb}mix(n,i){const o=this;if(n){const l=o.rgb,u=n.rgb;let f;const m=i===f?.5:i,x=2*m-1,y=l.a-u.a,w=((x*y==-1?x:(x+y)/(1+x*y))+1)/2;f=1-w,l.r=255&w*l.r+f*u.r+.5,l.g=255&w*l.g+f*u.g+.5,l.b=255&w*l.b+f*u.b+.5,l.a=m*l.a+(1-m)*u.a,o.rgb=l}return o}clone(){return new _t(this.rgb)}alpha(n){return this._rgb.a=G(n),this}clearer(n){const i=this._rgb;return i.a*=1-n,this}greyscale(){const n=this._rgb,i=z(n.r*.3+n.g*.59+n.b*.11);return n.r=n.g=n.b=i,this}opaquer(n){const i=this._rgb;return i.a*=1+n,this}negate(){const n=this._rgb;return n.r=255-n.r,n.g=255-n.g,n.b=255-n.b,this}lighten(n){return Ft(this._rgb,2,n),this}darken(n){return Ft(this._rgb,2,-n),this}saturate(n){return Ft(this._rgb,1,n),this}desaturate(n){return Ft(this._rgb,1,-n),this}rotate(n){return ee(this._rgb,n),this}}function Nt(r){return new _t(r)}const Rt=r=>r instanceof CanvasGradient||r instanceof CanvasPattern;function B(r){return Rt(r)?r:Nt(r)}function D(r){return Rt(r)?r:Nt(r).saturate(.5).darken(.1).hexString()}function et(){}const bt=function(){let r=0;return function(){return r++}}();function at(r){return r===null||typeof r=="undefined"}function gt(r){if(Array.isArray&&Array.isArray(r))return!0;const n=Object.prototype.toString.call(r);return n.substr(0,7)==="[object"&&n.substr(-6)==="Array]"}function Et(r){return r!==null&&Object.prototype.toString.call(r)==="[object Object]"}const At=r=>(typeof r=="number"||r instanceof Number)&&isFinite(+r);function Vt(r,n){return At(r)?r:n}function ft(r,n){return typeof r=="undefined"?n:r}const W=(r,n)=>typeof r=="string"&&r.endsWith("%")?parseFloat(r)/100:r/n,Lt=(r,n)=>typeof r=="string"&&r.endsWith("%")?parseFloat(r)/100*n:+r;function nt(r,n,i){if(r&&typeof r.call=="function")return r.apply(i,n)}function mt(r,n,i,o){let l,u,f;if(gt(r))if(u=r.length,o)for(l=u-1;l>=0;l--)n.call(i,r[l],l);else for(l=0;l<u;l++)n.call(i,r[l],l);else if(Et(r))for(f=Object.keys(r),u=f.length,l=0;l<u;l++)n.call(i,r[f[l]],f[l])}function kt(r,n){let i,o,l,u;if(!r||!n||r.length!==n.length)return!1;for(i=0,o=r.length;i<o;++i)if(l=r[i],u=n[i],l.datasetIndex!==u.datasetIndex||l.index!==u.index)return!1;return!0}function Qt(r){if(gt(r))return r.map(Qt);if(Et(r)){const n=Object.create(null),i=Object.keys(r),o=i.length;let l=0;for(;l<o;++l)n[i[l]]=Qt(r[i[l]]);return n}return r}function De(r){return["__proto__","prototype","constructor"].indexOf(r)===-1}function Ie(r,n,i,o){if(!De(r))return;const l=n[r],u=i[r];Et(l)&&Et(u)?Je(l,u,o):n[r]=Qt(u)}function Je(r,n,i){const o=gt(n)?n:[n],l=o.length;if(!Et(r))return r;i=i||{};const u=i.merger||Ie;for(let f=0;f<l;++f){if(n=o[f],!Et(n))continue;const m=Object.keys(n);for(let x=0,y=m.length;x<y;++x)u(m[x],r,n,i)}return r}function me(r,n){return Je(r,n,{merger:dn})}function dn(r,n,i){if(!De(r))return;const o=n[r],l=i[r];Et(o)&&Et(l)?me(o,l):Object.prototype.hasOwnProperty.call(n,r)||(n[r]=Qt(l))}function vn(r,n,i,o){n!==void 0&&console.warn(r+': "'+i+'" is deprecated. Please use "'+o+'" instead')}const Cs="",fa=".";function Rs(r,n){const i=r.indexOf(fa,n);return i===-1?r.length:i}function fn(r,n){if(n===Cs)return r;let i=0,o=Rs(n,i);for(;r&&o>i;)r=r[n.substr(i,o-i)],i=o+1,o=Rs(n,i);return r}function pn(r){return r.charAt(0).toUpperCase()+r.slice(1)}const Be=r=>typeof r!="undefined",An=r=>typeof r=="function",Dr=(r,n)=>{if(r.size!==n.size)return!1;for(const i of r)if(!n.has(i))return!1;return!0},mn=Object.create(null),Ps=Object.create(null);function Nn(r,n){if(!n)return r;const i=n.split(".");for(let o=0,l=i.length;o<l;++o){const u=i[o];r=r[u]||(r[u]=Object.create(null))}return r}function Fi(r,n,i){return typeof n=="string"?Je(Nn(r,n),i):Je(Nn(r,""),n)}class Ir{constructor(n){this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0,0,0,0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=i=>i.chart.platform.getDevicePixelRatio(),this.elements={},this.events=["mousemove","mouseout","click","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(i,o)=>D(o.backgroundColor),this.hoverBorderColor=(i,o)=>D(o.borderColor),this.hoverColor=(i,o)=>D(o.color),this.indexAxis="x",this.interaction={mode:"nearest",intersect:!0},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.describe(n)}set(n,i){return Fi(this,n,i)}get(n){return Nn(this,n)}describe(n,i){return Fi(Ps,n,i)}override(n,i){return Fi(mn,n,i)}route(n,i,o,l){const u=Nn(this,n),f=Nn(this,o),m="_"+i;Object.defineProperties(u,{[m]:{value:u[i],writable:!0},[i]:{enumerable:!0,get(){const x=this[m],y=f[l];return Et(x)?Object.assign({},y,x):ft(x,y)},set(x){this[m]=x}}})}}var ie=new Ir({_scriptable:r=>!r.startsWith("on"),_indexable:r=>r!=="events",hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}});const ye=Math.PI,P=2*ye,$=P+ye,j=Number.POSITIVE_INFINITY,J=ye/180,lt=ye/2,qt=ye/4,Gt=ye*2/3,Ot=Math.log10,Yt=Math.sign;function ce(r){const n=Math.round(r);r=fe(r,n,r/1e3)?n:r;const i=Math.pow(10,Math.floor(Ot(r))),o=r/i;return(o<=1?1:o<=2?2:o<=5?5:10)*i}function ne(r){const n=[],i=Math.sqrt(r);let o;for(o=1;o<i;o++)r%o==0&&(n.push(o),n.push(r/o));return i===(i|0)&&n.push(i),n.sort((l,u)=>l-u).pop(),n}function te(r){return!isNaN(parseFloat(r))&&isFinite(r)}function fe(r,n,i){return Math.abs(r-n)<i}function oe(r,n){const i=Math.round(r);return i-n<=r&&i+n>=r}function Ln(r,n,i){let o,l,u;for(o=0,l=r.length;o<l;o++)u=r[o][i],isNaN(u)||(n.min=Math.min(n.min,u),n.max=Math.max(n.max,u))}function ue(r){return r*(ye/180)}function ze(r){return r*(180/ye)}function qn(r){if(!At(r))return;let n=1,i=0;for(;Math.round(r*n)/n!==r;)n*=10,i++;return i}function an(r,n){const i=n.x-r.x,o=n.y-r.y,l=Math.sqrt(i*i+o*o);let u=Math.atan2(o,i);return u<-.5*ye&&(u+=P),{angle:u,distance:l}}function Cn(r,n){return Math.sqrt(Math.pow(n.x-r.x,2)+Math.pow(n.y-r.y,2))}function be(r,n){return(r-n+$)%P-ye}function Me(r){return(r%P+P)%P}function Ue(r,n,i,o){const l=Me(r),u=Me(n),f=Me(i),m=Me(u-l),x=Me(f-l),y=Me(l-u),w=Me(l-f);return l===u||l===f||o&&u===f||m>x&&y<w}function Fe(r,n,i){return Math.max(n,Math.min(i,r))}function Rc(r){return Fe(r,-32768,32767)}function Pc(r){return!r||at(r.size)||at(r.family)?null:(r.style?r.style+" ":"")+(r.weight?r.weight+" ":"")+r.size+"px "+r.family}function Ds(r,n,i,o,l){let u=n[l];return u||(u=n[l]=r.measureText(l).width,i.push(l)),u>o&&(o=u),o}function Dc(r,n,i,o){o=o||{};let l=o.data=o.data||{},u=o.garbageCollect=o.garbageCollect||[];o.font!==n&&(l=o.data={},u=o.garbageCollect=[],o.font=n),r.save(),r.font=n;let f=0;const m=i.length;let x,y,w,A,R;for(x=0;x<m;x++)if(A=i[x],A!=null&&gt(A)!==!0)f=Ds(r,l,u,f,A);else if(gt(A))for(y=0,w=A.length;y<w;y++)R=A[y],R!=null&&!gt(R)&&(f=Ds(r,l,u,f,R));r.restore();const O=u.length/2;if(O>i.length){for(x=0;x<O;x++)delete l[u[x]];u.splice(0,O)}return f}function Yn(r,n,i){const o=r.currentDevicePixelRatio,l=i!==0?Math.max(i/2,.5):0;return Math.round((n-l)*o)/o+l}function pa(r,n){n=n||r.getContext("2d"),n.save(),n.resetTransform(),n.clearRect(0,0,r.width,r.height),n.restore()}function Is(r,n,i,o){let l,u,f,m,x;const y=n.pointStyle,w=n.rotation,A=n.radius;let R=(w||0)*J;if(y&&typeof y=="object"&&(l=y.toString(),l==="[object HTMLImageElement]"||l==="[object HTMLCanvasElement]")){r.save(),r.translate(i,o),r.rotate(R),r.drawImage(y,-y.width/2,-y.height/2,y.width,y.height),r.restore();return}if(!(isNaN(A)||A<=0)){switch(r.beginPath(),y){default:r.arc(i,o,A,0,P),r.closePath();break;case"triangle":r.moveTo(i+Math.sin(R)*A,o-Math.cos(R)*A),R+=Gt,r.lineTo(i+Math.sin(R)*A,o-Math.cos(R)*A),R+=Gt,r.lineTo(i+Math.sin(R)*A,o-Math.cos(R)*A),r.closePath();break;case"rectRounded":x=A*.516,m=A-x,u=Math.cos(R+qt)*m,f=Math.sin(R+qt)*m,r.arc(i-u,o-f,x,R-ye,R-lt),r.arc(i+f,o-u,x,R-lt,R),r.arc(i+u,o+f,x,R,R+lt),r.arc(i-f,o+u,x,R+lt,R+ye),r.closePath();break;case"rect":if(!w){m=Math.SQRT1_2*A,r.rect(i-m,o-m,2*m,2*m);break}R+=qt;case"rectRot":u=Math.cos(R)*A,f=Math.sin(R)*A,r.moveTo(i-u,o-f),r.lineTo(i+f,o-u),r.lineTo(i+u,o+f),r.lineTo(i-f,o+u),r.closePath();break;case"crossRot":R+=qt;case"cross":u=Math.cos(R)*A,f=Math.sin(R)*A,r.moveTo(i-u,o-f),r.lineTo(i+u,o+f),r.moveTo(i+f,o-u),r.lineTo(i-f,o+u);break;case"star":u=Math.cos(R)*A,f=Math.sin(R)*A,r.moveTo(i-u,o-f),r.lineTo(i+u,o+f),r.moveTo(i+f,o-u),r.lineTo(i-f,o+u),R+=qt,u=Math.cos(R)*A,f=Math.sin(R)*A,r.moveTo(i-u,o-f),r.lineTo(i+u,o+f),r.moveTo(i+f,o-u),r.lineTo(i-f,o+u);break;case"line":u=Math.cos(R)*A,f=Math.sin(R)*A,r.moveTo(i-u,o-f),r.lineTo(i+u,o+f);break;case"dash":r.moveTo(i,o),r.lineTo(i+Math.cos(R)*A,o+Math.sin(R)*A);break}r.fill(),n.borderWidth>0&&r.stroke()}}function $n(r,n,i){return i=i||.5,!n||r&&r.x>n.left-i&&r.x<n.right+i&&r.y>n.top-i&&r.y<n.bottom+i}function Fs(r,n){r.save(),r.beginPath(),r.rect(n.left,n.top,n.right-n.left,n.bottom-n.top),r.clip()}function ks(r){r.restore()}function Ic(r,n,i,o,l){if(!n)return r.lineTo(i.x,i.y);if(l==="middle"){const u=(n.x+i.x)/2;r.lineTo(u,n.y),r.lineTo(u,i.y)}else l==="after"!=!!o?r.lineTo(n.x,i.y):r.lineTo(i.x,n.y);r.lineTo(i.x,i.y)}function Fc(r,n,i,o){if(!n)return r.lineTo(i.x,i.y);r.bezierCurveTo(o?n.cp1x:n.cp2x,o?n.cp1y:n.cp2y,o?i.cp2x:i.cp1x,o?i.cp2y:i.cp1y,i.x,i.y)}function Zn(r,n,i,o,l,u={}){const f=gt(n)?n:[n],m=u.strokeWidth>0&&u.strokeColor!=="";let x,y;for(r.save(),r.font=l.string,dp(r,u),x=0;x<f.length;++x)y=f[x],m&&(u.strokeColor&&(r.strokeStyle=u.strokeColor),at(u.strokeWidth)||(r.lineWidth=u.strokeWidth),r.strokeText(y,i,o,u.maxWidth)),r.fillText(y,i,o,u.maxWidth),fp(r,i,o,y,u),o+=l.lineHeight;r.restore()}function dp(r,n){n.translation&&r.translate(n.translation[0],n.translation[1]),at(n.rotation)||r.rotate(n.rotation),n.color&&(r.fillStyle=n.color),n.textAlign&&(r.textAlign=n.textAlign),n.textBaseline&&(r.textBaseline=n.textBaseline)}function fp(r,n,i,o,l){if(l.strikethrough||l.underline){const u=r.measureText(o),f=n-u.actualBoundingBoxLeft,m=n+u.actualBoundingBoxRight,x=i-u.actualBoundingBoxAscent,y=i+u.actualBoundingBoxDescent,w=l.strikethrough?(x+y)/2:y;r.strokeStyle=r.fillStyle,r.beginPath(),r.lineWidth=l.decorationWidth||2,r.moveTo(f,w),r.lineTo(m,w),r.stroke()}}function Os(r,n){const{x:i,y:o,w:l,h:u,radius:f}=n;r.arc(i+f.topLeft,o+f.topLeft,f.topLeft,-lt,ye,!0),r.lineTo(i,o+u-f.bottomLeft),r.arc(i+f.bottomLeft,o+u-f.bottomLeft,f.bottomLeft,ye,lt,!0),r.lineTo(i+l-f.bottomRight,o+u),r.arc(i+l-f.bottomRight,o+u-f.bottomRight,f.bottomRight,lt,0,!0),r.lineTo(i+l,o+f.topRight),r.arc(i+l-f.topRight,o+f.topRight,f.topRight,0,-lt,!0),r.lineTo(i+f.topLeft,o)}function Fr(r,n,i){i=i||(f=>r[f]<n);let o=r.length-1,l=0,u;for(;o-l>1;)u=l+o>>1,i(u)?l=u:o=u;return{lo:l,hi:o}}const Rn=(r,n,i)=>Fr(r,i,o=>r[o][n]<i),kc=(r,n,i)=>Fr(r,i,o=>r[o][n]>=i);function Oc(r,n,i){let o=0,l=r.length;for(;o<l&&r[o]<n;)o++;for(;l>o&&r[l-1]>i;)l--;return o>0||l<r.length?r.slice(o,l):r}const Bc=["push","pop","shift","splice","unshift"];function zc(r,n){if(r._chartjs){r._chartjs.listeners.push(n);return}Object.defineProperty(r,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[n]}}),Bc.forEach(i=>{const o="_onData"+pn(i),l=r[i];Object.defineProperty(r,i,{configurable:!0,enumerable:!1,value(...u){const f=l.apply(this,u);return r._chartjs.listeners.forEach(m=>{typeof m[o]=="function"&&m[o](...u)}),f}})})}function ma(r,n){const i=r._chartjs;if(!i)return;const o=i.listeners,l=o.indexOf(n);l!==-1&&o.splice(l,1),!(o.length>0)&&(Bc.forEach(u=>{delete r[u]}),delete r._chartjs)}function ga(r){const n=new Set;let i,o;for(i=0,o=r.length;i<o;++i)n.add(r[i]);return n.size===o?r:Array.from(n)}function xa(){return typeof window!="undefined"&&typeof document!="undefined"}function vi(r){let n=r.parentNode;return n&&n.toString()==="[object ShadowRoot]"&&(n=n.host),n}function kr(r,n,i){let o;return typeof r=="string"?(o=parseInt(r,10),r.indexOf("%")!==-1&&(o=o/100*n.parentNode[i])):o=r,o}const Or=r=>window.getComputedStyle(r,null);function Nc(r,n){return Or(r).getPropertyValue(n)}const pp=["top","right","bottom","left"];function bi(r,n,i){const o={};i=i?"-"+i:"";for(let l=0;l<4;l++){const u=pp[l];o[u]=parseFloat(r[n+"-"+u+i])||0}return o.width=o.left+o.right,o.height=o.top+o.bottom,o}const mp=(r,n,i)=>(r>0||n>0)&&(!i||!i.shadowRoot);function gp(r,n){const i=r.native||r,o=i.touches,l=o&&o.length?o[0]:i,{offsetX:u,offsetY:f}=l;let m=!1,x,y;if(mp(u,f,i.target))x=u,y=f;else{const w=n.getBoundingClientRect();x=l.clientX-w.left,y=l.clientY-w.top,m=!0}return{x,y,box:m}}function _a(r,n){const{canvas:i,currentDevicePixelRatio:o}=n,l=Or(i),u=l.boxSizing==="border-box",f=bi(l,"padding"),m=bi(l,"border","width"),{x,y,box:w}=gp(r,i),A=f.left+(w&&m.left),R=f.top+(w&&m.top);let{width:O,height:U}=n;return u&&(O-=f.width+m.width,U-=f.height+m.height),{x:Math.round((x-A)/O*i.width/o),y:Math.round((y-R)/U*i.height/o)}}function xp(r,n,i){let o,l;if(n===void 0||i===void 0){const u=vi(r);if(!u)n=r.clientWidth,i=r.clientHeight;else{const f=u.getBoundingClientRect(),m=Or(u),x=bi(m,"border","width"),y=bi(m,"padding");n=f.width-y.width-x.width,i=f.height-y.height-x.height,o=kr(m.maxWidth,u,"clientWidth"),l=kr(m.maxHeight,u,"clientHeight")}}return{width:n,height:i,maxWidth:o||j,maxHeight:l||j}}const ya=r=>Math.round(r*10)/10;function Vc(r,n,i,o){const l=Or(r),u=bi(l,"margin"),f=kr(l.maxWidth,r,"clientWidth")||j,m=kr(l.maxHeight,r,"clientHeight")||j,x=xp(r,n,i);let{width:y,height:w}=x;if(l.boxSizing==="content-box"){const A=bi(l,"border","width"),R=bi(l,"padding");y-=R.width+A.width,w-=R.height+A.height}return y=Math.max(0,y-u.width),w=Math.max(0,o?Math.floor(y/o):w-u.height),y=ya(Math.min(y,f,x.maxWidth)),w=ya(Math.min(w,m,x.maxHeight)),y&&!w&&(w=ya(y/2)),{width:y,height:w}}function va(r,n,i){const o=n||1,l=Math.floor(r.height*o),u=Math.floor(r.width*o);r.height=l/o,r.width=u/o;const f=r.canvas;return f.style&&(i||!f.style.height&&!f.style.width)&&(f.style.height=`${r.height}px`,f.style.width=`${r.width}px`),r.currentDevicePixelRatio!==o||f.height!==l||f.width!==u?(r.currentDevicePixelRatio=o,f.height=l,f.width=u,r.ctx.setTransform(o,0,0,o,0,0),!0):!1}const Uc=function(){let r=!1;try{const n={get passive(){return r=!0,!1}};window.addEventListener("test",null,n),window.removeEventListener("test",null,n)}catch(n){}return r}();function ba(r,n){const i=Nc(r,n),o=i&&i.match(/^(\d+)(\.\d+)?px$/);return o?+o[1]:void 0}function Bs(r,n){return"native"in r?{x:r.x,y:r.y}:_a(r,n)}function _p(r,n){const i=r.getSortedVisibleDatasetMetas();let o,l,u;for(let f=0,m=i.length;f<m;++f){({index:o,data:l}=i[f]);for(let x=0,y=l.length;x<y;++x)u=l[x],u.skip||n(u,o,x)}}function yp(r,n,i,o){const{controller:l,data:u,_sorted:f}=r,m=l._cachedMeta.iScale;if(m&&n===m.axis&&f&&u.length){const x=m._reversePixels?kc:Rn;if(o){if(l._sharedOptions){const y=u[0],w=typeof y.getRange=="function"&&y.getRange(n);if(w){const A=x(u,n,i-w),R=x(u,n,i+w);return{lo:A.lo,hi:R.hi}}}}else return x(u,n,i)}return{lo:0,hi:u.length-1}}function Hc(r,n,i,o,l){const u=r.getSortedVisibleDatasetMetas(),f=i[n];for(let m=0,x=u.length;m<x;++m){const{index:y,data:w}=u[m],{lo:A,hi:R}=yp(u[m],n,f,l);for(let O=A;O<=R;++O){const U=w[O];U.skip||o(U,y,O)}}}function vp(r){const n=r.indexOf("x")!==-1,i=r.indexOf("y")!==-1;return function(o,l){const u=n?Math.abs(o.x-l.x):0,f=i?Math.abs(o.y-l.y):0;return Math.sqrt(Math.pow(u,2)+Math.pow(f,2))}}function Ma(r,n,i,o){const l=[];return $n(n,r.chartArea,r._minPadding)&&Hc(r,i,n,function(f,m,x){f.inRange(n.x,n.y,o)&&l.push({element:f,datasetIndex:m,index:x})},!0),l}function wa(r,n,i,o,l){const u=vp(i);let f=Number.POSITIVE_INFINITY,m=[];return $n(n,r.chartArea,r._minPadding)&&Hc(r,i,n,function(y,w,A){if(o&&!y.inRange(n.x,n.y,l))return;const R=y.getCenterPoint(l);if(!$n(R,r.chartArea,r._minPadding)&&!y.inRange(n.x,n.y,l))return;const O=u(n,R);O<f?(m=[{element:y,datasetIndex:w,index:A}],f=O):O===f&&m.push({element:y,datasetIndex:w,index:A})}),m}function Wc(r,n,i,o){const l=Bs(n,r),u=[],f=i.axis,m=f==="x"?"inXRange":"inYRange";let x=!1;return _p(r,(y,w,A)=>{y[m](l[f],o)&&u.push({element:y,datasetIndex:w,index:A}),y.inRange(l.x,l.y,o)&&(x=!0)}),i.intersect&&!x?[]:u}var Gc={modes:{index(r,n,i,o){const l=Bs(n,r),u=i.axis||"x",f=i.intersect?Ma(r,l,u,o):wa(r,l,u,!1,o),m=[];return f.length?(r.getSortedVisibleDatasetMetas().forEach(x=>{const y=f[0].index,w=x.data[y];w&&!w.skip&&m.push({element:w,datasetIndex:x.index,index:y})}),m):[]},dataset(r,n,i,o){const l=Bs(n,r),u=i.axis||"xy";let f=i.intersect?Ma(r,l,u,o):wa(r,l,u,!1,o);if(f.length>0){const m=f[0].datasetIndex,x=r.getDatasetMeta(m).data;f=[];for(let y=0;y<x.length;++y)f.push({element:x[y],datasetIndex:m,index:y})}return f},point(r,n,i,o){const l=Bs(n,r),u=i.axis||"xy";return Ma(r,l,u,o)},nearest(r,n,i,o){const l=Bs(n,r),u=i.axis||"xy";return wa(r,l,u,i.intersect,o)},x(r,n,i,o){return i.axis="x",Wc(r,n,i,o)},y(r,n,i,o){return i.axis="y",Wc(r,n,i,o)}}};const bp=new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/),Mp=new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);function Xc(r,n){const i=(""+r).match(bp);if(!i||i[1]==="normal")return n*1.2;switch(r=+i[2],i[3]){case"px":return r;case"%":r/=100;break}return n*r}const wp=r=>+r||0;function Br(r,n){const i={},o=Et(n),l=o?Object.keys(n):n,u=Et(r)?o?f=>ft(r[f],r[n[f]]):f=>r[f]:()=>r;for(const f of l)i[f]=wp(u(f));return i}function Sa(r){return Br(r,{top:"y",right:"x",bottom:"y",left:"x"})}function zr(r){return Br(r,["topLeft","topRight","bottomLeft","bottomRight"])}function je(r){const n=Sa(r);return n.width=n.left+n.right,n.height=n.top+n.bottom,n}function Ce(r,n){r=r||{},n=n||ie.font;let i=ft(r.size,n.size);typeof i=="string"&&(i=parseInt(i,10));let o=ft(r.style,n.style);o&&!(""+o).match(Mp)&&(console.warn('Invalid font style specified: "'+o+'"'),o="");const l={family:ft(r.family,n.family),lineHeight:Xc(ft(r.lineHeight,n.lineHeight),i),size:i,style:o,weight:ft(r.weight,n.weight),string:""};return l.string=Pc(l),l}function ki(r,n,i,o){let l=!0,u,f,m;for(u=0,f=r.length;u<f;++u)if(m=r[u],m!==void 0&&(n!==void 0&&typeof m=="function"&&(m=m(n),l=!1),i!==void 0&&gt(m)&&(m=m[i%m.length],l=!1),m!==void 0))return o&&!l&&(o.cacheable=!1),m}function jc(r,n){const{min:i,max:o}=r;return{min:i-Math.abs(Lt(n,i)),max:o+Lt(n,o)}}const qc=["left","top","right","bottom"];function zs(r,n){return r.filter(i=>i.pos===n)}function Yc(r,n){return r.filter(i=>qc.indexOf(i.pos)===-1&&i.box.axis===n)}function Ns(r,n){return r.sort((i,o)=>{const l=n?o:i,u=n?i:o;return l.weight===u.weight?l.index-u.index:l.weight-u.weight})}function Sp(r){const n=[];let i,o,l,u,f,m;for(i=0,o=(r||[]).length;i<o;++i)l=r[i],{position:u,options:{stack:f,stackWeight:m=1}}=l,n.push({index:i,box:l,pos:u,horizontal:l.isHorizontal(),weight:l.weight,stack:f&&u+f,stackWeight:m});return n}function Tp(r){const n={};for(const i of r){const{stack:o,pos:l,stackWeight:u}=i;if(!o||!qc.includes(l))continue;const f=n[o]||(n[o]={count:0,placed:0,weight:0,size:0});f.count++,f.weight+=u}return n}function Ep(r,n){const i=Tp(r),{vBoxMaxWidth:o,hBoxMaxHeight:l}=n;let u,f,m;for(u=0,f=r.length;u<f;++u){m=r[u];const{fullSize:x}=m.box,y=i[m.stack],w=y&&m.stackWeight/y.weight;m.horizontal?(m.width=w?w*o:x&&n.availableWidth,m.height=l):(m.width=o,m.height=w?w*l:x&&n.availableHeight)}return i}function Ap(r){const n=Sp(r),i=Ns(n.filter(y=>y.box.fullSize),!0),o=Ns(zs(n,"left"),!0),l=Ns(zs(n,"right")),u=Ns(zs(n,"top"),!0),f=Ns(zs(n,"bottom")),m=Yc(n,"x"),x=Yc(n,"y");return{fullSize:i,leftAndTop:o.concat(u),rightAndBottom:l.concat(x).concat(f).concat(m),chartArea:zs(n,"chartArea"),vertical:o.concat(l).concat(x),horizontal:u.concat(f).concat(m)}}function $c(r,n,i,o){return Math.max(r[i],n[i])+Math.max(r[o],n[o])}function Zc(r,n){r.top=Math.max(r.top,n.top),r.left=Math.max(r.left,n.left),r.bottom=Math.max(r.bottom,n.bottom),r.right=Math.max(r.right,n.right)}function Lp(r,n,i,o){const{pos:l,box:u}=i,f=r.maxPadding;if(!Et(l)){i.size&&(r[l]-=i.size);const A=o[i.stack]||{size:0,count:1};A.size=Math.max(A.size,i.horizontal?u.height:u.width),i.size=A.size/A.count,r[l]+=i.size}u.getPadding&&Zc(f,u.getPadding());const m=Math.max(0,n.outerWidth-$c(f,r,"left","right")),x=Math.max(0,n.outerHeight-$c(f,r,"top","bottom")),y=m!==r.w,w=x!==r.h;return r.w=m,r.h=x,i.horizontal?{same:y,other:w}:{same:w,other:y}}function Cp(r){const n=r.maxPadding;function i(o){const l=Math.max(n[o]-r[o],0);return r[o]+=l,l}r.y+=i("top"),r.x+=i("left"),i("right"),i("bottom")}function Rp(r,n){const i=n.maxPadding;function o(l){const u={left:0,top:0,right:0,bottom:0};return l.forEach(f=>{u[f]=Math.max(n[f],i[f])}),u}return o(r?["left","right"]:["top","bottom"])}function Vs(r,n,i,o){const l=[];let u,f,m,x,y,w;for(u=0,f=r.length,y=0;u<f;++u){m=r[u],x=m.box,x.update(m.width||n.w,m.height||n.h,Rp(m.horizontal,n));const{same:A,other:R}=Lp(n,i,m,o);y|=A&&l.length,w=w||R,x.fullSize||l.push(m)}return y&&Vs(l,n,i,o)||w}function Nr(r,n,i,o,l){r.top=i,r.left=n,r.right=n+o,r.bottom=i+l,r.width=o,r.height=l}function Jc(r,n,i,o){const l=i.padding;let{x:u,y:f}=n;for(const m of r){const x=m.box,y=o[m.stack]||{count:1,placed:0,weight:1},w=m.stackWeight/y.weight||1;if(m.horizontal){const A=n.w*w,R=y.size||x.height;Be(y.start)&&(f=y.start),x.fullSize?Nr(x,l.left,f,i.outerWidth-l.right-l.left,R):Nr(x,n.left+y.placed,f,A,R),y.start=f,y.placed+=A,f=x.bottom}else{const A=n.h*w,R=y.size||x.width;Be(y.start)&&(u=y.start),x.fullSize?Nr(x,u,l.top,R,i.outerHeight-l.bottom-l.top):Nr(x,u,n.top+y.placed,R,A),y.start=u,y.placed+=A,u=x.right}}n.x=u,n.y=f}ie.set("layout",{padding:{top:0,right:0,bottom:0,left:0}});var He={addBox(r,n){r.boxes||(r.boxes=[]),n.fullSize=n.fullSize||!1,n.position=n.position||"top",n.weight=n.weight||0,n._layers=n._layers||function(){return[{z:0,draw(i){n.draw(i)}}]},r.boxes.push(n)},removeBox(r,n){const i=r.boxes?r.boxes.indexOf(n):-1;i!==-1&&r.boxes.splice(i,1)},configure(r,n,i){n.fullSize=i.fullSize,n.position=i.position,n.weight=i.weight},update(r,n,i,o){if(!r)return;const l=je(r.options.layout.padding),u=Math.max(n-l.width,0),f=Math.max(i-l.height,0),m=Ap(r.boxes),x=m.vertical,y=m.horizontal;mt(r.boxes,H=>{typeof H.beforeLayout=="function"&&H.beforeLayout()});const w=x.reduce((H,q)=>q.box.options&&q.box.options.display===!1?H:H+1,0)||1,A=Object.freeze({outerWidth:n,outerHeight:i,padding:l,availableWidth:u,availableHeight:f,vBoxMaxWidth:u/2/w,hBoxMaxHeight:f/2}),R=Object.assign({},l);Zc(R,je(o));const O=Object.assign({maxPadding:R,w:u,h:f,x:l.left,y:l.top},l),U=Ep(x.concat(y),A);Vs(m.fullSize,O,A,U),Vs(x,O,A,U),Vs(y,O,A,U)&&Vs(x,O,A,U),Cp(O),Jc(m.leftAndTop,O,A,U),O.x+=O.w,O.y+=O.h,Jc(m.rightAndBottom,O,A,U),r.chartArea={left:O.left,top:O.top,right:O.left+O.w,bottom:O.top+O.h,height:O.h,width:O.w},mt(m.chartArea,H=>{const q=H.box;Object.assign(q,r.chartArea),q.update(O.w,O.h)})}};function Vr(r,n=[""],i=r,o,l=()=>r[0]){Be(o)||(o=nu("_fallback",r));const u={[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:r,_rootScopes:i,_fallback:o,_getTarget:l,override:f=>Vr([f,...r],n,i,o)};return new Proxy(u,{deleteProperty(f,m){return delete f[m],delete f._keys,delete r[0][m],!0},get(f,m){return Qc(f,m,()=>zp(m,n,r,f))},getOwnPropertyDescriptor(f,m){return Reflect.getOwnPropertyDescriptor(f._scopes[0],m)},getPrototypeOf(){return Reflect.getPrototypeOf(r[0])},has(f,m){return iu(f).includes(m)},ownKeys(f){return iu(f)},set(f,m,x){const y=f._storage||(f._storage=l());return y[m]=x,delete f[m],delete f._keys,!0}})}function Mi(r,n,i,o){const l={_cacheable:!1,_proxy:r,_context:n,_subProxy:i,_stack:new Set,_descriptors:Ta(r,o),setContext:u=>Mi(r,u,i,o),override:u=>Mi(r.override(u),n,i,o)};return new Proxy(l,{deleteProperty(u,f){return delete u[f],delete r[f],!0},get(u,f,m){return Qc(u,f,()=>Dp(u,f,m))},getOwnPropertyDescriptor(u,f){return u._descriptors.allKeys?Reflect.has(r,f)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(r,f)},getPrototypeOf(){return Reflect.getPrototypeOf(r)},has(u,f){return Reflect.has(r,f)},ownKeys(){return Reflect.ownKeys(r)},set(u,f,m){return r[f]=m,delete u[f],!0}})}function Ta(r,n={scriptable:!0,indexable:!0}){const{_scriptable:i=n.scriptable,_indexable:o=n.indexable,_allKeys:l=n.allKeys}=r;return{allKeys:l,scriptable:i,indexable:o,isScriptable:An(i)?i:()=>i,isIndexable:An(o)?o:()=>o}}const Pp=(r,n)=>r?r+pn(n):n,Kc=(r,n)=>Et(n)&&r!=="adapters";function Qc(r,n,i){let o=r[n];return Be(o)||(o=i(),Be(o)&&(r[n]=o)),o}function Dp(r,n,i){const{_proxy:o,_context:l,_subProxy:u,_descriptors:f}=r;let m=o[n];return An(m)&&f.isScriptable(n)&&(m=Ip(n,m,r,i)),gt(m)&&m.length&&(m=Fp(n,m,r,f.isIndexable)),Kc(n,m)&&(m=Mi(m,l,u&&u[n],f)),m}function Ip(r,n,i,o){const{_proxy:l,_context:u,_subProxy:f,_stack:m}=i;if(m.has(r))throw new Error("Recursion detected: "+Array.from(m).join("->")+"->"+r);return m.add(r),n=n(u,f||o),m.delete(r),Et(n)&&(n=Ea(l._scopes,l,r,n)),n}function Fp(r,n,i,o){const{_proxy:l,_context:u,_subProxy:f,_descriptors:m}=i;if(Be(u.index)&&o(r))n=n[u.index%n.length];else if(Et(n[0])){const x=n,y=l._scopes.filter(w=>w!==x);n=[];for(const w of x){const A=Ea(y,l,r,w);n.push(Mi(A,u,f&&f[r],m))}}return n}function tu(r,n,i){return An(r)?r(n,i):r}const kp=(r,n)=>r===!0?n:typeof r=="string"?fn(n,r):void 0;function Op(r,n,i,o){for(const l of n){const u=kp(i,l);if(u){r.add(u);const f=tu(u._fallback,i,u);if(Be(f)&&f!==i&&f!==o)return f}else if(u===!1&&Be(o)&&i!==o)return null}return!1}function Ea(r,n,i,o){const l=n._rootScopes,u=tu(n._fallback,i,o),f=[...r,...l],m=new Set;m.add(o);let x=eu(m,f,i,u||i);return x===null||Be(u)&&u!==i&&(x=eu(m,f,u,x),x===null)?!1:Vr(Array.from(m),[""],l,u,()=>Bp(n,i,o))}function eu(r,n,i,o){for(;i;)i=Op(r,n,i,o);return i}function Bp(r,n,i){const o=r._getTarget();n in o||(o[n]={});const l=o[n];return gt(l)&&Et(i)?i:l}function zp(r,n,i,o){let l;for(const u of n)if(l=nu(Pp(u,r),i),Be(l))return Kc(r,l)?Ea(i,o,r,l):l}function nu(r,n){for(const i of n){if(!i)continue;const o=i[r];if(Be(o))return o}}function iu(r){let n=r._keys;return n||(n=r._keys=Np(r._scopes)),n}function Np(r){const n=new Set;for(const i of r)for(const o of Object.keys(i).filter(l=>!l.startsWith("_")))n.add(o);return Array.from(n)}const Vp=Number.EPSILON||1e-14,Oi=(r,n)=>n<r.length&&!r[n].skip&&r[n],su=r=>r==="x"?"y":"x";function ru(r,n,i,o){const l=r.skip?n:r,u=n,f=i.skip?n:i,m=Cn(u,l),x=Cn(f,u);let y=m/(m+x),w=x/(m+x);y=isNaN(y)?0:y,w=isNaN(w)?0:w;const A=o*y,R=o*w;return{previous:{x:u.x-A*(f.x-l.x),y:u.y-A*(f.y-l.y)},next:{x:u.x+R*(f.x-l.x),y:u.y+R*(f.y-l.y)}}}function Up(r,n,i){const o=r.length;let l,u,f,m,x,y=Oi(r,0);for(let w=0;w<o-1;++w)if(x=y,y=Oi(r,w+1),!(!x||!y)){if(fe(n[w],0,Vp)){i[w]=i[w+1]=0;continue}l=i[w]/n[w],u=i[w+1]/n[w],m=Math.pow(l,2)+Math.pow(u,2),!(m<=9)&&(f=3/Math.sqrt(m),i[w]=l*f*n[w],i[w+1]=u*f*n[w])}}function Hp(r,n,i="x"){const o=su(i),l=r.length;let u,f,m,x=Oi(r,0);for(let y=0;y<l;++y){if(f=m,m=x,x=Oi(r,y+1),!m)continue;const w=m[i],A=m[o];f&&(u=(w-f[i])/3,m[`cp1${i}`]=w-u,m[`cp1${o}`]=A-u*n[y]),x&&(u=(x[i]-w)/3,m[`cp2${i}`]=w+u,m[`cp2${o}`]=A+u*n[y])}}function ou(r,n="x"){const i=su(n),o=r.length,l=Array(o).fill(0),u=Array(o);let f,m,x,y=Oi(r,0);for(f=0;f<o;++f)if(m=x,x=y,y=Oi(r,f+1),!!x){if(y){const w=y[n]-x[n];l[f]=w!==0?(y[i]-x[i])/w:0}u[f]=m?y?Yt(l[f-1])!==Yt(l[f])?0:(l[f-1]+l[f])/2:l[f-1]:l[f]}Up(r,l,u),Hp(r,u,n)}function Ur(r,n,i){return Math.max(Math.min(r,i),n)}function Wp(r,n){let i,o,l,u,f,m=$n(r[0],n);for(i=0,o=r.length;i<o;++i)f=u,u=m,m=i<o-1&&$n(r[i+1],n),!!u&&(l=r[i],f&&(l.cp1x=Ur(l.cp1x,n.left,n.right),l.cp1y=Ur(l.cp1y,n.top,n.bottom)),m&&(l.cp2x=Ur(l.cp2x,n.left,n.right),l.cp2y=Ur(l.cp2y,n.top,n.bottom)))}function au(r,n,i,o,l){let u,f,m,x;if(n.spanGaps&&(r=r.filter(y=>!y.skip)),n.cubicInterpolationMode==="monotone")ou(r,l);else{let y=o?r[r.length-1]:r[0];for(u=0,f=r.length;u<f;++u)m=r[u],x=ru(y,m,r[Math.min(u+1,f-(o?0:1))%f],n.tension),m.cp1x=x.previous.x,m.cp1y=x.previous.y,m.cp2x=x.next.x,m.cp2y=x.next.y,y=m}n.capBezierPoints&&Wp(r,i)}const Hr=r=>r===0||r===1,lu=(r,n,i)=>-(Math.pow(2,10*(r-=1))*Math.sin((r-n)*P/i)),cu=(r,n,i)=>Math.pow(2,-10*r)*Math.sin((r-n)*P/i)+1,Bi={linear:r=>r,easeInQuad:r=>r*r,easeOutQuad:r=>-r*(r-2),easeInOutQuad:r=>(r/=.5)<1?.5*r*r:-.5*(--r*(r-2)-1),easeInCubic:r=>r*r*r,easeOutCubic:r=>(r-=1)*r*r+1,easeInOutCubic:r=>(r/=.5)<1?.5*r*r*r:.5*((r-=2)*r*r+2),easeInQuart:r=>r*r*r*r,easeOutQuart:r=>-((r-=1)*r*r*r-1),easeInOutQuart:r=>(r/=.5)<1?.5*r*r*r*r:-.5*((r-=2)*r*r*r-2),easeInQuint:r=>r*r*r*r*r,easeOutQuint:r=>(r-=1)*r*r*r*r+1,easeInOutQuint:r=>(r/=.5)<1?.5*r*r*r*r*r:.5*((r-=2)*r*r*r*r+2),easeInSine:r=>-Math.cos(r*lt)+1,easeOutSine:r=>Math.sin(r*lt),easeInOutSine:r=>-.5*(Math.cos(ye*r)-1),easeInExpo:r=>r===0?0:Math.pow(2,10*(r-1)),easeOutExpo:r=>r===1?1:-Math.pow(2,-10*r)+1,easeInOutExpo:r=>Hr(r)?r:r<.5?.5*Math.pow(2,10*(r*2-1)):.5*(-Math.pow(2,-10*(r*2-1))+2),easeInCirc:r=>r>=1?r:-(Math.sqrt(1-r*r)-1),easeOutCirc:r=>Math.sqrt(1-(r-=1)*r),easeInOutCirc:r=>(r/=.5)<1?-.5*(Math.sqrt(1-r*r)-1):.5*(Math.sqrt(1-(r-=2)*r)+1),easeInElastic:r=>Hr(r)?r:lu(r,.075,.3),easeOutElastic:r=>Hr(r)?r:cu(r,.075,.3),easeInOutElastic(r){const n=.1125,i=.45;return Hr(r)?r:r<.5?.5*lu(r*2,n,i):.5+.5*cu(r*2-1,n,i)},easeInBack(r){const n=1.70158;return r*r*((n+1)*r-n)},easeOutBack(r){const n=1.70158;return(r-=1)*r*((n+1)*r+n)+1},easeInOutBack(r){let n=1.70158;return(r/=.5)<1?.5*(r*r*(((n*=1.525)+1)*r-n)):.5*((r-=2)*r*(((n*=1.525)+1)*r+n)+2)},easeInBounce:r=>1-Bi.easeOutBounce(1-r),easeOutBounce(r){const n=7.5625,i=2.75;return r<1/i?n*r*r:r<2/i?n*(r-=1.5/i)*r+.75:r<2.5/i?n*(r-=2.25/i)*r+.9375:n*(r-=2.625/i)*r+.984375},easeInOutBounce:r=>r<.5?Bi.easeInBounce(r*2)*.5:Bi.easeOutBounce(r*2-1)*.5+.5};function Jn(r,n,i,o){return{x:r.x+i*(n.x-r.x),y:r.y+i*(n.y-r.y)}}function uu(r,n,i,o){return{x:r.x+i*(n.x-r.x),y:o==="middle"?i<.5?r.y:n.y:o==="after"?i<1?r.y:n.y:i>0?n.y:r.y}}function hu(r,n,i,o){const l={x:r.cp2x,y:r.cp2y},u={x:n.cp1x,y:n.cp1y},f=Jn(r,l,i),m=Jn(l,u,i),x=Jn(u,n,i),y=Jn(f,m,i),w=Jn(m,x,i);return Jn(y,w,i)}const du=new Map;function Gp(r,n){n=n||{};const i=r+JSON.stringify(n);let o=du.get(i);return o||(o=new Intl.NumberFormat(r,n),du.set(i,o)),o}function zi(r,n,i){return Gp(n,i).format(r)}const Xp=function(r,n){return{x(i){return r+r+n-i},setWidth(i){n=i},textAlign(i){return i==="center"?i:i==="right"?"left":"right"},xPlus(i,o){return i-o},leftForLtr(i,o){return i-o}}},jp=function(){return{x(r){return r},setWidth(r){},textAlign(r){return r},xPlus(r,n){return r+n},leftForLtr(r,n){return r}}};function wi(r,n,i){return r?Xp(n,i):jp()}function Aa(r,n){let i,o;(n==="ltr"||n==="rtl")&&(i=r.canvas.style,o=[i.getPropertyValue("direction"),i.getPropertyPriority("direction")],i.setProperty("direction",n,"important"),r.prevTextDirection=o)}function La(r,n){n!==void 0&&(delete r.prevTextDirection,r.canvas.style.setProperty("direction",n[0],n[1]))}function fu(r){return r==="angle"?{between:Ue,compare:be,normalize:Me}:{between:(n,i,o)=>n>=Math.min(i,o)&&n<=Math.max(o,i),compare:(n,i)=>n-i,normalize:n=>n}}function pu({start:r,end:n,count:i,loop:o,style:l}){return{start:r%i,end:n%i,loop:o&&(n-r+1)%i==0,style:l}}function qp(r,n,i){const{property:o,start:l,end:u}=i,{between:f,normalize:m}=fu(o),x=n.length;let{start:y,end:w,loop:A}=r,R,O;if(A){for(y+=x,w+=x,R=0,O=x;R<O&&f(m(n[y%x][o]),l,u);++R)y--,w--;y%=x,w%=x}return w<y&&(w+=x),{start:y,end:w,loop:A,style:r.style}}function Ca(r,n,i){if(!i)return[r];const{property:o,start:l,end:u}=i,f=n.length,{compare:m,between:x,normalize:y}=fu(o),{start:w,end:A,loop:R,style:O}=qp(r,n,i),U=[];let H=!1,q=null,Z,ct,Tt;const wt=()=>x(l,Tt,Z)&&m(l,Tt)!==0,yt=()=>m(u,Z)===0||x(u,Tt,Z),Dt=()=>H||wt(),Ut=()=>!H||yt();for(let zt=w,Kt=w;zt<=A;++zt)ct=n[zt%f],!ct.skip&&(Z=y(ct[o]),Z!==Tt&&(H=x(Z,l,u),q===null&&Dt()&&(q=m(Z,l)===0?zt:Kt),q!==null&&Ut()&&(U.push(pu({start:q,end:zt,loop:R,count:f,style:O})),q=null),Kt=zt,Tt=Z));return q!==null&&U.push(pu({start:q,end:A,loop:R,count:f,style:O})),U}function Ra(r,n){const i=[],o=r.segments;for(let l=0;l<o.length;l++){const u=Ca(o[l],r.points,n);u.length&&i.push(...u)}return i}function Yp(r,n,i,o){let l=0,u=n-1;if(i&&!o)for(;l<n&&!r[l].skip;)l++;for(;l<n&&r[l].skip;)l++;for(l%=n,i&&(u+=l);u>l&&r[u%n].skip;)u--;return u%=n,{start:l,end:u}}function $p(r,n,i,o){const l=r.length,u=[];let f=n,m=r[n],x;for(x=n+1;x<=i;++x){const y=r[x%l];y.skip||y.stop?m.skip||(o=!1,u.push({start:n%l,end:(x-1)%l,loop:o}),n=f=y.stop?x:null):(f=x,m.skip&&(n=x)),m=y}return f!==null&&u.push({start:n%l,end:f%l,loop:o}),u}function mu(r,n){const i=r.points,o=r.options.spanGaps,l=i.length;if(!l)return[];const u=!!r._loop,{start:f,end:m}=Yp(i,l,u,o);if(o===!0)return gu(r,[{start:f,end:m,loop:u}],i,n);const x=m<f?m+l:m,y=!!r._fullLoop&&f===0&&m===l-1;return gu(r,$p(i,f,x,y),i,n)}function gu(r,n,i,o){return!o||!o.setContext||!i?n:Zp(r,n,i,o)}function Zp(r,n,i,o){const l=xu(r.options),u=i.length,f=[];let m=n[0].start,x=m;for(const y of n){let w=l,A=i[m%u],R;for(x=m+1;x<=y.end;x++){const O=i[x%u];R=xu(o.setContext({type:"segment",p0:A,p1:O,p0DataIndex:(x-1)%u,p1DataIndex:x%u,datasetIndex:r._datasetIndex})),Jp(R,w)&&(f.push({start:m,end:x-1,loop:y.loop,style:w}),w=R,m=x-1),A=O,w=R}m<x-1&&(f.push({start:m,end:x-1,loop:y.loop,style:R}),m=x-1)}return f}function xu(r){return{backgroundColor:r.backgroundColor,borderCapStyle:r.borderCapStyle,borderDash:r.borderDash,borderDashOffset:r.borderDashOffset,borderJoinStyle:r.borderJoinStyle,borderWidth:r.borderWidth,borderColor:r.borderColor}}function Jp(r,n){return n&&JSON.stringify(r)!==JSON.stringify(n)}var Kp=Object.freeze({__proto__:null,easingEffects:Bi,color:B,getHoverColor:D,noop:et,uid:bt,isNullOrUndef:at,isArray:gt,isObject:Et,isFinite:At,finiteOrDefault:Vt,valueOrDefault:ft,toPercentage:W,toDimension:Lt,callback:nt,each:mt,_elementsEqual:kt,clone:Qt,_merger:Ie,merge:Je,mergeIf:me,_mergerIf:dn,_deprecated:vn,resolveObjectKey:fn,_capitalize:pn,defined:Be,isFunction:An,setsEqual:Dr,toFontString:Pc,_measureText:Ds,_longestText:Dc,_alignPixel:Yn,clearCanvas:pa,drawPoint:Is,_isPointInArea:$n,clipArea:Fs,unclipArea:ks,_steppedLineTo:Ic,_bezierCurveTo:Fc,renderText:Zn,addRoundedRectPath:Os,_lookup:Fr,_lookupByKey:Rn,_rlookupByKey:kc,_filterBetween:Oc,listenArrayEvents:zc,unlistenArrayEvents:ma,_arrayUnique:ga,_createResolver:Vr,_attachContext:Mi,_descriptors:Ta,splineCurve:ru,splineCurveMonotone:ou,_updateBezierControlPoints:au,_isDomSupported:xa,_getParentNode:vi,getStyle:Nc,getRelativePosition:_a,getMaximumSize:Vc,retinaScale:va,supportsEventListenerOptions:Uc,readUsedSize:ba,fontString:e,requestAnimFrame:s,throttled:a,debounce:h,_toLeftRightCenter:d,_alignStartEnd:p,_textX:g,_pointInLine:Jn,_steppedInterpolation:uu,_bezierInterpolation:hu,formatNumber:zi,toLineHeight:Xc,_readValueToProps:Br,toTRBL:Sa,toTRBLCorners:zr,toPadding:je,toFont:Ce,resolve:ki,_addGrace:jc,PI:ye,TAU:P,PITAU:$,INFINITY:j,RAD_PER_DEG:J,HALF_PI:lt,QUARTER_PI:qt,TWO_THIRDS_PI:Gt,log10:Ot,sign:Yt,niceNum:ce,_factorize:ne,isNumber:te,almostEquals:fe,almostWhole:oe,_setMinAndMaxByKey:Ln,toRadians:ue,toDegrees:ze,_decimalPlaces:qn,getAngleFromPoint:an,distanceBetweenPoints:Cn,_angleDiff:be,_normalizeAngle:Me,_angleBetween:Ue,_limitValue:Fe,_int16Range:Rc,getRtlAdapter:wi,overrideTextDirection:Aa,restoreTextDirection:La,_boundSegment:Ca,_boundSegments:Ra,_computeSegments:mu});class Pa{acquireContext(n,i){}releaseContext(n){return!1}addEventListener(n,i,o){}removeEventListener(n,i,o){}getDevicePixelRatio(){return 1}getMaximumSize(n,i,o,l){return i=Math.max(0,i||n.width),o=o||n.height,{width:i,height:Math.max(0,l?Math.floor(i/l):o)}}isAttached(n){return!0}}class _u extends Pa{acquireContext(n){return n&&n.getContext&&n.getContext("2d")||null}}const Wr="$chartjs",Qp={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},yu=r=>r===null||r==="";function tm(r,n){const i=r.style,o=r.getAttribute("height"),l=r.getAttribute("width");if(r[Wr]={initial:{height:o,width:l,style:{display:i.display,height:i.height,width:i.width}}},i.display=i.display||"block",i.boxSizing=i.boxSizing||"border-box",yu(l)){const u=ba(r,"width");u!==void 0&&(r.width=u)}if(yu(o))if(r.style.height==="")r.height=r.width/(n||2);else{const u=ba(r,"height");u!==void 0&&(r.height=u)}return r}const vu=Uc?{passive:!0}:!1;function em(r,n,i){r.addEventListener(n,i,vu)}function nm(r,n,i){r.canvas.removeEventListener(n,i,vu)}function im(r,n){const i=Qp[r.type]||r.type,{x:o,y:l}=_a(r,n);return{type:i,chart:n,native:r,x:o!==void 0?o:null,y:l!==void 0?l:null}}function sm(r,n,i){const o=r.canvas,u=o&&vi(o)||o,f=new MutationObserver(m=>{const x=vi(u);m.forEach(y=>{for(let w=0;w<y.addedNodes.length;w++){const A=y.addedNodes[w];(A===u||A===x)&&i(y.target)}})});return f.observe(document,{childList:!0,subtree:!0}),f}function rm(r,n,i){const o=r.canvas,l=o&&vi(o);if(!l)return;const u=new MutationObserver(f=>{f.forEach(m=>{for(let x=0;x<m.removedNodes.length;x++)if(m.removedNodes[x]===o){i();break}})});return u.observe(l,{childList:!0}),u}const Us=new Map;let bu=0;function Mu(){const r=window.devicePixelRatio;r!==bu&&(bu=r,Us.forEach((n,i)=>{i.currentDevicePixelRatio!==r&&n()}))}function om(r,n){Us.size||window.addEventListener("resize",Mu),Us.set(r,n)}function am(r){Us.delete(r),Us.size||window.removeEventListener("resize",Mu)}function lm(r,n,i){const o=r.canvas,l=o&&vi(o);if(!l)return;const u=a((m,x)=>{const y=l.clientWidth;i(m,x),y<l.clientWidth&&i()},window),f=new ResizeObserver(m=>{const x=m[0],y=x.contentRect.width,w=x.contentRect.height;y===0&&w===0||u(y,w)});return f.observe(l),om(r,u),f}function Da(r,n,i){i&&i.disconnect(),n==="resize"&&am(r)}function cm(r,n,i){const o=r.canvas,l=a(u=>{r.ctx!==null&&i(im(u,r))},r,u=>{const f=u[0];return[f,f.offsetX,f.offsetY]});return em(o,n,l),l}class wu extends Pa{acquireContext(n,i){const o=n&&n.getContext&&n.getContext("2d");return o&&o.canvas===n?(tm(n,i),o):null}releaseContext(n){const i=n.canvas;if(!i[Wr])return!1;const o=i[Wr].initial;["height","width"].forEach(u=>{const f=o[u];at(f)?i.removeAttribute(u):i.setAttribute(u,f)});const l=o.style||{};return Object.keys(l).forEach(u=>{i.style[u]=l[u]}),i.width=i.width,delete i[Wr],!0}addEventListener(n,i,o){this.removeEventListener(n,i);const l=n.$proxies||(n.$proxies={}),f={attach:sm,detach:rm,resize:lm}[i]||cm;l[i]=f(n,i,o)}removeEventListener(n,i){const o=n.$proxies||(n.$proxies={}),l=o[i];if(!l)return;({attach:Da,detach:Da,resize:Da}[i]||nm)(n,i,l),o[i]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(n,i,o,l){return Vc(n,i,o,l)}isAttached(n){const i=vi(n);return!!(i&&i.isConnected)}}function Su(r){return!xa()||typeof OffscreenCanvas!="undefined"&&r instanceof OffscreenCanvas?_u:wu}var Tu=Object.freeze({__proto__:null,_detectPlatform:Su,BasePlatform:Pa,BasicPlatform:_u,DomPlatform:wu});const Eu="transparent",um={boolean(r,n,i){return i>.5?n:r},color(r,n,i){const o=B(r||Eu),l=o.valid&&B(n||Eu);return l&&l.valid?l.mix(o,i).hexString():n},number(r,n,i){return r+(n-r)*i}};class Au{constructor(n,i,o,l){const u=i[o];l=ki([n.to,l,u,n.from]);const f=ki([n.from,u,l]);this._active=!0,this._fn=n.fn||um[n.type||typeof f],this._easing=Bi[n.easing]||Bi.linear,this._start=Math.floor(Date.now()+(n.delay||0)),this._duration=this._total=Math.floor(n.duration),this._loop=!!n.loop,this._target=i,this._prop=o,this._from=f,this._to=l,this._promises=void 0}active(){return this._active}update(n,i,o){const l=this;if(l._active){l._notify(!1);const u=l._target[l._prop],f=o-l._start,m=l._duration-f;l._start=o,l._duration=Math.floor(Math.max(m,n.duration)),l._total+=f,l._loop=!!n.loop,l._to=ki([n.to,i,u,n.from]),l._from=ki([n.from,u,i])}}cancel(){const n=this;n._active&&(n.tick(Date.now()),n._active=!1,n._notify(!1))}tick(n){const i=this,o=n-i._start,l=i._duration,u=i._prop,f=i._from,m=i._loop,x=i._to;let y;if(i._active=f!==x&&(m||o<l),!i._active){i._target[u]=x,i._notify(!0);return}if(o<0){i._target[u]=f;return}y=o/l%2,y=m&&y>1?2-y:y,y=i._easing(Math.min(1,Math.max(0,y))),i._target[u]=i._fn(f,x,y)}wait(){const n=this._promises||(this._promises=[]);return new Promise((i,o)=>{n.push({res:i,rej:o})})}_notify(n){const i=n?"res":"rej",o=this._promises||[];for(let l=0;l<o.length;l++)o[l][i]()}}const hm=["x","y","borderWidth","radius","tension"],dm=["color","borderColor","backgroundColor"];ie.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0});const fm=Object.keys(ie.animation);ie.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:r=>r!=="onProgress"&&r!=="onComplete"&&r!=="fn"}),ie.set("animations",{colors:{type:"color",properties:dm},numbers:{type:"number",properties:hm}}),ie.describe("animations",{_fallback:"animation"}),ie.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:r=>r|0}}}});class Ia{constructor(n,i){this._chart=n,this._properties=new Map,this.configure(i)}configure(n){if(!Et(n))return;const i=this._properties;Object.getOwnPropertyNames(n).forEach(o=>{const l=n[o];if(!Et(l))return;const u={};for(const f of fm)u[f]=l[f];(gt(l.properties)&&l.properties||[o]).forEach(f=>{(f===o||!i.has(f))&&i.set(f,u)})})}_animateOptions(n,i){const o=i.options,l=mm(n,o);if(!l)return[];const u=this._createAnimations(l,o);return o.$shared&&pm(n.options.$animations,o).then(()=>{n.options=o},()=>{}),u}_createAnimations(n,i){const o=this._properties,l=[],u=n.$animations||(n.$animations={}),f=Object.keys(i),m=Date.now();let x;for(x=f.length-1;x>=0;--x){const y=f[x];if(y.charAt(0)==="$")continue;if(y==="options"){l.push(...this._animateOptions(n,i));continue}const w=i[y];let A=u[y];const R=o.get(y);if(A)if(R&&A.active()){A.update(R,w,m);continue}else A.cancel();if(!R||!R.duration){n[y]=w;continue}u[y]=A=new Au(R,n,y,w),l.push(A)}return l}update(n,i){if(this._properties.size===0){Object.assign(n,i);return}const o=this._createAnimations(n,i);if(o.length)return v.add(this._chart,o),!0}}function pm(r,n){const i=[],o=Object.keys(n);for(let l=0;l<o.length;l++){const u=r[o[l]];u&&u.active()&&i.push(u.wait())}return Promise.all(i)}function mm(r,n){if(!n)return;let i=r.options;if(!i){r.options=n;return}return i.$shared&&(r.options=i=Object.assign({},i,{$shared:!1,$animations:{}})),i}function Lu(r,n){const i=r&&r.options||{},o=i.reverse,l=i.min===void 0?n:0,u=i.max===void 0?n:0;return{start:o?u:l,end:o?l:u}}function gm(r,n,i){if(i===!1)return!1;const o=Lu(r,i),l=Lu(n,i);return{top:l.end,right:o.end,bottom:l.start,left:o.start}}function xm(r){let n,i,o,l;return Et(r)?(n=r.top,i=r.right,o=r.bottom,l=r.left):n=i=o=l=r,{top:n,right:i,bottom:o,left:l,disabled:r===!1}}function Cu(r,n){const i=[],o=r._getSortedDatasetMetas(n);let l,u;for(l=0,u=o.length;l<u;++l)i.push(o[l].index);return i}function Ru(r,n,i,o){const l=r.keys,u=o.mode==="single";let f,m,x,y;if(n!==null){for(f=0,m=l.length;f<m;++f){if(x=+l[f],x===i){if(o.all)continue;break}y=r.values[x],At(y)&&(u||n===0||Yt(n)===Yt(y))&&(n+=y)}return n}}function _m(r){const n=Object.keys(r),i=new Array(n.length);let o,l,u;for(o=0,l=n.length;o<l;++o)u=n[o],i[o]={x:u,y:r[u]};return i}function Pu(r,n){const i=r&&r.options.stacked;return i||i===void 0&&n.stack!==void 0}function ym(r,n,i){return`${r.id}.${n.id}.${i.stack||i.type}`}function vm(r){const{min:n,max:i,minDefined:o,maxDefined:l}=r.getUserBounds();return{min:o?n:Number.NEGATIVE_INFINITY,max:l?i:Number.POSITIVE_INFINITY}}function bm(r,n,i){const o=r[n]||(r[n]={});return o[i]||(o[i]={})}function Du(r,n,i){for(const o of n.getMatchingVisibleMetas("bar").reverse()){const l=r[o.index];if(i&&l>0||!i&&l<0)return o.index}return null}function Iu(r,n){const{chart:i,_cachedMeta:o}=r,l=i._stacks||(i._stacks={}),{iScale:u,vScale:f,index:m}=o,x=u.axis,y=f.axis,w=ym(u,f,o),A=n.length;let R;for(let O=0;O<A;++O){const U=n[O],{[x]:H,[y]:q}=U,Z=U._stacks||(U._stacks={});R=Z[y]=bm(l,w,H),R[m]=q,R._top=Du(R,f,!0),R._bottom=Du(R,f,!1)}}function Fa(r,n){const i=r.scales;return Object.keys(i).filter(o=>i[o].axis===n).shift()}function Mm(r,n){return Object.assign(Object.create(r),{active:!1,dataset:void 0,datasetIndex:n,index:n,mode:"default",type:"dataset"})}function wm(r,n,i){return Object.assign(Object.create(r),{active:!1,dataIndex:n,parsed:void 0,raw:void 0,element:i,index:n,mode:"default",type:"data"})}function Hs(r,n){const i=r.controller.index,o=r.vScale&&r.vScale.axis;if(!!o){n=n||r._parsed;for(const l of n){const u=l._stacks;if(!u||u[o]===void 0||u[o][i]===void 0)return;delete u[o][i]}}}const ka=r=>r==="reset"||r==="none",Fu=(r,n)=>n?r:Object.assign({},r);class bn{constructor(n,i){this.chart=n,this._ctx=n.ctx,this.index=i,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.$context=void 0,this._syncList=[],this.initialize()}initialize(){const n=this,i=n._cachedMeta;n.configure(),n.linkScales(),i._stacked=Pu(i.vScale,i),n.addElements()}updateIndex(n){this.index!==n&&Hs(this._cachedMeta),this.index=n}linkScales(){const n=this,i=n.chart,o=n._cachedMeta,l=n.getDataset(),u=(R,O,U,H)=>R==="x"?O:R==="r"?H:U,f=o.xAxisID=ft(l.xAxisID,Fa(i,"x")),m=o.yAxisID=ft(l.yAxisID,Fa(i,"y")),x=o.rAxisID=ft(l.rAxisID,Fa(i,"r")),y=o.indexAxis,w=o.iAxisID=u(y,f,m,x),A=o.vAxisID=u(y,m,f,x);o.xScale=n.getScaleForId(f),o.yScale=n.getScaleForId(m),o.rScale=n.getScaleForId(x),o.iScale=n.getScaleForId(w),o.vScale=n.getScaleForId(A)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(n){return this.chart.scales[n]}_getOtherScale(n){const i=this._cachedMeta;return n===i.iScale?i.vScale:i.iScale}reset(){this._update("reset")}_destroy(){const n=this._cachedMeta;this._data&&ma(this._data,this),n._stacked&&Hs(n)}_dataCheck(){const n=this,i=n.getDataset(),o=i.data||(i.data=[]),l=n._data;if(Et(o))n._data=_m(o);else if(l!==o){if(l){ma(l,n);const u=n._cachedMeta;Hs(u),u._parsed=[]}o&&Object.isExtensible(o)&&zc(o,n),n._syncList=[],n._data=o}}addElements(){const n=this,i=n._cachedMeta;n._dataCheck(),n.datasetElementType&&(i.dataset=new n.datasetElementType)}buildOrUpdateElements(n){const i=this,o=i._cachedMeta,l=i.getDataset();let u=!1;i._dataCheck();const f=o._stacked;o._stacked=Pu(o.vScale,o),o.stack!==l.stack&&(u=!0,Hs(o),o.stack=l.stack),i._resyncElements(n),(u||f!==o._stacked)&&Iu(i,o._parsed)}configure(){const n=this,i=n.chart.config,o=i.datasetScopeKeys(n._type),l=i.getOptionScopes(n.getDataset(),o,!0);n.options=i.createResolver(l,n.getContext()),n._parsing=n.options.parsing}parse(n,i){const o=this,{_cachedMeta:l,_data:u}=o,{iScale:f,_stacked:m}=l,x=f.axis;let y=n===0&&i===u.length?!0:l._sorted,w=n>0&&l._parsed[n-1],A,R,O;if(o._parsing===!1)l._parsed=u,l._sorted=!0,O=u;else{gt(u[n])?O=o.parseArrayData(l,u,n,i):Et(u[n])?O=o.parseObjectData(l,u,n,i):O=o.parsePrimitiveData(l,u,n,i);const U=()=>R[x]===null||w&&R[x]<w[x];for(A=0;A<i;++A)l._parsed[A+n]=R=O[A],y&&(U()&&(y=!1),w=R);l._sorted=y}m&&Iu(o,O)}parsePrimitiveData(n,i,o,l){const{iScale:u,vScale:f}=n,m=u.axis,x=f.axis,y=u.getLabels(),w=u===f,A=new Array(l);let R,O,U;for(R=0,O=l;R<O;++R)U=R+o,A[R]={[m]:w||u.parse(y[U],U),[x]:f.parse(i[U],U)};return A}parseArrayData(n,i,o,l){const{xScale:u,yScale:f}=n,m=new Array(l);let x,y,w,A;for(x=0,y=l;x<y;++x)w=x+o,A=i[w],m[x]={x:u.parse(A[0],w),y:f.parse(A[1],w)};return m}parseObjectData(n,i,o,l){const{xScale:u,yScale:f}=n,{xAxisKey:m="x",yAxisKey:x="y"}=this._parsing,y=new Array(l);let w,A,R,O;for(w=0,A=l;w<A;++w)R=w+o,O=i[R],y[w]={x:u.parse(fn(O,m),R),y:f.parse(fn(O,x),R)};return y}getParsed(n){return this._cachedMeta._parsed[n]}getDataElement(n){return this._cachedMeta.data[n]}applyStack(n,i,o){const l=this.chart,u=this._cachedMeta,f=i[n.axis],m={keys:Cu(l,!0),values:i._stacks[n.axis]};return Ru(m,f,u.index,{mode:o})}updateRangeFromParsed(n,i,o,l){const u=o[i.axis];let f=u===null?NaN:u;const m=l&&o._stacks[i.axis];l&&m&&(l.values=m,n.min=Math.min(n.min,f),n.max=Math.max(n.max,f),f=Ru(l,u,this._cachedMeta.index,{all:!0})),n.min=Math.min(n.min,f),n.max=Math.max(n.max,f)}getMinMax(n,i){const o=this,l=o._cachedMeta,u=l._parsed,f=l._sorted&&n===l.iScale,m=u.length,x=o._getOtherScale(n),y=i&&l._stacked&&{keys:Cu(o.chart,!0),values:null},w={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:A,max:R}=vm(x);let O,U,H,q;function Z(){return H=u[O],U=H[n.axis],q=H[x.axis],!At(U)||A>q||R<q}for(O=0;O<m&&!(!Z()&&(o.updateRangeFromParsed(w,n,H,y),f));++O);if(f){for(O=m-1;O>=0;--O)if(!Z()){o.updateRangeFromParsed(w,n,H,y);break}}return w}getAllParsedValues(n){const i=this._cachedMeta._parsed,o=[];let l,u,f;for(l=0,u=i.length;l<u;++l)f=i[l][n.axis],At(f)&&o.push(f);return o}getMaxOverflow(){return!1}getLabelAndValue(n){const i=this,o=i._cachedMeta,l=o.iScale,u=o.vScale,f=i.getParsed(n);return{label:l?""+l.getLabelForValue(f[l.axis]):"",value:u?""+u.getLabelForValue(f[u.axis]):""}}_update(n){const i=this,o=i._cachedMeta;i.configure(),i._cachedDataOpts={},i.update(n||"default"),o._clip=xm(ft(i.options.clip,gm(o.xScale,o.yScale,i.getMaxOverflow())))}update(n){}draw(){const n=this,i=n._ctx,o=n.chart,l=n._cachedMeta,u=l.data||[],f=o.chartArea,m=[],x=n._drawStart||0,y=n._drawCount||u.length-x;let w;for(l.dataset&&l.dataset.draw(i,f,x,y),w=x;w<x+y;++w){const A=u[w];A.hidden||(A.active?m.push(A):A.draw(i,f))}for(w=0;w<m.length;++w)m[w].draw(i,f)}getStyle(n,i){const o=i?"active":"default";return n===void 0&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(o):this.resolveDataElementOptions(n||0,o)}getContext(n,i,o){const l=this,u=l.getDataset();let f;if(n>=0&&n<l._cachedMeta.data.length){const m=l._cachedMeta.data[n];f=m.$context||(m.$context=wm(l.getContext(),n,m)),f.parsed=l.getParsed(n),f.raw=u.data[n],f.index=f.dataIndex=n}else f=l.$context||(l.$context=Mm(l.chart.getContext(),l.index)),f.dataset=u,f.index=f.datasetIndex=l.index;return f.active=!!i,f.mode=o,f}resolveDatasetElementOptions(n){return this._resolveElementOptions(this.datasetElementType.id,n)}resolveDataElementOptions(n,i){return this._resolveElementOptions(this.dataElementType.id,i,n)}_resolveElementOptions(n,i="default",o){const l=this,u=i==="active",f=l._cachedDataOpts,m=n+"-"+i,x=f[m],y=l.enableOptionSharing&&Be(o);if(x)return Fu(x,y);const w=l.chart.config,A=w.datasetElementScopeKeys(l._type,n),R=u?[`${n}Hover`,"hover",n,""]:[n,""],O=w.getOptionScopes(l.getDataset(),A),U=Object.keys(ie.elements[n]),H=()=>l.getContext(o,u),q=w.resolveNamedOptions(O,U,H,R);return q.$shared&&(q.$shared=y,f[m]=Object.freeze(Fu(q,y))),q}_resolveAnimations(n,i,o){const l=this,u=l.chart,f=l._cachedDataOpts,m=`animation-${i}`,x=f[m];if(x)return x;let y;if(u.options.animation!==!1){const A=l.chart.config,R=A.datasetAnimationScopeKeys(l._type,i),O=A.getOptionScopes(l.getDataset(),R);y=A.createResolver(O,l.getContext(n,o,i))}const w=new Ia(u,y&&y.animations);return y&&y._cacheable&&(f[m]=Object.freeze(w)),w}getSharedOptions(n){if(!!n.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},n))}includeOptions(n,i){return!i||ka(n)||this.chart._animationsDisabled}updateElement(n,i,o,l){ka(l)?Object.assign(n,o):this._resolveAnimations(i,l).update(n,o)}updateSharedOptions(n,i,o){n&&!ka(i)&&this._resolveAnimations(void 0,i).update(n,o)}_setStyle(n,i,o,l){n.active=l;const u=this.getStyle(i,l);this._resolveAnimations(i,o,l).update(n,{options:!l&&this.getSharedOptions(u)||u})}removeHoverStyle(n,i,o){this._setStyle(n,o,"active",!1)}setHoverStyle(n,i,o){this._setStyle(n,o,"active",!0)}_removeDatasetHoverStyle(){const n=this._cachedMeta.dataset;n&&this._setStyle(n,void 0,"active",!1)}_setDatasetHoverStyle(){const n=this._cachedMeta.dataset;n&&this._setStyle(n,void 0,"active",!0)}_resyncElements(n){const i=this,o=i._data,l=i._cachedMeta.data;for(const[x,y,w]of i._syncList)i[x](y,w);i._syncList=[];const u=l.length,f=o.length,m=Math.min(f,u);m&&i.parse(0,m),f>u?i._insertElements(u,f-u,n):f<u&&i._removeElements(f,u-f)}_insertElements(n,i,o=!0){const l=this,u=l._cachedMeta,f=u.data,m=n+i;let x;const y=w=>{for(w.length+=i,x=w.length-1;x>=m;x--)w[x]=w[x-i]};for(y(f),x=n;x<m;++x)f[x]=new l.dataElementType;l._parsing&&y(u._parsed),l.parse(n,i),o&&l.updateElements(f,n,i,"reset")}updateElements(n,i,o,l){}_removeElements(n,i){const o=this,l=o._cachedMeta;if(o._parsing){const u=l._parsed.splice(n,i);l._stacked&&Hs(l,u)}l.data.splice(n,i)}_sync(n){if(this._parsing)this._syncList.push(n);else{const[i,o,l]=n;this[i](o,l)}}_onDataPush(){const n=arguments.length;this._sync(["_insertElements",this.getDataset().data.length-n,n])}_onDataPop(){this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync(["_removeElements",0,1])}_onDataSplice(n,i){this._sync(["_removeElements",n,i]),this._sync(["_insertElements",n,arguments.length-2])}_onDataUnshift(){this._sync(["_insertElements",0,arguments.length])}}bn.defaults={},bn.prototype.datasetElementType=null,bn.prototype.dataElementType=null;class gn{constructor(){this.x=void 0,this.y=void 0,this.active=!1,this.options=void 0,this.$animations=void 0}tooltipPosition(n){const{x:i,y:o}=this.getProps(["x","y"],n);return{x:i,y:o}}hasValue(){return te(this.x)&&te(this.y)}getProps(n,i){const o=this,l=this.$animations;if(!i||!l)return o;const u={};return n.forEach(f=>{u[f]=l[f]&&l[f].active()?l[f]._to:o[f]}),u}}gn.defaults={},gn.defaultRoutes=void 0;const ku={values(r){return gt(r)?r:""+r},numeric(r,n,i){if(r===0)return"0";const o=this.chart.options.locale;let l,u=r;if(i.length>1){const y=Math.max(Math.abs(i[0].value),Math.abs(i[i.length-1].value));(y<1e-4||y>1e15)&&(l="scientific"),u=Sm(r,i)}const f=Ot(Math.abs(u)),m=Math.max(Math.min(-1*Math.floor(f),20),0),x={notation:l,minimumFractionDigits:m,maximumFractionDigits:m};return Object.assign(x,this.options.ticks.format),zi(r,o,x)},logarithmic(r,n,i){if(r===0)return"0";const o=r/Math.pow(10,Math.floor(Ot(r)));return o===1||o===2||o===5?ku.numeric.call(this,r,n,i):""}};function Sm(r,n){let i=n.length>3?n[2].value-n[1].value:n[1].value-n[0].value;return Math.abs(i)>=1&&r!==Math.floor(r)&&(i=r-Math.floor(r)),i}var Ws={formatters:ku};ie.set("scale",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:"ticks",grace:0,grid:{display:!0,lineWidth:1,drawBorder:!0,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(r,n)=>n.lineWidth,tickColor:(r,n)=>n.color,offset:!1,borderDash:[],borderDashOffset:0,borderWidth:1},title:{display:!1,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:"",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:Ws.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:!1,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}}),ie.route("scale.ticks","color","","color"),ie.route("scale.grid","color","","borderColor"),ie.route("scale.grid","borderColor","","borderColor"),ie.route("scale.title","color","","color"),ie.describe("scale",{_fallback:!1,_scriptable:r=>!r.startsWith("before")&&!r.startsWith("after")&&r!=="callback"&&r!=="parser",_indexable:r=>r!=="borderDash"&&r!=="tickBorderDash"}),ie.describe("scales",{_fallback:"scale"}),ie.describe("scale.ticks",{_scriptable:r=>r!=="backdropPadding"&&r!=="callback",_indexable:r=>r!=="backdropPadding"});function Tm(r,n){const i=r.options.ticks,o=i.maxTicksLimit||Em(r),l=i.major.enabled?Lm(n):[],u=l.length,f=l[0],m=l[u-1],x=[];if(u>o)return Cm(n,x,l,u/o),x;const y=Am(l,n,o);if(u>0){let w,A;const R=u>1?Math.round((m-f)/(u-1)):null;for(Gr(n,x,y,at(R)?0:f-R,f),w=0,A=u-1;w<A;w++)Gr(n,x,y,l[w],l[w+1]);return Gr(n,x,y,m,at(R)?n.length:m+R),x}return Gr(n,x,y),x}function Em(r){const n=r.options.offset,i=r._tickSize(),o=r._length/i+(n?0:1),l=r._maxLength/i;return Math.floor(Math.min(o,l))}function Am(r,n,i){const o=Rm(r),l=n.length/i;if(!o)return Math.max(l,1);const u=ne(o);for(let f=0,m=u.length-1;f<m;f++){const x=u[f];if(x>l)return x}return Math.max(l,1)}function Lm(r){const n=[];let i,o;for(i=0,o=r.length;i<o;i++)r[i].major&&n.push(i);return n}function Cm(r,n,i,o){let l=0,u=i[0],f;for(o=Math.ceil(o),f=0;f<r.length;f++)f===u&&(n.push(r[f]),l++,u=i[l*o])}function Gr(r,n,i,o,l){const u=ft(o,0),f=Math.min(ft(l,r.length),r.length);let m=0,x,y,w;for(i=Math.ceil(i),l&&(x=l-o,i=x/Math.floor(x/i)),w=u;w<0;)m++,w=Math.round(u+m*i);for(y=Math.max(u,0);y<f;y++)y===w&&(n.push(r[y]),m++,w=Math.round(u+m*i))}function Rm(r){const n=r.length;let i,o;if(n<2)return!1;for(o=r[0],i=1;i<n;++i)if(r[i]-r[i-1]!==o)return!1;return o}const Pm=r=>r==="left"?"right":r==="right"?"left":r,Ou=(r,n,i)=>n==="top"||n==="left"?r[n]+i:r[n]-i;function Bu(r,n){const i=[],o=r.length/n,l=r.length;let u=0;for(;u<l;u+=o)i.push(r[Math.floor(u)]);return i}function Dm(r,n,i){const o=r.ticks.length,l=Math.min(n,o-1),u=r._startPixel,f=r._endPixel,m=1e-6;let x=r.getPixelForTick(l),y;if(!(i&&(o===1?y=Math.max(x-u,f-x):n===0?y=(r.getPixelForTick(1)-x)/2:y=(x-r.getPixelForTick(l-1))/2,x+=l<n?y:-y,x<u-m||x>f+m)))return x}function Im(r,n){mt(r,i=>{const o=i.gc,l=o.length/2;let u;if(l>n){for(u=0;u<l;++u)delete i.data[o[u]];o.splice(0,l)}})}function Gs(r){return r.drawTicks?r.tickLength:0}function zu(r,n){if(!r.display)return 0;const i=Ce(r.font,n),o=je(r.padding);return(gt(r.text)?r.text.length:1)*i.lineHeight+o.height}function Fm(r,n){return Object.assign(Object.create(r),{scale:n,type:"scale"})}function km(r,n,i){return Object.assign(Object.create(r),{tick:i,index:n,type:"tick"})}function Om(r,n,i){let o=d(r);return(i&&n!=="right"||!i&&n==="right")&&(o=Pm(o)),o}function Bm(r,n,i,o){const{top:l,left:u,bottom:f,right:m,chart:x}=r,{chartArea:y,scales:w}=x;let A=0,R,O,U;const H=f-l,q=m-u;if(r.isHorizontal()){if(O=p(o,u,m),Et(i)){const Z=Object.keys(i)[0],ct=i[Z];U=w[Z].getPixelForValue(ct)+H-n}else i==="center"?U=(y.bottom+y.top)/2+H-n:U=Ou(r,i,n);R=m-u}else{if(Et(i)){const Z=Object.keys(i)[0],ct=i[Z];O=w[Z].getPixelForValue(ct)-q+n}else i==="center"?O=(y.left+y.right)/2-q+n:O=Ou(r,i,n);U=p(o,f,l),A=i==="left"?-lt:lt}return{titleX:O,titleY:U,maxWidth:R,rotation:A}}class Kn extends gn{constructor(n){super();this.id=n.id,this.type=n.type,this.options=void 0,this.ctx=n.ctx,this.chart=n.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(n){const i=this;i.options=n.setContext(i.getContext()),i.axis=n.axis,i._userMin=i.parse(n.min),i._userMax=i.parse(n.max),i._suggestedMin=i.parse(n.suggestedMin),i._suggestedMax=i.parse(n.suggestedMax)}parse(n,i){return n}getUserBounds(){let{_userMin:n,_userMax:i,_suggestedMin:o,_suggestedMax:l}=this;return n=Vt(n,Number.POSITIVE_INFINITY),i=Vt(i,Number.NEGATIVE_INFINITY),o=Vt(o,Number.POSITIVE_INFINITY),l=Vt(l,Number.NEGATIVE_INFINITY),{min:Vt(n,o),max:Vt(i,l),minDefined:At(n),maxDefined:At(i)}}getMinMax(n){const i=this;let{min:o,max:l,minDefined:u,maxDefined:f}=i.getUserBounds(),m;if(u&&f)return{min:o,max:l};const x=i.getMatchingVisibleMetas();for(let y=0,w=x.length;y<w;++y)m=x[y].controller.getMinMax(i,n),u||(o=Math.min(o,m.min)),f||(l=Math.max(l,m.max));return{min:Vt(o,Vt(l,o)),max:Vt(l,Vt(o,l))}}getPadding(){const n=this;return{left:n.paddingLeft||0,top:n.paddingTop||0,right:n.paddingRight||0,bottom:n.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const n=this.chart.data;return this.options.labels||(this.isHorizontal()?n.xLabels:n.yLabels)||n.labels||[]}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){nt(this.options.beforeUpdate,[this])}update(n,i,o){const l=this,u=l.options.ticks,f=u.sampleSize;l.beforeUpdate(),l.maxWidth=n,l.maxHeight=i,l._margins=o=Object.assign({left:0,right:0,top:0,bottom:0},o),l.ticks=null,l._labelSizes=null,l._gridLineItems=null,l._labelItems=null,l.beforeSetDimensions(),l.setDimensions(),l.afterSetDimensions(),l._maxLength=l.isHorizontal()?l.width+o.left+o.right:l.height+o.top+o.bottom,l._dataLimitsCached||(l.beforeDataLimits(),l.determineDataLimits(),l.afterDataLimits(),l._range=jc(l,l.options.grace),l._dataLimitsCached=!0),l.beforeBuildTicks(),l.ticks=l.buildTicks()||[],l.afterBuildTicks();const m=f<l.ticks.length;l._convertTicksToLabels(m?Bu(l.ticks,f):l.ticks),l.configure(),l.beforeCalculateLabelRotation(),l.calculateLabelRotation(),l.afterCalculateLabelRotation(),u.display&&(u.autoSkip||u.source==="auto")&&(l.ticks=Tm(l,l.ticks),l._labelSizes=null),m&&l._convertTicksToLabels(l.ticks),l.beforeFit(),l.fit(),l.afterFit(),l.afterUpdate()}configure(){const n=this;let i=n.options.reverse,o,l;n.isHorizontal()?(o=n.left,l=n.right):(o=n.top,l=n.bottom,i=!i),n._startPixel=o,n._endPixel=l,n._reversePixels=i,n._length=l-o,n._alignToPixels=n.options.alignToPixels}afterUpdate(){nt(this.options.afterUpdate,[this])}beforeSetDimensions(){nt(this.options.beforeSetDimensions,[this])}setDimensions(){const n=this;n.isHorizontal()?(n.width=n.maxWidth,n.left=0,n.right=n.width):(n.height=n.maxHeight,n.top=0,n.bottom=n.height),n.paddingLeft=0,n.paddingTop=0,n.paddingRight=0,n.paddingBottom=0}afterSetDimensions(){nt(this.options.afterSetDimensions,[this])}_callHooks(n){const i=this;i.chart.notifyPlugins(n,i.getContext()),nt(i.options[n],[i])}beforeDataLimits(){this._callHooks("beforeDataLimits")}determineDataLimits(){}afterDataLimits(){this._callHooks("afterDataLimits")}beforeBuildTicks(){this._callHooks("beforeBuildTicks")}buildTicks(){return[]}afterBuildTicks(){this._callHooks("afterBuildTicks")}beforeTickToLabelConversion(){nt(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(n){const i=this,o=i.options.ticks;let l,u,f;for(l=0,u=n.length;l<u;l++)f=n[l],f.label=nt(o.callback,[f.value,l,n],i)}afterTickToLabelConversion(){nt(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){nt(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const n=this,i=n.options,o=i.ticks,l=n.ticks.length,u=o.minRotation||0,f=o.maxRotation;let m=u,x,y,w;if(!n._isVisible()||!o.display||u>=f||l<=1||!n.isHorizontal()){n.labelRotation=u;return}const A=n._getLabelSizes(),R=A.widest.width,O=A.highest.height,U=Fe(n.chart.width-R,0,n.maxWidth);x=i.offset?n.maxWidth/l:U/(l-1),R+6>x&&(x=U/(l-(i.offset?.5:1)),y=n.maxHeight-Gs(i.grid)-o.padding-zu(i.title,n.chart.options.font),w=Math.sqrt(R*R+O*O),m=ze(Math.min(Math.asin(Fe((A.highest.height+6)/x,-1,1)),Math.asin(Fe(y/w,-1,1))-Math.asin(Fe(O/w,-1,1)))),m=Math.max(u,Math.min(f,m))),n.labelRotation=m}afterCalculateLabelRotation(){nt(this.options.afterCalculateLabelRotation,[this])}beforeFit(){nt(this.options.beforeFit,[this])}fit(){const n=this,i={width:0,height:0},{chart:o,options:{ticks:l,title:u,grid:f}}=n,m=n._isVisible(),x=n.isHorizontal();if(m){const y=zu(u,o.options.font);if(x?(i.width=n.maxWidth,i.height=Gs(f)+y):(i.height=n.maxHeight,i.width=Gs(f)+y),l.display&&n.ticks.length){const{first:w,last:A,widest:R,highest:O}=n._getLabelSizes(),U=l.padding*2,H=ue(n.labelRotation),q=Math.cos(H),Z=Math.sin(H);if(x){const ct=l.mirror?0:Z*R.width+q*O.height;i.height=Math.min(n.maxHeight,i.height+ct+U)}else{const ct=l.mirror?0:q*R.width+Z*O.height;i.width=Math.min(n.maxWidth,i.width+ct+U)}n._calculatePadding(w,A,Z,q)}}n._handleMargins(),x?(n.width=n._length=o.width-n._margins.left-n._margins.right,n.height=i.height):(n.width=i.width,n.height=n._length=o.height-n._margins.top-n._margins.bottom)}_calculatePadding(n,i,o,l){const u=this,{ticks:{align:f,padding:m},position:x}=u.options,y=u.labelRotation!==0,w=x!=="top"&&u.axis==="x";if(u.isHorizontal()){const A=u.getPixelForTick(0)-u.left,R=u.right-u.getPixelForTick(u.ticks.length-1);let O=0,U=0;y?w?(O=l*n.width,U=o*i.height):(O=o*n.height,U=l*i.width):f==="start"?U=i.width:f==="end"?O=n.width:(O=n.width/2,U=i.width/2),u.paddingLeft=Math.max((O-A+m)*u.width/(u.width-A),0),u.paddingRight=Math.max((U-R+m)*u.width/(u.width-R),0)}else{let A=i.height/2,R=n.height/2;f==="start"?(A=0,R=n.height):f==="end"&&(A=i.height,R=0),u.paddingTop=A+m,u.paddingBottom=R+m}}_handleMargins(){const n=this;n._margins&&(n._margins.left=Math.max(n.paddingLeft,n._margins.left),n._margins.top=Math.max(n.paddingTop,n._margins.top),n._margins.right=Math.max(n.paddingRight,n._margins.right),n._margins.bottom=Math.max(n.paddingBottom,n._margins.bottom))}afterFit(){nt(this.options.afterFit,[this])}isHorizontal(){const{axis:n,position:i}=this.options;return i==="top"||i==="bottom"||n==="x"}isFullSize(){return this.options.fullSize}_convertTicksToLabels(n){const i=this;i.beforeTickToLabelConversion(),i.generateTickLabels(n);let o,l;for(o=0,l=n.length;o<l;o++)at(n[o].label)&&(n.splice(o,1),l--,o--);i.afterTickToLabelConversion()}_getLabelSizes(){const n=this;let i=n._labelSizes;if(!i){const o=n.options.ticks.sampleSize;let l=n.ticks;o<l.length&&(l=Bu(l,o)),n._labelSizes=i=n._computeLabelSizes(l,l.length)}return i}_computeLabelSizes(n,i){const{ctx:o,_longestTextCache:l}=this,u=[],f=[];let m=0,x=0,y,w,A,R,O,U,H,q,Z,ct,Tt;for(y=0;y<i;++y){if(R=n[y].label,O=this._resolveTickFontOptions(y),o.font=U=O.string,H=l[U]=l[U]||{data:{},gc:[]},q=O.lineHeight,Z=ct=0,!at(R)&&!gt(R))Z=Ds(o,H.data,H.gc,Z,R),ct=q;else if(gt(R))for(w=0,A=R.length;w<A;++w)Tt=R[w],!at(Tt)&&!gt(Tt)&&(Z=Ds(o,H.data,H.gc,Z,Tt),ct+=q);u.push(Z),f.push(ct),m=Math.max(Z,m),x=Math.max(ct,x)}Im(l,i);const wt=u.indexOf(m),yt=f.indexOf(x),Dt=Ut=>({width:u[Ut]||0,height:f[Ut]||0});return{first:Dt(0),last:Dt(i-1),widest:Dt(wt),highest:Dt(yt),widths:u,heights:f}}getLabelForValue(n){return n}getPixelForValue(n,i){return NaN}getValueForPixel(n){}getPixelForTick(n){const i=this.ticks;return n<0||n>i.length-1?null:this.getPixelForValue(i[n].value)}getPixelForDecimal(n){const i=this;i._reversePixels&&(n=1-n);const o=i._startPixel+n*i._length;return Rc(i._alignToPixels?Yn(i.chart,o,0):o)}getDecimalForPixel(n){const i=(n-this._startPixel)/this._length;return this._reversePixels?1-i:i}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:n,max:i}=this;return n<0&&i<0?i:n>0&&i>0?n:0}getContext(n){const i=this,o=i.ticks||[];if(n>=0&&n<o.length){const l=o[n];return l.$context||(l.$context=km(i.getContext(),n,l))}return i.$context||(i.$context=Fm(i.chart.getContext(),i))}_tickSize(){const n=this,i=n.options.ticks,o=ue(n.labelRotation),l=Math.abs(Math.cos(o)),u=Math.abs(Math.sin(o)),f=n._getLabelSizes(),m=i.autoSkipPadding||0,x=f?f.widest.width+m:0,y=f?f.highest.height+m:0;return n.isHorizontal()?y*l>x*u?x/l:y/u:y*u<x*l?y/l:x/u}_isVisible(){const n=this.options.display;return n!=="auto"?!!n:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(n){const i=this,o=i.axis,l=i.chart,u=i.options,{grid:f,position:m}=u,x=f.offset,y=i.isHorizontal(),A=i.ticks.length+(x?1:0),R=Gs(f),O=[],U=f.setContext(i.getContext()),H=U.drawBorder?U.borderWidth:0,q=H/2,Z=function($t){return Yn(l,$t,H)};let ct,Tt,wt,yt,Dt,Ut,zt,Kt,he,ae,Se,le;if(m==="top")ct=Z(i.bottom),Ut=i.bottom-R,Kt=ct-q,ae=Z(n.top)+q,le=n.bottom;else if(m==="bottom")ct=Z(i.top),ae=n.top,le=Z(n.bottom)-q,Ut=ct+q,Kt=i.top+R;else if(m==="left")ct=Z(i.right),Dt=i.right-R,zt=ct-q,he=Z(n.left)+q,Se=n.right;else if(m==="right")ct=Z(i.left),he=n.left,Se=Z(n.right)-q,Dt=ct+q,zt=i.left+R;else if(o==="x"){if(m==="center")ct=Z((n.top+n.bottom)/2+.5);else if(Et(m)){const $t=Object.keys(m)[0],Qe=m[$t];ct=Z(i.chart.scales[$t].getPixelForValue(Qe))}ae=n.top,le=n.bottom,Ut=ct+q,Kt=Ut+R}else if(o==="y"){if(m==="center")ct=Z((n.left+n.right)/2);else if(Et(m)){const $t=Object.keys(m)[0],Qe=m[$t];ct=Z(i.chart.scales[$t].getPixelForValue(Qe))}Dt=ct-q,zt=Dt-R,he=n.left,Se=n.right}const Re=ft(u.ticks.maxTicksLimit,A),Ke=Math.max(1,Math.ceil(A/Re));for(Tt=0;Tt<A;Tt+=Ke){const $t=f.setContext(i.getContext(Tt)),Qe=$t.lineWidth,Ti=$t.color,Zs=f.borderDash||[],tl=$t.borderDashOffset,co=$t.tickWidth,Ui=$t.tickColor,Js=$t.tickBorderDash||[],Ks=$t.tickBorderDashOffset;wt=Dm(i,Tt,x),wt!==void 0&&(yt=Yn(l,wt,Qe),y?Dt=zt=he=Se=yt:Ut=Kt=ae=le=yt,O.push({tx1:Dt,ty1:Ut,tx2:zt,ty2:Kt,x1:he,y1:ae,x2:Se,y2:le,width:Qe,color:Ti,borderDash:Zs,borderDashOffset:tl,tickWidth:co,tickColor:Ui,tickBorderDash:Js,tickBorderDashOffset:Ks}))}return i._ticksLength=A,i._borderValue=ct,O}_computeLabelItems(n){const i=this,o=i.axis,l=i.options,{position:u,ticks:f}=l,m=i.isHorizontal(),x=i.ticks,{align:y,crossAlign:w,padding:A,mirror:R}=f,O=Gs(l.grid),U=O+A,H=R?-A:U,q=-ue(i.labelRotation),Z=[];let ct,Tt,wt,yt,Dt,Ut,zt,Kt,he,ae,Se,le,Re="middle";if(u==="top")Ut=i.bottom-H,zt=i._getXAxisLabelAlignment();else if(u==="bottom")Ut=i.top+H,zt=i._getXAxisLabelAlignment();else if(u==="left"){const $t=i._getYAxisLabelAlignment(O);zt=$t.textAlign,Dt=$t.x}else if(u==="right"){const $t=i._getYAxisLabelAlignment(O);zt=$t.textAlign,Dt=$t.x}else if(o==="x"){if(u==="center")Ut=(n.top+n.bottom)/2+U;else if(Et(u)){const $t=Object.keys(u)[0],Qe=u[$t];Ut=i.chart.scales[$t].getPixelForValue(Qe)+U}zt=i._getXAxisLabelAlignment()}else if(o==="y"){if(u==="center")Dt=(n.left+n.right)/2-U;else if(Et(u)){const $t=Object.keys(u)[0],Qe=u[$t];Dt=i.chart.scales[$t].getPixelForValue(Qe)}zt=i._getYAxisLabelAlignment(O).textAlign}o==="y"&&(y==="start"?Re="top":y==="end"&&(Re="bottom"));const Ke=i._getLabelSizes();for(ct=0,Tt=x.length;ct<Tt;++ct){wt=x[ct],yt=wt.label;const $t=f.setContext(i.getContext(ct));Kt=i.getPixelForTick(ct)+f.labelOffset,he=i._resolveTickFontOptions(ct),ae=he.lineHeight,Se=gt(yt)?yt.length:1;const Qe=Se/2,Ti=$t.color,Zs=$t.textStrokeColor,tl=$t.textStrokeWidth;m?(Dt=Kt,u==="top"?w==="near"||q!==0?le=-Se*ae+ae/2:w==="center"?le=-Ke.highest.height/2-Qe*ae+ae:le=-Ke.highest.height+ae/2:w==="near"||q!==0?le=ae/2:w==="center"?le=Ke.highest.height/2-Qe*ae:le=Ke.highest.height-Se*ae,R&&(le*=-1)):(Ut=Kt,le=(1-Se)*ae/2);let co;if($t.showLabelBackdrop){const Ui=je($t.backdropPadding),Js=Ke.heights[ct],Ks=Ke.widths[ct];let el=Ut+le-Ui.top,nl=Dt-Ui.left;switch(Re){case"middle":el-=Js/2;break;case"bottom":el-=Js;break}switch(zt){case"center":nl-=Ks/2;break;case"right":nl-=Ks;break}co={left:nl,top:el,width:Ks+Ui.width,height:Js+Ui.height,color:$t.backdropColor}}Z.push({rotation:q,label:yt,font:he,color:Ti,strokeColor:Zs,strokeWidth:tl,textOffset:le,textAlign:zt,textBaseline:Re,translation:[Dt,Ut],backdrop:co})}return Z}_getXAxisLabelAlignment(){const n=this,{position:i,ticks:o}=n.options;if(-ue(n.labelRotation))return i==="top"?"left":"right";let u="center";return o.align==="start"?u="left":o.align==="end"&&(u="right"),u}_getYAxisLabelAlignment(n){const i=this,{position:o,ticks:{crossAlign:l,mirror:u,padding:f}}=i.options,m=i._getLabelSizes(),x=n+f,y=m.widest.width;let w,A;return o==="left"?u?(A=i.right+f,l==="near"?w="left":l==="center"?(w="center",A+=y/2):(w="right",A+=y)):(A=i.right-x,l==="near"?w="right":l==="center"?(w="center",A-=y/2):(w="left",A=i.left)):o==="right"?u?(A=i.left+f,l==="near"?w="right":l==="center"?(w="center",A-=y/2):(w="left",A-=y)):(A=i.left+x,l==="near"?w="left":l==="center"?(w="center",A+=y/2):(w="right",A=i.right)):w="right",{textAlign:w,x:A}}_computeLabelArea(){const n=this;if(n.options.ticks.mirror)return;const i=n.chart,o=n.options.position;if(o==="left"||o==="right")return{top:0,left:n.left,bottom:i.height,right:n.right};if(o==="top"||o==="bottom")return{top:n.top,left:0,bottom:n.bottom,right:i.width}}drawBackground(){const{ctx:n,options:{backgroundColor:i},left:o,top:l,width:u,height:f}=this;i&&(n.save(),n.fillStyle=i,n.fillRect(o,l,u,f),n.restore())}getLineWidthForValue(n){const i=this,o=i.options.grid;if(!i._isVisible()||!o.display)return 0;const u=i.ticks.findIndex(f=>f.value===n);return u>=0?o.setContext(i.getContext(u)).lineWidth:0}drawGrid(n){const i=this,o=i.options.grid,l=i.ctx,u=i._gridLineItems||(i._gridLineItems=i._computeGridLineItems(n));let f,m;const x=(y,w,A)=>{!A.width||!A.color||(l.save(),l.lineWidth=A.width,l.strokeStyle=A.color,l.setLineDash(A.borderDash||[]),l.lineDashOffset=A.borderDashOffset,l.beginPath(),l.moveTo(y.x,y.y),l.lineTo(w.x,w.y),l.stroke(),l.restore())};if(o.display)for(f=0,m=u.length;f<m;++f){const y=u[f];o.drawOnChartArea&&x({x:y.x1,y:y.y1},{x:y.x2,y:y.y2},y),o.drawTicks&&x({x:y.tx1,y:y.ty1},{x:y.tx2,y:y.ty2},{color:y.tickColor,width:y.tickWidth,borderDash:y.tickBorderDash,borderDashOffset:y.tickBorderDashOffset})}}drawBorder(){const n=this,{chart:i,ctx:o,options:{grid:l}}=n,u=l.setContext(n.getContext()),f=l.drawBorder?u.borderWidth:0;if(!f)return;const m=l.setContext(n.getContext(0)).lineWidth,x=n._borderValue;let y,w,A,R;n.isHorizontal()?(y=Yn(i,n.left,f)-f/2,w=Yn(i,n.right,m)+m/2,A=R=x):(A=Yn(i,n.top,f)-f/2,R=Yn(i,n.bottom,m)+m/2,y=w=x),o.save(),o.lineWidth=u.borderWidth,o.strokeStyle=u.borderColor,o.beginPath(),o.moveTo(y,A),o.lineTo(w,R),o.stroke(),o.restore()}drawLabels(n){const i=this;if(!i.options.ticks.display)return;const l=i.ctx,u=i._computeLabelArea();u&&Fs(l,u);const f=i._labelItems||(i._labelItems=i._computeLabelItems(n));let m,x;for(m=0,x=f.length;m<x;++m){const y=f[m],w=y.font,A=y.label;y.backdrop&&(l.fillStyle=y.backdrop.color,l.fillRect(y.backdrop.left,y.backdrop.top,y.backdrop.width,y.backdrop.height));let R=y.textOffset;Zn(l,A,0,R,w,y)}u&&ks(l)}drawTitle(){const{ctx:n,options:{position:i,title:o,reverse:l}}=this;if(!o.display)return;const u=Ce(o.font),f=je(o.padding),m=o.align;let x=u.lineHeight/2;i==="bottom"||i==="center"||Et(i)?(x+=f.bottom,gt(o.text)&&(x+=u.lineHeight*(o.text.length-1))):x+=f.top;const{titleX:y,titleY:w,maxWidth:A,rotation:R}=Bm(this,x,i,m);Zn(n,o.text,0,0,u,{color:o.color,maxWidth:A,rotation:R,textAlign:Om(m,i,l),textBaseline:"middle",translation:[y,w]})}draw(n){const i=this;!i._isVisible()||(i.drawBackground(),i.drawGrid(n),i.drawBorder(),i.drawTitle(),i.drawLabels(n))}_layers(){const n=this,i=n.options,o=i.ticks&&i.ticks.z||0,l=ft(i.grid&&i.grid.z,-1);return!n._isVisible()||n.draw!==Kn.prototype.draw?[{z:o,draw(u){n.draw(u)}}]:[{z:l,draw(u){n.drawBackground(),n.drawGrid(u),n.drawTitle()}},{z:l+1,draw(){n.drawBorder()}},{z:o,draw(u){n.drawLabels(u)}}]}getMatchingVisibleMetas(n){const i=this,o=i.chart.getSortedVisibleDatasetMetas(),l=i.axis+"AxisID",u=[];let f,m;for(f=0,m=o.length;f<m;++f){const x=o[f];x[l]===i.id&&(!n||x.type===n)&&u.push(x)}return u}_resolveTickFontOptions(n){const i=this.options.ticks.setContext(this.getContext(n));return Ce(i.font)}_maxDigits(){const n=this,i=n._resolveTickFontOptions(0).lineHeight;return(n.isHorizontal()?n.width:n.height)/i}}class Xr{constructor(n,i,o){this.type=n,this.scope=i,this.override=o,this.items=Object.create(null)}isForType(n){return Object.prototype.isPrototypeOf.call(this.type.prototype,n.prototype)}register(n){const i=this,o=Object.getPrototypeOf(n);let l;Vm(o)&&(l=i.register(o));const u=i.items,f=n.id,m=i.scope+"."+f;if(!f)throw new Error("class does not have id: "+n);return f in u||(u[f]=n,zm(n,m,l),i.override&&ie.override(n.id,n.overrides)),m}get(n){return this.items[n]}unregister(n){const i=this.items,o=n.id,l=this.scope;o in i&&delete i[o],l&&o in ie[l]&&(delete ie[l][o],this.override&&delete mn[o])}}function zm(r,n,i){const o=Je(Object.create(null),[i?ie.get(i):{},ie.get(n),r.defaults]);ie.set(n,o),r.defaultRoutes&&Nm(n,r.defaultRoutes),r.descriptors&&ie.describe(n,r.descriptors)}function Nm(r,n){Object.keys(n).forEach(i=>{const o=i.split("."),l=o.pop(),u=[r].concat(o).join("."),f=n[i].split("."),m=f.pop(),x=f.join(".");ie.route(u,l,x,m)})}function Vm(r){return"id"in r&&"defaults"in r}class Um{constructor(){this.controllers=new Xr(bn,"datasets",!0),this.elements=new Xr(gn,"elements"),this.plugins=new Xr(Object,"plugins"),this.scales=new Xr(Kn,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...n){this._each("register",n)}remove(...n){this._each("unregister",n)}addControllers(...n){this._each("register",n,this.controllers)}addElements(...n){this._each("register",n,this.elements)}addPlugins(...n){this._each("register",n,this.plugins)}addScales(...n){this._each("register",n,this.scales)}getController(n){return this._get(n,this.controllers,"controller")}getElement(n){return this._get(n,this.elements,"element")}getPlugin(n){return this._get(n,this.plugins,"plugin")}getScale(n){return this._get(n,this.scales,"scale")}removeControllers(...n){this._each("unregister",n,this.controllers)}removeElements(...n){this._each("unregister",n,this.elements)}removePlugins(...n){this._each("unregister",n,this.plugins)}removeScales(...n){this._each("unregister",n,this.scales)}_each(n,i,o){const l=this;[...i].forEach(u=>{const f=o||l._getRegistryForType(u);o||f.isForType(u)||f===l.plugins&&u.id?l._exec(n,f,u):mt(u,m=>{const x=o||l._getRegistryForType(m);l._exec(n,x,m)})})}_exec(n,i,o){const l=pn(n);nt(o["before"+l],[],o),i[n](o),nt(o["after"+l],[],o)}_getRegistryForType(n){for(let i=0;i<this._typedRegistries.length;i++){const o=this._typedRegistries[i];if(o.isForType(n))return o}return this.plugins}_get(n,i,o){const l=i.get(n);if(l===void 0)throw new Error('"'+n+'" is not a registered '+o+".");return l}}var Pn=new Um;class Hm{constructor(){this._init=[]}notify(n,i,o,l){const u=this;i==="beforeInit"&&(u._init=u._createDescriptors(n,!0),u._notify(u._init,n,"install"));const f=l?u._descriptors(n).filter(l):u._descriptors(n),m=u._notify(f,n,i,o);return i==="destroy"&&(u._notify(f,n,"stop"),u._notify(u._init,n,"uninstall")),m}_notify(n,i,o,l){l=l||{};for(const u of n){const f=u.plugin,m=f[o],x=[i,l,u.options];if(nt(m,x,f)===!1&&l.cancelable)return!1}return!0}invalidate(){at(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(n){if(this._cache)return this._cache;const i=this._cache=this._createDescriptors(n);return this._notifyStateChanges(n),i}_createDescriptors(n,i){const o=n&&n.config,l=ft(o.options&&o.options.plugins,{}),u=Wm(o);return l===!1&&!i?[]:Xm(n,u,l,i)}_notifyStateChanges(n){const i=this._oldCache||[],o=this._cache,l=(u,f)=>u.filter(m=>!f.some(x=>m.plugin.id===x.plugin.id));this._notify(l(i,o),n,"stop"),this._notify(l(o,i),n,"start")}}function Wm(r){const n=[],i=Object.keys(Pn.plugins.items);for(let l=0;l<i.length;l++)n.push(Pn.getPlugin(i[l]));const o=r.plugins||[];for(let l=0;l<o.length;l++){const u=o[l];n.indexOf(u)===-1&&n.push(u)}return n}function Gm(r,n){return!n&&r===!1?null:r===!0?{}:r}function Xm(r,n,i,o){const l=[],u=r.getContext();for(let f=0;f<n.length;f++){const m=n[f],x=m.id,y=Gm(i[x],o);y!==null&&l.push({plugin:m,options:jm(r.config,m,y,u)})}return l}function jm(r,n,i,o){const l=r.pluginScopeKeys(n),u=r.getOptionScopes(i,l);return r.createResolver(u,o,[""],{scriptable:!1,indexable:!1,allKeys:!0})}function Oa(r,n){const i=ie.datasets[r]||{};return((n.datasets||{})[r]||{}).indexAxis||n.indexAxis||i.indexAxis||"x"}function qm(r,n){let i=r;return r==="_index_"?i=n:r==="_value_"&&(i=n==="x"?"y":"x"),i}function Ym(r,n){return r===n?"_index_":"_value_"}function $m(r){if(r==="top"||r==="bottom")return"x";if(r==="left"||r==="right")return"y"}function Ba(r,n){return r==="x"||r==="y"?r:n.axis||$m(n.position)||r.charAt(0).toLowerCase()}function Zm(r,n){const i=mn[r.type]||{scales:{}},o=n.scales||{},l=Oa(r.type,n),u=Object.create(null),f=Object.create(null);return Object.keys(o).forEach(m=>{const x=o[m],y=Ba(m,x),w=Ym(y,l),A=i.scales||{};u[y]=u[y]||m,f[m]=me(Object.create(null),[{axis:y},x,A[y],A[w]])}),r.data.datasets.forEach(m=>{const x=m.type||r.type,y=m.indexAxis||Oa(x,n),A=(mn[x]||{}).scales||{};Object.keys(A).forEach(R=>{const O=qm(R,y),U=m[O+"AxisID"]||u[O]||O;f[U]=f[U]||Object.create(null),me(f[U],[{axis:O},o[U],A[R]])})}),Object.keys(f).forEach(m=>{const x=f[m];me(x,[ie.scales[x.type],ie.scale])}),f}function Nu(r){const n=r.options||(r.options={});n.plugins=ft(n.plugins,{}),n.scales=Zm(r,n)}function Vu(r){return r=r||{},r.datasets=r.datasets||[],r.labels=r.labels||[],r}function Jm(r){return r=r||{},r.data=Vu(r.data),Nu(r),r}const Uu=new Map,Hu=new Set;function jr(r,n){let i=Uu.get(r);return i||(i=n(),Uu.set(r,i),Hu.add(i)),i}const Xs=(r,n,i)=>{const o=fn(n,i);o!==void 0&&r.add(o)};class Km{constructor(n){this._config=Jm(n),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(n){this._config.type=n}get data(){return this._config.data}set data(n){this._config.data=Vu(n)}get options(){return this._config.options}set options(n){this._config.options=n}get plugins(){return this._config.plugins}update(){const n=this._config;this.clearCache(),Nu(n)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(n){return jr(n,()=>[[`datasets.${n}`,""]])}datasetAnimationScopeKeys(n,i){return jr(`${n}.transition.${i}`,()=>[[`datasets.${n}.transitions.${i}`,`transitions.${i}`],[`datasets.${n}`,""]])}datasetElementScopeKeys(n,i){return jr(`${n}-${i}`,()=>[[`datasets.${n}.elements.${i}`,`datasets.${n}`,`elements.${i}`,""]])}pluginScopeKeys(n){const i=n.id,o=this.type;return jr(`${o}-plugin-${i}`,()=>[[`plugins.${i}`,...n.additionalOptionScopes||[]]])}_cachedScopes(n,i){const o=this._scopeCache;let l=o.get(n);return(!l||i)&&(l=new Map,o.set(n,l)),l}getOptionScopes(n,i,o){const{options:l,type:u}=this,f=this._cachedScopes(n,o),m=f.get(i);if(m)return m;const x=new Set;i.forEach(w=>{n&&(x.add(n),w.forEach(A=>Xs(x,n,A))),w.forEach(A=>Xs(x,l,A)),w.forEach(A=>Xs(x,mn[u]||{},A)),w.forEach(A=>Xs(x,ie,A)),w.forEach(A=>Xs(x,Ps,A))});const y=Array.from(x);return y.length===0&&y.push(Object.create(null)),Hu.has(i)&&f.set(i,y),y}chartOptionScopes(){const{options:n,type:i}=this;return[n,mn[i]||{},ie.datasets[i]||{},{type:i},ie,Ps]}resolveNamedOptions(n,i,o,l=[""]){const u={$shared:!0},{resolver:f,subPrefixes:m}=Wu(this._resolverCache,n,l);let x=f;if(Qm(f,i)){u.$shared=!1,o=An(o)?o():o;const y=this.createResolver(n,o,m);x=Mi(f,o,y)}for(const y of i)u[y]=x[y];return u}createResolver(n,i,o=[""],l){const{resolver:u}=Wu(this._resolverCache,n,o);return Et(i)?Mi(u,i,void 0,l):u}}function Wu(r,n,i){let o=r.get(n);o||(o=new Map,r.set(n,o));const l=i.join();let u=o.get(l);return u||(u={resolver:Vr(n,i),subPrefixes:i.filter(m=>!m.toLowerCase().includes("hover"))},o.set(l,u)),u}function Qm(r,n){const{isScriptable:i,isIndexable:o}=Ta(r);for(const l of n)if(i(l)&&An(r[l])||o(l)&&gt(r[l]))return!0;return!1}var tg="3.5.1";const eg=["top","bottom","left","right","chartArea"];function Gu(r,n){return r==="top"||r==="bottom"||eg.indexOf(r)===-1&&n==="x"}function Xu(r,n){return function(i,o){return i[r]===o[r]?i[n]-o[n]:i[r]-o[r]}}function ju(r){const n=r.chart,i=n.options.animation;n.notifyPlugins("afterRender"),nt(i&&i.onComplete,[r],n)}function ng(r){const n=r.chart,i=n.options.animation;nt(i&&i.onProgress,[r],n)}function qu(r){return xa()&&typeof r=="string"?r=document.getElementById(r):r&&r.length&&(r=r[0]),r&&r.canvas&&(r=r.canvas),r}const qr={},Yu=r=>{const n=qu(r);return Object.values(qr).filter(i=>i.canvas===n).pop()};class Ee{constructor(n,i){const o=this,l=this.config=new Km(i),u=qu(n),f=Yu(u);if(f)throw new Error("Canvas is already in use. Chart with ID '"+f.id+"' must be destroyed before the canvas can be reused.");const m=l.createResolver(l.chartOptionScopes(),o.getContext());this.platform=new(l.platform||Su(u));const x=o.platform.acquireContext(u,m.aspectRatio),y=x&&x.canvas,w=y&&y.height,A=y&&y.width;if(this.id=bt(),this.ctx=x,this.canvas=y,this.width=A,this.height=w,this._options=m,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new Hm,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=h(()=>this.update("resize"),m.resizeDelay||0),qr[o.id]=o,!x||!y){console.error("Failed to create chart: can't acquire context from the given item");return}v.listen(o,"complete",ju),v.listen(o,"progress",ng),o._initialize(),o.attached&&o.update()}get aspectRatio(){const{options:{aspectRatio:n,maintainAspectRatio:i},width:o,height:l,_aspectRatio:u}=this;return at(n)?i&&u?u:l?o/l:null:n}get data(){return this.config.data}set data(n){this.config.data=n}get options(){return this._options}set options(n){this.config.options=n}_initialize(){const n=this;return n.notifyPlugins("beforeInit"),n.options.responsive?n.resize():va(n,n.options.devicePixelRatio),n.bindEvents(),n.notifyPlugins("afterInit"),n}clear(){return pa(this.canvas,this.ctx),this}stop(){return v.stop(this),this}resize(n,i){v.running(this)?this._resizeBeforeDraw={width:n,height:i}:this._resize(n,i)}_resize(n,i){const o=this,l=o.options,u=o.canvas,f=l.maintainAspectRatio&&o.aspectRatio,m=o.platform.getMaximumSize(u,n,i,f),x=l.devicePixelRatio||o.platform.getDevicePixelRatio();o.width=m.width,o.height=m.height,o._aspectRatio=o.aspectRatio,!!va(o,x,!0)&&(o.notifyPlugins("resize",{size:m}),nt(l.onResize,[o,m],o),o.attached&&o._doResize()&&o.render())}ensureScalesHaveIDs(){const i=this.options.scales||{};mt(i,(o,l)=>{o.id=l})}buildOrUpdateScales(){const n=this,i=n.options,o=i.scales,l=n.scales,u=Object.keys(l).reduce((m,x)=>(m[x]=!1,m),{});let f=[];o&&(f=f.concat(Object.keys(o).map(m=>{const x=o[m],y=Ba(m,x),w=y==="r",A=y==="x";return{options:x,dposition:w?"chartArea":A?"bottom":"left",dtype:w?"radialLinear":A?"category":"linear"}}))),mt(f,m=>{const x=m.options,y=x.id,w=Ba(y,x),A=ft(x.type,m.dtype);(x.position===void 0||Gu(x.position,w)!==Gu(m.dposition))&&(x.position=m.dposition),u[y]=!0;let R=null;if(y in l&&l[y].type===A)R=l[y];else{const O=Pn.getScale(A);R=new O({id:y,type:A,ctx:n.ctx,chart:n}),l[R.id]=R}R.init(x,i)}),mt(u,(m,x)=>{m||delete l[x]}),mt(l,m=>{He.configure(n,m,m.options),He.addBox(n,m)})}_updateMetasets(){const n=this,i=n._metasets,o=n.data.datasets.length,l=i.length;if(i.sort((u,f)=>u.index-f.index),l>o){for(let u=o;u<l;++u)n._destroyDatasetMeta(u);i.splice(o,l-o)}n._sortedMetasets=i.slice(0).sort(Xu("order","index"))}_removeUnreferencedMetasets(){const n=this,{_metasets:i,data:{datasets:o}}=n;i.length>o.length&&delete n._stacks,i.forEach((l,u)=>{o.filter(f=>f===l._dataset).length===0&&n._destroyDatasetMeta(u)})}buildOrUpdateControllers(){const n=this,i=[],o=n.data.datasets;let l,u;for(n._removeUnreferencedMetasets(),l=0,u=o.length;l<u;l++){const f=o[l];let m=n.getDatasetMeta(l);const x=f.type||n.config.type;if(m.type&&m.type!==x&&(n._destroyDatasetMeta(l),m=n.getDatasetMeta(l)),m.type=x,m.indexAxis=f.indexAxis||Oa(x,n.options),m.order=f.order||0,m.index=l,m.label=""+f.label,m.visible=n.isDatasetVisible(l),m.controller)m.controller.updateIndex(l),m.controller.linkScales();else{const y=Pn.getController(x),{datasetElementType:w,dataElementType:A}=ie.datasets[x];Object.assign(y.prototype,{dataElementType:Pn.getElement(A),datasetElementType:w&&Pn.getElement(w)}),m.controller=new y(n,l),i.push(m.controller)}}return n._updateMetasets(),i}_resetElements(){const n=this;mt(n.data.datasets,(i,o)=>{n.getDatasetMeta(o).controller.reset()},n)}reset(){this._resetElements(),this.notifyPlugins("reset")}update(n){const i=this,o=i.config;o.update(),i._options=o.createResolver(o.chartOptionScopes(),i.getContext()),mt(i.scales,y=>{He.removeBox(i,y)});const l=i._animationsDisabled=!i.options.animation;i.ensureScalesHaveIDs(),i.buildOrUpdateScales();const u=new Set(Object.keys(i._listeners)),f=new Set(i.options.events);if((!Dr(u,f)||!!this._responsiveListeners!==i.options.responsive)&&(i.unbindEvents(),i.bindEvents()),i._plugins.invalidate(),i.notifyPlugins("beforeUpdate",{mode:n,cancelable:!0})===!1)return;const m=i.buildOrUpdateControllers();i.notifyPlugins("beforeElementsUpdate");let x=0;for(let y=0,w=i.data.datasets.length;y<w;y++){const{controller:A}=i.getDatasetMeta(y),R=!l&&m.indexOf(A)===-1;A.buildOrUpdateElements(R),x=Math.max(+A.getMaxOverflow(),x)}i._minPadding=x,i._updateLayout(x),l||mt(m,y=>{y.reset()}),i._updateDatasets(n),i.notifyPlugins("afterUpdate",{mode:n}),i._layers.sort(Xu("z","_idx")),i._lastEvent&&i._eventHandler(i._lastEvent,!0),i.render()}_updateLayout(n){const i=this;if(i.notifyPlugins("beforeLayout",{cancelable:!0})===!1)return;He.update(i,i.width,i.height,n);const o=i.chartArea,l=o.width<=0||o.height<=0;i._layers=[],mt(i.boxes,u=>{l&&u.position==="chartArea"||(u.configure&&u.configure(),i._layers.push(...u._layers()))},i),i._layers.forEach((u,f)=>{u._idx=f}),i.notifyPlugins("afterLayout")}_updateDatasets(n){const i=this,o=typeof n=="function";if(i.notifyPlugins("beforeDatasetsUpdate",{mode:n,cancelable:!0})!==!1){for(let l=0,u=i.data.datasets.length;l<u;++l)i._updateDataset(l,o?n({datasetIndex:l}):n);i.notifyPlugins("afterDatasetsUpdate",{mode:n})}}_updateDataset(n,i){const o=this,l=o.getDatasetMeta(n),u={meta:l,index:n,mode:i,cancelable:!0};o.notifyPlugins("beforeDatasetUpdate",u)!==!1&&(l.controller._update(i),u.cancelable=!1,o.notifyPlugins("afterDatasetUpdate",u))}render(){const n=this;n.notifyPlugins("beforeRender",{cancelable:!0})!==!1&&(v.has(n)?n.attached&&!v.running(n)&&v.start(n):(n.draw(),ju({chart:n})))}draw(){const n=this;let i;if(n._resizeBeforeDraw){const{width:l,height:u}=n._resizeBeforeDraw;n._resize(l,u),n._resizeBeforeDraw=null}if(n.clear(),n.width<=0||n.height<=0||n.notifyPlugins("beforeDraw",{cancelable:!0})===!1)return;const o=n._layers;for(i=0;i<o.length&&o[i].z<=0;++i)o[i].draw(n.chartArea);for(n._drawDatasets();i<o.length;++i)o[i].draw(n.chartArea);n.notifyPlugins("afterDraw")}_getSortedDatasetMetas(n){const o=this._sortedMetasets,l=[];let u,f;for(u=0,f=o.length;u<f;++u){const m=o[u];(!n||m.visible)&&l.push(m)}return l}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){const n=this;if(n.notifyPlugins("beforeDatasetsDraw",{cancelable:!0})===!1)return;const i=n.getSortedVisibleDatasetMetas();for(let o=i.length-1;o>=0;--o)n._drawDataset(i[o]);n.notifyPlugins("afterDatasetsDraw")}_drawDataset(n){const i=this,o=i.ctx,l=n._clip,u=!l.disabled,f=i.chartArea,m={meta:n,index:n.index,cancelable:!0};i.notifyPlugins("beforeDatasetDraw",m)!==!1&&(u&&Fs(o,{left:l.left===!1?0:f.left-l.left,right:l.right===!1?i.width:f.right+l.right,top:l.top===!1?0:f.top-l.top,bottom:l.bottom===!1?i.height:f.bottom+l.bottom}),n.controller.draw(),u&&ks(o),m.cancelable=!1,i.notifyPlugins("afterDatasetDraw",m))}getElementsAtEventForMode(n,i,o,l){const u=Gc.modes[i];return typeof u=="function"?u(this,n,o,l):[]}getDatasetMeta(n){const i=this,o=i.data.datasets[n],l=i._metasets;let u=l.filter(f=>f&&f._dataset===o).pop();return u||(u={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:o&&o.order||0,index:n,_dataset:o,_parsed:[],_sorted:!1},l.push(u)),u}getContext(){return this.$context||(this.$context={chart:this,type:"chart"})}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(n){const i=this.data.datasets[n];if(!i)return!1;const o=this.getDatasetMeta(n);return typeof o.hidden=="boolean"?!o.hidden:!i.hidden}setDatasetVisibility(n,i){const o=this.getDatasetMeta(n);o.hidden=!i}toggleDataVisibility(n){this._hiddenIndices[n]=!this._hiddenIndices[n]}getDataVisibility(n){return!this._hiddenIndices[n]}_updateVisibility(n,i,o){const l=this,u=o?"show":"hide",f=l.getDatasetMeta(n),m=f.controller._resolveAnimations(void 0,u);Be(i)?(f.data[i].hidden=!o,l.update()):(l.setDatasetVisibility(n,o),m.update(f,{visible:o}),l.update(x=>x.datasetIndex===n?u:void 0))}hide(n,i){this._updateVisibility(n,i,!1)}show(n,i){this._updateVisibility(n,i,!0)}_destroyDatasetMeta(n){const i=this,o=i._metasets&&i._metasets[n];o&&o.controller&&(o.controller._destroy(),delete i._metasets[n])}destroy(){const n=this,{canvas:i,ctx:o}=n;let l,u;for(n.stop(),v.remove(n),l=0,u=n.data.datasets.length;l<u;++l)n._destroyDatasetMeta(l);n.config.clearCache(),i&&(n.unbindEvents(),pa(i,o),n.platform.releaseContext(o),n.canvas=null,n.ctx=null),n.notifyPlugins("destroy"),delete qr[n.id]}toBase64Image(...n){return this.canvas.toDataURL(...n)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const n=this,i=n._listeners,o=n.platform,l=(f,m)=>{o.addEventListener(n,f,m),i[f]=m},u=function(f,m,x){f.offsetX=m,f.offsetY=x,n._eventHandler(f)};mt(n.options.events,f=>l(f,u))}bindResponsiveEvents(){const n=this;n._responsiveListeners||(n._responsiveListeners={});const i=n._responsiveListeners,o=n.platform,l=(y,w)=>{o.addEventListener(n,y,w),i[y]=w},u=(y,w)=>{i[y]&&(o.removeEventListener(n,y,w),delete i[y])},f=(y,w)=>{n.canvas&&n.resize(y,w)};let m;const x=()=>{u("attach",x),n.attached=!0,n.resize(),l("resize",f),l("detach",m)};m=()=>{n.attached=!1,u("resize",f),l("attach",x)},o.isAttached(n.canvas)?x():m()}unbindEvents(){const n=this;mt(n._listeners,(i,o)=>{n.platform.removeEventListener(n,o,i)}),n._listeners={},mt(n._responsiveListeners,(i,o)=>{n.platform.removeEventListener(n,o,i)}),n._responsiveListeners=void 0}updateHoverStyle(n,i,o){const l=o?"set":"remove";let u,f,m,x;for(i==="dataset"&&(u=this.getDatasetMeta(n[0].datasetIndex),u.controller["_"+l+"DatasetHoverStyle"]()),m=0,x=n.length;m<x;++m){f=n[m];const y=f&&this.getDatasetMeta(f.datasetIndex).controller;y&&y[l+"HoverStyle"](f.element,f.datasetIndex,f.index)}}getActiveElements(){return this._active||[]}setActiveElements(n){const i=this,o=i._active||[],l=n.map(({datasetIndex:f,index:m})=>{const x=i.getDatasetMeta(f);if(!x)throw new Error("No dataset found at index "+f);return{datasetIndex:f,element:x.data[m],index:m}});!kt(l,o)&&(i._active=l,i._updateHoverStyles(l,o))}notifyPlugins(n,i,o){return this._plugins.notify(this,n,i,o)}_updateHoverStyles(n,i,o){const l=this,u=l.options.hover,f=(y,w)=>y.filter(A=>!w.some(R=>A.datasetIndex===R.datasetIndex&&A.index===R.index)),m=f(i,n),x=o?n:f(n,i);m.length&&l.updateHoverStyle(m,u.mode,!1),x.length&&u.mode&&l.updateHoverStyle(x,u.mode,!0)}_eventHandler(n,i){const o=this,l={event:n,replay:i,cancelable:!0},u=m=>(m.options.events||this.options.events).includes(n.type);if(o.notifyPlugins("beforeEvent",l,u)===!1)return;const f=o._handleEvent(n,i);return l.cancelable=!1,o.notifyPlugins("afterEvent",l,u),(f||l.changed)&&o.render(),o}_handleEvent(n,i){const o=this,{_active:l=[],options:u}=o,f=u.hover,m=i;let x=[],y=!1,w=null;return n.type!=="mouseout"&&(x=o.getElementsAtEventForMode(n,f.mode,f,m),w=n.type==="click"?o._lastEvent:n),o._lastEvent=null,$n(n,o.chartArea,o._minPadding)&&(nt(u.onHover,[n,x,o],o),(n.type==="mouseup"||n.type==="click"||n.type==="contextmenu")&&nt(u.onClick,[n,x,o],o)),y=!kt(x,l),(y||i)&&(o._active=x,o._updateHoverStyles(x,l,i)),o._lastEvent=w,y}}const $u=()=>mt(Ee.instances,r=>r._plugins.invalidate()),Qn=!0;Object.defineProperties(Ee,{defaults:{enumerable:Qn,value:ie},instances:{enumerable:Qn,value:qr},overrides:{enumerable:Qn,value:mn},registry:{enumerable:Qn,value:Pn},version:{enumerable:Qn,value:tg},getChart:{enumerable:Qn,value:Yu},register:{enumerable:Qn,value:(...r)=>{Pn.add(...r),$u()}},unregister:{enumerable:Qn,value:(...r)=>{Pn.remove(...r),$u()}}});function Si(){throw new Error("This method is not implemented: Check that a complete date adapter is provided.")}class za{constructor(n){this.options=n||{}}formats(){return Si()}parse(n,i){return Si()}format(n,i){return Si()}add(n,i,o){return Si()}diff(n,i,o){return Si()}startOf(n,i,o){return Si()}endOf(n,i){return Si()}}za.override=function(r){Object.assign(za.prototype,r)};var Zu={_date:za};function ig(r){if(!r._cache.$bar){const n=r.getMatchingVisibleMetas("bar");let i=[];for(let o=0,l=n.length;o<l;o++)i=i.concat(n[o].controller.getAllParsedValues(r));r._cache.$bar=ga(i.sort((o,l)=>o-l))}return r._cache.$bar}function sg(r){const n=ig(r);let i=r._length,o,l,u,f;const m=()=>{u===32767||u===-32768||(Be(f)&&(i=Math.min(i,Math.abs(u-f)||i)),f=u)};for(o=0,l=n.length;o<l;++o)u=r.getPixelForValue(n[o]),m();for(f=void 0,o=0,l=r.ticks.length;o<l;++o)u=r.getPixelForTick(o),m();return i}function rg(r,n,i,o){const l=i.barThickness;let u,f;return at(l)?(u=n.min*i.categoryPercentage,f=i.barPercentage):(u=l*o,f=1),{chunk:u/o,ratio:f,start:n.pixels[r]-u/2}}function og(r,n,i,o){const l=n.pixels,u=l[r];let f=r>0?l[r-1]:null,m=r<l.length-1?l[r+1]:null;const x=i.categoryPercentage;f===null&&(f=u-(m===null?n.end-n.start:m-u)),m===null&&(m=u+u-f);const y=u-(u-Math.min(f,m))/2*x;return{chunk:Math.abs(m-f)/2*x/o,ratio:i.barPercentage,start:y}}function ag(r,n,i,o){const l=i.parse(r[0],o),u=i.parse(r[1],o),f=Math.min(l,u),m=Math.max(l,u);let x=f,y=m;Math.abs(f)>Math.abs(m)&&(x=m,y=f),n[i.axis]=y,n._custom={barStart:x,barEnd:y,start:l,end:u,min:f,max:m}}function Ju(r,n,i,o){return gt(r)?ag(r,n,i,o):n[i.axis]=i.parse(r,o),n}function Ku(r,n,i,o){const l=r.iScale,u=r.vScale,f=l.getLabels(),m=l===u,x=[];let y,w,A,R;for(y=i,w=i+o;y<w;++y)R=n[y],A={},A[l.axis]=m||l.parse(f[y],y),x.push(Ju(R,A,u,y));return x}function Na(r){return r&&r.barStart!==void 0&&r.barEnd!==void 0}function lg(r,n,i){return r!==0?Yt(r):(n.isHorizontal()?1:-1)*(n.min>=i?1:-1)}function cg(r){let n,i,o,l,u;return r.horizontal?(n=r.base>r.x,i="left",o="right"):(n=r.base<r.y,i="bottom",o="top"),n?(l="end",u="start"):(l="start",u="end"),{start:i,end:o,reverse:n,top:l,bottom:u}}function ug(r,n,i,o){let l=n.borderSkipped;const u={};if(!l){r.borderSkipped=u;return}const{start:f,end:m,reverse:x,top:y,bottom:w}=cg(r);l==="middle"&&i&&(r.enableBorderRadius=!0,(i._top||0)===o?l=y:(i._bottom||0)===o?l=w:(u[Qu(w,f,m,x)]=!0,l=y)),u[Qu(l,f,m,x)]=!0,r.borderSkipped=u}function Qu(r,n,i,o){return o?(r=hg(r,n,i),r=th(r,i,n)):r=th(r,n,i),r}function hg(r,n,i){return r===n?i:r===i?n:r}function th(r,n,i){return r==="start"?n:r==="end"?i:r}class Yr extends bn{parsePrimitiveData(n,i,o,l){return Ku(n,i,o,l)}parseArrayData(n,i,o,l){return Ku(n,i,o,l)}parseObjectData(n,i,o,l){const{iScale:u,vScale:f}=n,{xAxisKey:m="x",yAxisKey:x="y"}=this._parsing,y=u.axis==="x"?m:x,w=f.axis==="x"?m:x,A=[];let R,O,U,H;for(R=o,O=o+l;R<O;++R)H=i[R],U={},U[u.axis]=u.parse(fn(H,y),R),A.push(Ju(fn(H,w),U,f,R));return A}updateRangeFromParsed(n,i,o,l){super.updateRangeFromParsed(n,i,o,l);const u=o._custom;u&&i===this._cachedMeta.vScale&&(n.min=Math.min(n.min,u.min),n.max=Math.max(n.max,u.max))}getMaxOverflow(){return 0}getLabelAndValue(n){const i=this,o=i._cachedMeta,{iScale:l,vScale:u}=o,f=i.getParsed(n),m=f._custom,x=Na(m)?"["+m.start+", "+m.end+"]":""+u.getLabelForValue(f[u.axis]);return{label:""+l.getLabelForValue(f[l.axis]),value:x}}initialize(){const n=this;n.enableOptionSharing=!0,super.initialize();const i=n._cachedMeta;i.stack=n.getDataset().stack}update(n){const i=this,o=i._cachedMeta;i.updateElements(o.data,0,o.data.length,n)}updateElements(n,i,o,l){const u=this,f=l==="reset",{index:m,_cachedMeta:{vScale:x}}=u,y=x.getBasePixel(),w=x.isHorizontal(),A=u._getRuler(),R=u.resolveDataElementOptions(i,l),O=u.getSharedOptions(R),U=u.includeOptions(l,O);u.updateSharedOptions(O,l,R);for(let H=i;H<i+o;H++){const q=u.getParsed(H),Z=f||at(q[x.axis])?{base:y,head:y}:u._calculateBarValuePixels(H),ct=u._calculateBarIndexPixels(H,A),Tt=(q._stacks||{})[x.axis],wt={horizontal:w,base:Z.base,enableBorderRadius:!Tt||Na(q._custom)||m===Tt._top||m===Tt._bottom,x:w?Z.head:ct.center,y:w?ct.center:Z.head,height:w?ct.size:Math.abs(Z.size),width:w?Math.abs(Z.size):ct.size};U&&(wt.options=O||u.resolveDataElementOptions(H,n[H].active?"active":l)),ug(wt,wt.options||n[H].options,Tt,m),u.updateElement(n[H],H,wt,l)}}_getStacks(n,i){const o=this,u=o._cachedMeta.iScale,f=u.getMatchingVisibleMetas(o._type),m=u.options.stacked,x=f.length,y=[];let w,A;for(w=0;w<x;++w)if(A=f[w],!!A.controller.options.grouped){if(typeof i!="undefined"){const R=A.controller.getParsed(i)[A.controller._cachedMeta.vScale.axis];if(at(R)||isNaN(R))continue}if((m===!1||y.indexOf(A.stack)===-1||m===void 0&&A.stack===void 0)&&y.push(A.stack),A.index===n)break}return y.length||y.push(void 0),y}_getStackCount(n){return this._getStacks(void 0,n).length}_getStackIndex(n,i,o){const l=this._getStacks(n,o),u=i!==void 0?l.indexOf(i):-1;return u===-1?l.length-1:u}_getRuler(){const n=this,i=n.options,o=n._cachedMeta,l=o.iScale,u=[];let f,m;for(f=0,m=o.data.length;f<m;++f)u.push(l.getPixelForValue(n.getParsed(f)[l.axis],f));const x=i.barThickness;return{min:x||sg(l),pixels:u,start:l._startPixel,end:l._endPixel,stackCount:n._getStackCount(),scale:l,grouped:i.grouped,ratio:x?1:i.categoryPercentage*i.barPercentage}}_calculateBarValuePixels(n){const i=this,{_cachedMeta:{vScale:o,_stacked:l},options:{base:u,minBarLength:f}}=i,m=u||0,x=i.getParsed(n),y=x._custom,w=Na(y);let A=x[o.axis],R=0,O=l?i.applyStack(o,x,l):A,U,H;O!==A&&(R=O-A,O=A),w&&(A=y.barStart,O=y.barEnd-y.barStart,A!==0&&Yt(A)!==Yt(y.barEnd)&&(R=0),R+=A);const q=!at(u)&&!w?u:R;let Z=o.getPixelForValue(q);if(i.chart.getDataVisibility(n)?U=o.getPixelForValue(R+O):U=Z,H=U-Z,Math.abs(H)<f&&(H=lg(H,o,m)*f,A===m&&(Z-=H/2),U=Z+H),Z===o.getPixelForValue(m)){const ct=Yt(H)*o.getLineWidthForValue(m)/2;Z+=ct,H-=ct}return{size:H,base:Z,head:U,center:U+H/2}}_calculateBarIndexPixels(n,i){const o=this,l=i.scale,u=o.options,f=u.skipNull,m=ft(u.maxBarThickness,1/0);let x,y;if(i.grouped){const w=f?o._getStackCount(n):i.stackCount,A=u.barThickness==="flex"?og(n,i,u,w):rg(n,i,u,w),R=o._getStackIndex(o.index,o._cachedMeta.stack,f?n:void 0);x=A.start+A.chunk*R+A.chunk/2,y=Math.min(m,A.chunk*A.ratio)}else x=l.getPixelForValue(o.getParsed(n)[l.axis],n),y=Math.min(m,i.min*i.ratio);return{base:x-y/2,head:x+y/2,center:x,size:y}}draw(){const n=this,i=n._cachedMeta,o=i.vScale,l=i.data,u=l.length;let f=0;for(;f<u;++f)n.getParsed(f)[o.axis]!==null&&l[f].draw(n._ctx)}}Yr.id="bar",Yr.defaults={datasetElementType:!1,dataElementType:"bar",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:"number",properties:["x","y","base","width","height"]}}},Yr.overrides={scales:{_index_:{type:"category",offset:!0,grid:{offset:!0}},_value_:{type:"linear",beginAtZero:!0}}};class $r extends bn{initialize(){this.enableOptionSharing=!0,super.initialize()}parseObjectData(n,i,o,l){const{xScale:u,yScale:f}=n,{xAxisKey:m="x",yAxisKey:x="y"}=this._parsing,y=[];let w,A,R;for(w=o,A=o+l;w<A;++w)R=i[w],y.push({x:u.parse(fn(R,m),w),y:f.parse(fn(R,x),w),_custom:R&&R.r&&+R.r});return y}getMaxOverflow(){const{data:n,_parsed:i}=this._cachedMeta;let o=0;for(let l=n.length-1;l>=0;--l)o=Math.max(o,n[l].size()/2,i[l]._custom);return o>0&&o}getLabelAndValue(n){const i=this,o=i._cachedMeta,{xScale:l,yScale:u}=o,f=i.getParsed(n),m=l.getLabelForValue(f.x),x=u.getLabelForValue(f.y),y=f._custom;return{label:o.label,value:"("+m+", "+x+(y?", "+y:"")+")"}}update(n){const i=this,o=i._cachedMeta.data;i.updateElements(o,0,o.length,n)}updateElements(n,i,o,l){const u=this,f=l==="reset",{iScale:m,vScale:x}=u._cachedMeta,y=u.resolveDataElementOptions(i,l),w=u.getSharedOptions(y),A=u.includeOptions(l,w),R=m.axis,O=x.axis;for(let U=i;U<i+o;U++){const H=n[U],q=!f&&u.getParsed(U),Z={},ct=Z[R]=f?m.getPixelForDecimal(.5):m.getPixelForValue(q[R]),Tt=Z[O]=f?x.getBasePixel():x.getPixelForValue(q[O]);Z.skip=isNaN(ct)||isNaN(Tt),A&&(Z.options=u.resolveDataElementOptions(U,H.active?"active":l),f&&(Z.options.radius=0)),u.updateElement(H,U,Z,l)}u.updateSharedOptions(w,l,y)}resolveDataElementOptions(n,i){const o=this.getParsed(n);let l=super.resolveDataElementOptions(n,i);l.$shared&&(l=Object.assign({},l,{$shared:!1}));const u=l.radius;return i!=="active"&&(l.radius=0),l.radius+=ft(o&&o._custom,u),l}}$r.id="bubble",$r.defaults={datasetElementType:!1,dataElementType:"point",animations:{numbers:{type:"number",properties:["x","y","borderWidth","radius"]}}},$r.overrides={scales:{x:{type:"linear"},y:{type:"linear"}},plugins:{tooltip:{callbacks:{title(){return""}}}}};function dg(r,n,i){let o=1,l=1,u=0,f=0;if(n<P){const m=r,x=m+n,y=Math.cos(m),w=Math.sin(m),A=Math.cos(x),R=Math.sin(x),O=(Tt,wt,yt)=>Ue(Tt,m,x,!0)?1:Math.max(wt,wt*i,yt,yt*i),U=(Tt,wt,yt)=>Ue(Tt,m,x,!0)?-1:Math.min(wt,wt*i,yt,yt*i),H=O(0,y,A),q=O(lt,w,R),Z=U(ye,y,A),ct=U(ye+lt,w,R);o=(H-Z)/2,l=(q-ct)/2,u=-(H+Z)/2,f=-(q+ct)/2}return{ratioX:o,ratioY:l,offsetX:u,offsetY:f}}class Ni extends bn{constructor(n,i){super(n,i);this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}linkScales(){}parse(n,i){const o=this.getDataset().data,l=this._cachedMeta;let u,f;for(u=n,f=n+i;u<f;++u)l._parsed[u]=+o[u]}_getRotation(){return ue(this.options.rotation-90)}_getCircumference(){return ue(this.options.circumference)}_getRotationExtents(){let n=P,i=-P;const o=this;for(let l=0;l<o.chart.data.datasets.length;++l)if(o.chart.isDatasetVisible(l)){const u=o.chart.getDatasetMeta(l).controller,f=u._getRotation(),m=u._getCircumference();n=Math.min(n,f),i=Math.max(i,f+m)}return{rotation:n,circumference:i-n}}update(n){const i=this,o=i.chart,{chartArea:l}=o,u=i._cachedMeta,f=u.data,m=i.getMaxBorderWidth()+i.getMaxOffset(f)+i.options.spacing,x=Math.max((Math.min(l.width,l.height)-m)/2,0),y=Math.min(W(i.options.cutout,x),1),w=i._getRingWeight(i.index),{circumference:A,rotation:R}=i._getRotationExtents(),{ratioX:O,ratioY:U,offsetX:H,offsetY:q}=dg(R,A,y),Z=(l.width-m)/O,ct=(l.height-m)/U,Tt=Math.max(Math.min(Z,ct)/2,0),wt=Lt(i.options.radius,Tt),yt=Math.max(wt*y,0),Dt=(wt-yt)/i._getVisibleDatasetWeightTotal();i.offsetX=H*wt,i.offsetY=q*wt,u.total=i.calculateTotal(),i.outerRadius=wt-Dt*i._getRingWeightOffset(i.index),i.innerRadius=Math.max(i.outerRadius-Dt*w,0),i.updateElements(f,0,f.length,n)}_circumference(n,i){const o=this,l=o.options,u=o._cachedMeta,f=o._getCircumference();return i&&l.animation.animateRotate||!this.chart.getDataVisibility(n)||u._parsed[n]===null||u.data[n].hidden?0:o.calculateCircumference(u._parsed[n]*f/P)}updateElements(n,i,o,l){const u=this,f=l==="reset",m=u.chart,x=m.chartArea,w=m.options.animation,A=(x.left+x.right)/2,R=(x.top+x.bottom)/2,O=f&&w.animateScale,U=O?0:u.innerRadius,H=O?0:u.outerRadius,q=u.resolveDataElementOptions(i,l),Z=u.getSharedOptions(q),ct=u.includeOptions(l,Z);let Tt=u._getRotation(),wt;for(wt=0;wt<i;++wt)Tt+=u._circumference(wt,f);for(wt=i;wt<i+o;++wt){const yt=u._circumference(wt,f),Dt=n[wt],Ut={x:A+u.offsetX,y:R+u.offsetY,startAngle:Tt,endAngle:Tt+yt,circumference:yt,outerRadius:H,innerRadius:U};ct&&(Ut.options=Z||u.resolveDataElementOptions(wt,Dt.active?"active":l)),Tt+=yt,u.updateElement(Dt,wt,Ut,l)}u.updateSharedOptions(Z,l,q)}calculateTotal(){const n=this._cachedMeta,i=n.data;let o=0,l;for(l=0;l<i.length;l++){const u=n._parsed[l];u!==null&&!isNaN(u)&&this.chart.getDataVisibility(l)&&!i[l].hidden&&(o+=Math.abs(u))}return o}calculateCircumference(n){const i=this._cachedMeta.total;return i>0&&!isNaN(n)?P*(Math.abs(n)/i):0}getLabelAndValue(n){const i=this,o=i._cachedMeta,l=i.chart,u=l.data.labels||[],f=zi(o._parsed[n],l.options.locale);return{label:u[n]||"",value:f}}getMaxBorderWidth(n){const i=this;let o=0;const l=i.chart;let u,f,m,x,y;if(!n){for(u=0,f=l.data.datasets.length;u<f;++u)if(l.isDatasetVisible(u)){m=l.getDatasetMeta(u),n=m.data,x=m.controller,x!==i&&x.configure();break}}if(!n)return 0;for(u=0,f=n.length;u<f;++u)y=x.resolveDataElementOptions(u),y.borderAlign!=="inner"&&(o=Math.max(o,y.borderWidth||0,y.hoverBorderWidth||0));return o}getMaxOffset(n){let i=0;for(let o=0,l=n.length;o<l;++o){const u=this.resolveDataElementOptions(o);i=Math.max(i,u.offset||0,u.hoverOffset||0)}return i}_getRingWeightOffset(n){let i=0;for(let o=0;o<n;++o)this.chart.isDatasetVisible(o)&&(i+=this._getRingWeight(o));return i}_getRingWeight(n){return Math.max(ft(this.chart.data.datasets[n].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}Ni.id="doughnut",Ni.defaults={datasetElementType:!1,dataElementType:"arc",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:"number",properties:["circumference","endAngle","innerRadius","outerRadius","startAngle","x","y","offset","borderWidth","spacing"]}},cutout:"50%",rotation:0,circumference:360,radius:"100%",spacing:0,indexAxis:"r"},Ni.descriptors={_scriptable:r=>r!=="spacing",_indexable:r=>r!=="spacing"},Ni.overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(r){const n=r.data;if(n.labels.length&&n.datasets.length){const{labels:{pointStyle:i}}=r.legend.options;return n.labels.map((o,l)=>{const f=r.getDatasetMeta(0).controller.getStyle(l);return{text:o,fillStyle:f.backgroundColor,strokeStyle:f.borderColor,lineWidth:f.borderWidth,pointStyle:i,hidden:!r.getDataVisibility(l),index:l}})}return[]}},onClick(r,n,i){i.chart.toggleDataVisibility(n.index),i.chart.update()}},tooltip:{callbacks:{title(){return""},label(r){let n=r.label;const i=": "+r.formattedValue;return gt(n)?(n=n.slice(),n[0]+=i):n+=i,n}}}}};class js extends bn{initialize(){this.enableOptionSharing=!0,super.initialize()}update(n){const i=this,o=i._cachedMeta,{dataset:l,data:u=[],_dataset:f}=o,m=i.chart._animationsDisabled;let{start:x,count:y}=fg(o,u,m);i._drawStart=x,i._drawCount=y,pg(o)&&(x=0,y=u.length),l._datasetIndex=i.index,l._decimated=!!f._decimated,l.points=u;const w=i.resolveDatasetElementOptions(n);i.options.showLine||(w.borderWidth=0),w.segment=i.options.segment,i.updateElement(l,void 0,{animated:!m,options:w},n),i.updateElements(u,x,y,n)}updateElements(n,i,o,l){const u=this,f=l==="reset",{iScale:m,vScale:x,_stacked:y}=u._cachedMeta,w=u.resolveDataElementOptions(i,l),A=u.getSharedOptions(w),R=u.includeOptions(l,A),O=m.axis,U=x.axis,H=u.options.spanGaps,q=te(H)?H:Number.POSITIVE_INFINITY,Z=u.chart._animationsDisabled||f||l==="none";let ct=i>0&&u.getParsed(i-1);for(let Tt=i;Tt<i+o;++Tt){const wt=n[Tt],yt=u.getParsed(Tt),Dt=Z?wt:{},Ut=at(yt[U]),zt=Dt[O]=m.getPixelForValue(yt[O],Tt),Kt=Dt[U]=f||Ut?x.getBasePixel():x.getPixelForValue(y?u.applyStack(x,yt,y):yt[U],Tt);Dt.skip=isNaN(zt)||isNaN(Kt)||Ut,Dt.stop=Tt>0&&yt[O]-ct[O]>q,Dt.parsed=yt,R&&(Dt.options=A||u.resolveDataElementOptions(Tt,wt.active?"active":l)),Z||u.updateElement(wt,Tt,Dt,l),ct=yt}u.updateSharedOptions(A,l,w)}getMaxOverflow(){const n=this,i=n._cachedMeta,o=i.dataset,l=o.options&&o.options.borderWidth||0,u=i.data||[];if(!u.length)return l;const f=u[0].size(n.resolveDataElementOptions(0)),m=u[u.length-1].size(n.resolveDataElementOptions(u.length-1));return Math.max(l,f,m)/2}draw(){const n=this._cachedMeta;n.dataset.updateControlPoints(this.chart.chartArea,n.iScale.axis),super.draw()}}js.id="line",js.defaults={datasetElementType:"line",dataElementType:"point",showLine:!0,spanGaps:!1},js.overrides={scales:{_index_:{type:"category"},_value_:{type:"linear"}}};function fg(r,n,i){const o=n.length;let l=0,u=o;if(r._sorted){const{iScale:f,_parsed:m}=r,x=f.axis,{min:y,max:w,minDefined:A,maxDefined:R}=f.getUserBounds();A&&(l=Fe(Math.min(Rn(m,f.axis,y).lo,i?o:Rn(n,x,f.getPixelForValue(y)).lo),0,o-1)),R?u=Fe(Math.max(Rn(m,f.axis,w).hi+1,i?0:Rn(n,x,f.getPixelForValue(w)).hi+1),l,o)-l:u=o-l}return{start:l,count:u}}function pg(r){const{xScale:n,yScale:i,_scaleRanges:o}=r,l={xmin:n.min,xmax:n.max,ymin:i.min,ymax:i.max};if(!o)return r._scaleRanges=l,!0;const u=o.xmin!==n.min||o.xmax!==n.max||o.ymin!==i.min||o.ymax!==i.max;return Object.assign(o,l),u}class Zr extends bn{constructor(n,i){super(n,i);this.innerRadius=void 0,this.outerRadius=void 0}getLabelAndValue(n){const i=this,o=i._cachedMeta,l=i.chart,u=l.data.labels||[],f=zi(o._parsed[n].r,l.options.locale);return{label:u[n]||"",value:f}}update(n){const i=this._cachedMeta.data;this._updateRadius(),this.updateElements(i,0,i.length,n)}_updateRadius(){const n=this,i=n.chart,o=i.chartArea,l=i.options,u=Math.min(o.right-o.left,o.bottom-o.top),f=Math.max(u/2,0),m=Math.max(l.cutoutPercentage?f/100*l.cutoutPercentage:1,0),x=(f-m)/i.getVisibleDatasetCount();n.outerRadius=f-x*n.index,n.innerRadius=n.outerRadius-x}updateElements(n,i,o,l){const u=this,f=l==="reset",m=u.chart,x=u.getDataset(),w=m.options.animation,A=u._cachedMeta.rScale,R=A.xCenter,O=A.yCenter,U=A.getIndexAngle(0)-.5*ye;let H=U,q;const Z=360/u.countVisibleElements();for(q=0;q<i;++q)H+=u._computeAngle(q,l,Z);for(q=i;q<i+o;q++){const ct=n[q];let Tt=H,wt=H+u._computeAngle(q,l,Z),yt=m.getDataVisibility(q)?A.getDistanceFromCenterForValue(x.data[q]):0;H=wt,f&&(w.animateScale&&(yt=0),w.animateRotate&&(Tt=wt=U));const Dt={x:R,y:O,innerRadius:0,outerRadius:yt,startAngle:Tt,endAngle:wt,options:u.resolveDataElementOptions(q,ct.active?"active":l)};u.updateElement(ct,q,Dt,l)}}countVisibleElements(){const n=this.getDataset(),i=this._cachedMeta;let o=0;return i.data.forEach((l,u)=>{!isNaN(n.data[u])&&this.chart.getDataVisibility(u)&&o++}),o}_computeAngle(n,i,o){return this.chart.getDataVisibility(n)?ue(this.resolveDataElementOptions(n,i).angle||o):0}}Zr.id="polarArea",Zr.defaults={dataElementType:"arc",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:"number",properties:["x","y","startAngle","endAngle","innerRadius","outerRadius"]}},indexAxis:"r",startAngle:0},Zr.overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(r){const n=r.data;if(n.labels.length&&n.datasets.length){const{labels:{pointStyle:i}}=r.legend.options;return n.labels.map((o,l)=>{const f=r.getDatasetMeta(0).controller.getStyle(l);return{text:o,fillStyle:f.backgroundColor,strokeStyle:f.borderColor,lineWidth:f.borderWidth,pointStyle:i,hidden:!r.getDataVisibility(l),index:l}})}return[]}},onClick(r,n,i){i.chart.toggleDataVisibility(n.index),i.chart.update()}},tooltip:{callbacks:{title(){return""},label(r){return r.chart.data.labels[r.dataIndex]+": "+r.formattedValue}}}},scales:{r:{type:"radialLinear",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}};class Va extends Ni{}Va.id="pie",Va.defaults={cutout:0,rotation:0,circumference:360,radius:"100%"};class Jr extends bn{getLabelAndValue(n){const i=this,o=i._cachedMeta.vScale,l=i.getParsed(n);return{label:o.getLabels()[n],value:""+o.getLabelForValue(l[o.axis])}}update(n){const i=this,o=i._cachedMeta,l=o.dataset,u=o.data||[],f=o.iScale.getLabels();if(l.points=u,n!=="resize"){const m=i.resolveDatasetElementOptions(n);i.options.showLine||(m.borderWidth=0);const x={_loop:!0,_fullLoop:f.length===u.length,options:m};i.updateElement(l,void 0,x,n)}i.updateElements(u,0,u.length,n)}updateElements(n,i,o,l){const u=this,f=u.getDataset(),m=u._cachedMeta.rScale,x=l==="reset";for(let y=i;y<i+o;y++){const w=n[y],A=u.resolveDataElementOptions(y,w.active?"active":l),R=m.getPointPositionForValue(y,f.data[y]),O=x?m.xCenter:R.x,U=x?m.yCenter:R.y,H={x:O,y:U,angle:R.angle,skip:isNaN(O)||isNaN(U),options:A};u.updateElement(w,y,H,l)}}}Jr.id="radar",Jr.defaults={datasetElementType:"line",dataElementType:"point",indexAxis:"r",showLine:!0,elements:{line:{fill:"start"}}},Jr.overrides={aspectRatio:1,scales:{r:{type:"radialLinear"}}};class Kr extends js{}Kr.id="scatter",Kr.defaults={showLine:!1,fill:!1},Kr.overrides={interaction:{mode:"point"},plugins:{tooltip:{callbacks:{title(){return""},label(r){return"("+r.label+", "+r.formattedValue+")"}}}},scales:{x:{type:"linear"},y:{type:"linear"}}};var eh=Object.freeze({__proto__:null,BarController:Yr,BubbleController:$r,DoughnutController:Ni,LineController:js,PolarAreaController:Zr,PieController:Va,RadarController:Jr,ScatterController:Kr});function nh(r,n,i){const{startAngle:o,pixelMargin:l,x:u,y:f,outerRadius:m,innerRadius:x}=n;let y=l/m;r.beginPath(),r.arc(u,f,m,o-y,i+y),x>l?(y=l/x,r.arc(u,f,x,i+y,o-y,!0)):r.arc(u,f,l,i+lt,o-lt),r.closePath(),r.clip()}function mg(r){return Br(r,["outerStart","outerEnd","innerStart","innerEnd"])}function gg(r,n,i,o){const l=mg(r.options.borderRadius),u=(i-n)/2,f=Math.min(u,o*n/2),m=x=>{const y=(i-Math.min(u,x))*o/2;return Fe(x,0,Math.min(u,y))};return{outerStart:m(l.outerStart),outerEnd:m(l.outerEnd),innerStart:Fe(l.innerStart,0,f),innerEnd:Fe(l.innerEnd,0,f)}}function Vi(r,n,i,o){return{x:i+r*Math.cos(n),y:o+r*Math.sin(n)}}function Ua(r,n,i,o,l){const{x:u,y:f,startAngle:m,pixelMargin:x,innerRadius:y}=n,w=Math.max(n.outerRadius+o+i-x,0),A=y>0?y+o+i+x:0;let R=0;const O=l-m;if(o){const $t=y>0?y-o:0,Qe=w>0?w-o:0,Ti=($t+Qe)/2,Zs=Ti!==0?O*Ti/(Ti+o):O;R=(O-Zs)/2}const U=Math.max(.001,O*w-i/ye)/w,H=(O-U)/2,q=m+H+R,Z=l-H-R,{outerStart:ct,outerEnd:Tt,innerStart:wt,innerEnd:yt}=gg(n,A,w,Z-q),Dt=w-ct,Ut=w-Tt,zt=q+ct/Dt,Kt=Z-Tt/Ut,he=A+wt,ae=A+yt,Se=q+wt/he,le=Z-yt/ae;if(r.beginPath(),r.arc(u,f,w,zt,Kt),Tt>0){const $t=Vi(Ut,Kt,u,f);r.arc($t.x,$t.y,Tt,Kt,Z+lt)}const Re=Vi(ae,Z,u,f);if(r.lineTo(Re.x,Re.y),yt>0){const $t=Vi(ae,le,u,f);r.arc($t.x,$t.y,yt,Z+lt,le+Math.PI)}if(r.arc(u,f,A,Z-yt/A,q+wt/A,!0),wt>0){const $t=Vi(he,Se,u,f);r.arc($t.x,$t.y,wt,Se+Math.PI,q-lt)}const Ke=Vi(Dt,q,u,f);if(r.lineTo(Ke.x,Ke.y),ct>0){const $t=Vi(Dt,zt,u,f);r.arc($t.x,$t.y,ct,q-lt,zt)}r.closePath()}function xg(r,n,i,o){const{fullCircles:l,startAngle:u,circumference:f}=n;let m=n.endAngle;if(l){Ua(r,n,i,o,u+P);for(let x=0;x<l;++x)r.fill();isNaN(f)||(m=u+f%P,f%P==0&&(m+=P))}return Ua(r,n,i,o,m),r.fill(),m}function _g(r,n,i){const{x:o,y:l,startAngle:u,pixelMargin:f,fullCircles:m}=n,x=Math.max(n.outerRadius-f,0),y=n.innerRadius+f;let w;for(i&&nh(r,n,u+P),r.beginPath(),r.arc(o,l,y,u+P,u,!0),w=0;w<m;++w)r.stroke();for(r.beginPath(),r.arc(o,l,x,u,u+P),w=0;w<m;++w)r.stroke()}function yg(r,n,i,o,l){const{options:u}=n,f=u.borderAlign==="inner";!u.borderWidth||(f?(r.lineWidth=u.borderWidth*2,r.lineJoin="round"):(r.lineWidth=u.borderWidth,r.lineJoin="bevel"),n.fullCircles&&_g(r,n,f),f&&nh(r,n,l),Ua(r,n,i,o,l),r.stroke())}class Qr extends gn{constructor(n){super();this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,n&&Object.assign(this,n)}inRange(n,i,o){const l=this.getProps(["x","y"],o),{angle:u,distance:f}=an(l,{x:n,y:i}),{startAngle:m,endAngle:x,innerRadius:y,outerRadius:w,circumference:A}=this.getProps(["startAngle","endAngle","innerRadius","outerRadius","circumference"],o),R=this.options.spacing/2,O=A>=P||Ue(u,m,x),U=f>=y+R&&f<=w+R;return O&&U}getCenterPoint(n){const{x:i,y:o,startAngle:l,endAngle:u,innerRadius:f,outerRadius:m}=this.getProps(["x","y","startAngle","endAngle","innerRadius","outerRadius","circumference"],n),{offset:x,spacing:y}=this.options,w=(l+u)/2,A=(f+m+y+x)/2;return{x:i+Math.cos(w)*A,y:o+Math.sin(w)*A}}tooltipPosition(n){return this.getCenterPoint(n)}draw(n){const i=this,{options:o,circumference:l}=i,u=(o.offset||0)/2,f=(o.spacing||0)/2;if(i.pixelMargin=o.borderAlign==="inner"?.33:0,i.fullCircles=l>P?Math.floor(l/P):0,l===0||i.innerRadius<0||i.outerRadius<0)return;n.save();let m=0;if(u){m=u/2;const y=(i.startAngle+i.endAngle)/2;n.translate(Math.cos(y)*m,Math.sin(y)*m),i.circumference>=ye&&(m=u)}n.fillStyle=o.backgroundColor,n.strokeStyle=o.borderColor;const x=xg(n,i,m,f);yg(n,i,m,f,x),n.restore()}}Qr.id="arc",Qr.defaults={borderAlign:"center",borderColor:"#fff",borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0},Qr.defaultRoutes={backgroundColor:"backgroundColor"};function ih(r,n,i=n){r.lineCap=ft(i.borderCapStyle,n.borderCapStyle),r.setLineDash(ft(i.borderDash,n.borderDash)),r.lineDashOffset=ft(i.borderDashOffset,n.borderDashOffset),r.lineJoin=ft(i.borderJoinStyle,n.borderJoinStyle),r.lineWidth=ft(i.borderWidth,n.borderWidth),r.strokeStyle=ft(i.borderColor,n.borderColor)}function vg(r,n,i){r.lineTo(i.x,i.y)}function bg(r){return r.stepped?Ic:r.tension||r.cubicInterpolationMode==="monotone"?Fc:vg}function sh(r,n,i={}){const o=r.length,{start:l=0,end:u=o-1}=i,{start:f,end:m}=n,x=Math.max(l,f),y=Math.min(u,m),w=l<f&&u<f||l>m&&u>m;return{count:o,start:x,loop:n.loop,ilen:y<x&&!w?o+y-x:y-x}}function Mg(r,n,i,o){const{points:l,options:u}=n,{count:f,start:m,loop:x,ilen:y}=sh(l,i,o),w=bg(u);let{move:A=!0,reverse:R}=o||{},O,U,H;for(O=0;O<=y;++O)U=l[(m+(R?y-O:O))%f],!U.skip&&(A?(r.moveTo(U.x,U.y),A=!1):w(r,H,U,R,u.stepped),H=U);return x&&(U=l[(m+(R?y:0))%f],w(r,H,U,R,u.stepped)),!!x}function wg(r,n,i,o){const l=n.points,{count:u,start:f,ilen:m}=sh(l,i,o),{move:x=!0,reverse:y}=o||{};let w=0,A=0,R,O,U,H,q,Z;const ct=wt=>(f+(y?m-wt:wt))%u,Tt=()=>{H!==q&&(r.lineTo(w,q),r.lineTo(w,H),r.lineTo(w,Z))};for(x&&(O=l[ct(0)],r.moveTo(O.x,O.y)),R=0;R<=m;++R){if(O=l[ct(R)],O.skip)continue;const wt=O.x,yt=O.y,Dt=wt|0;Dt===U?(yt<H?H=yt:yt>q&&(q=yt),w=(A*w+wt)/++A):(Tt(),r.lineTo(wt,yt),U=Dt,A=0,H=q=yt),Z=yt}Tt()}function Ha(r){const n=r.options,i=n.borderDash&&n.borderDash.length;return!r._decimated&&!r._loop&&!n.tension&&n.cubicInterpolationMode!=="monotone"&&!n.stepped&&!i?wg:Mg}function Sg(r){return r.stepped?uu:r.tension||r.cubicInterpolationMode==="monotone"?hu:Jn}function Tg(r,n,i,o){let l=n._path;l||(l=n._path=new Path2D,n.path(l,i,o)&&l.closePath()),ih(r,n.options),r.stroke(l)}function Eg(r,n,i,o){const{segments:l,options:u}=n,f=Ha(n);for(const m of l)ih(r,u,m.style),r.beginPath(),f(r,n,m,{start:i,end:i+o-1})&&r.closePath(),r.stroke()}const Ag=typeof Path2D=="function";function Lg(r,n,i,o){Ag&&n.segments.length===1?Tg(r,n,i,o):Eg(r,n,i,o)}class ti extends gn{constructor(n){super();this.animated=!0,this.options=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,n&&Object.assign(this,n)}updateControlPoints(n,i){const o=this,l=o.options;if((l.tension||l.cubicInterpolationMode==="monotone")&&!l.stepped&&!o._pointsUpdated){const u=l.spanGaps?o._loop:o._fullLoop;au(o._points,l,n,u,i),o._pointsUpdated=!0}}set points(n){const i=this;i._points=n,delete i._segments,delete i._path,i._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=mu(this,this.options.segment))}first(){const n=this.segments,i=this.points;return n.length&&i[n[0].start]}last(){const n=this.segments,i=this.points,o=n.length;return o&&i[n[o-1].end]}interpolate(n,i){const o=this,l=o.options,u=n[i],f=o.points,m=Ra(o,{property:i,start:u,end:u});if(!m.length)return;const x=[],y=Sg(l);let w,A;for(w=0,A=m.length;w<A;++w){const{start:R,end:O}=m[w],U=f[R],H=f[O];if(U===H){x.push(U);continue}const q=Math.abs((u-U[i])/(H[i]-U[i])),Z=y(U,H,q,l.stepped);Z[i]=n[i],x.push(Z)}return x.length===1?x[0]:x}pathSegment(n,i,o){return Ha(this)(n,this,i,o)}path(n,i,o){const l=this,u=l.segments,f=Ha(l);let m=l._loop;i=i||0,o=o||l.points.length-i;for(const x of u)m&=f(n,l,x,{start:i,end:i+o-1});return!!m}draw(n,i,o,l){const u=this,f=u.options||{};!(u.points||[]).length||!f.borderWidth||(n.save(),Lg(n,u,o,l),n.restore(),u.animated&&(u._pointsUpdated=!1,u._path=void 0))}}ti.id="line",ti.defaults={borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:"default",fill:!1,spanGaps:!1,stepped:!1,tension:0},ti.defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"},ti.descriptors={_scriptable:!0,_indexable:r=>r!=="borderDash"&&r!=="fill"};function rh(r,n,i,o){const l=r.options,{[i]:u}=r.getProps([i],o);return Math.abs(n-u)<l.radius+l.hitRadius}class to extends gn{constructor(n){super();this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,n&&Object.assign(this,n)}inRange(n,i,o){const l=this.options,{x:u,y:f}=this.getProps(["x","y"],o);return Math.pow(n-u,2)+Math.pow(i-f,2)<Math.pow(l.hitRadius+l.radius,2)}inXRange(n,i){return rh(this,n,"x",i)}inYRange(n,i){return rh(this,n,"y",i)}getCenterPoint(n){const{x:i,y:o}=this.getProps(["x","y"],n);return{x:i,y:o}}size(n){n=n||this.options||{};let i=n.radius||0;i=Math.max(i,i&&n.hoverRadius||0);const o=i&&n.borderWidth||0;return(i+o)*2}draw(n,i){const o=this,l=o.options;o.skip||l.radius<.1||!$n(o,i,o.size(l)/2)||(n.strokeStyle=l.borderColor,n.lineWidth=l.borderWidth,n.fillStyle=l.backgroundColor,Is(n,l,o.x,o.y))}getRange(){const n=this.options||{};return n.radius+n.hitRadius}}to.id="point",to.defaults={borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0},to.defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};function oh(r,n){const{x:i,y:o,base:l,width:u,height:f}=r.getProps(["x","y","base","width","height"],n);let m,x,y,w,A;return r.horizontal?(A=f/2,m=Math.min(i,l),x=Math.max(i,l),y=o-A,w=o+A):(A=u/2,m=i-A,x=i+A,y=Math.min(o,l),w=Math.max(o,l)),{left:m,top:y,right:x,bottom:w}}function ei(r,n,i,o){return r?0:Fe(n,i,o)}function Cg(r,n,i){const o=r.options.borderWidth,l=r.borderSkipped,u=Sa(o);return{t:ei(l.top,u.top,0,i),r:ei(l.right,u.right,0,n),b:ei(l.bottom,u.bottom,0,i),l:ei(l.left,u.left,0,n)}}function Rg(r,n,i){const{enableBorderRadius:o}=r.getProps(["enableBorderRadius"]),l=r.options.borderRadius,u=zr(l),f=Math.min(n,i),m=r.borderSkipped,x=o||Et(l);return{topLeft:ei(!x||m.top||m.left,u.topLeft,0,f),topRight:ei(!x||m.top||m.right,u.topRight,0,f),bottomLeft:ei(!x||m.bottom||m.left,u.bottomLeft,0,f),bottomRight:ei(!x||m.bottom||m.right,u.bottomRight,0,f)}}function Pg(r){const n=oh(r),i=n.right-n.left,o=n.bottom-n.top,l=Cg(r,i/2,o/2),u=Rg(r,i/2,o/2);return{outer:{x:n.left,y:n.top,w:i,h:o,radius:u},inner:{x:n.left+l.l,y:n.top+l.t,w:i-l.l-l.r,h:o-l.t-l.b,radius:{topLeft:Math.max(0,u.topLeft-Math.max(l.t,l.l)),topRight:Math.max(0,u.topRight-Math.max(l.t,l.r)),bottomLeft:Math.max(0,u.bottomLeft-Math.max(l.b,l.l)),bottomRight:Math.max(0,u.bottomRight-Math.max(l.b,l.r))}}}}function Wa(r,n,i,o){const l=n===null,u=i===null,m=r&&!(l&&u)&&oh(r,o);return m&&(l||n>=m.left&&n<=m.right)&&(u||i>=m.top&&i<=m.bottom)}function Dg(r){return r.topLeft||r.topRight||r.bottomLeft||r.bottomRight}function Ig(r,n){r.rect(n.x,n.y,n.w,n.h)}function Ga(r,n,i={}){const o=r.x!==i.x?-n:0,l=r.y!==i.y?-n:0,u=(r.x+r.w!==i.x+i.w?n:0)-o,f=(r.y+r.h!==i.y+i.h?n:0)-l;return{x:r.x+o,y:r.y+l,w:r.w+u,h:r.h+f,radius:r.radius}}class eo extends gn{constructor(n){super();this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,n&&Object.assign(this,n)}draw(n){const i=this.options,{inner:o,outer:l}=Pg(this),u=Dg(l.radius)?Os:Ig,f=.33;n.save(),(l.w!==o.w||l.h!==o.h)&&(n.beginPath(),u(n,Ga(l,f,o)),n.clip(),u(n,Ga(o,-f,l)),n.fillStyle=i.borderColor,n.fill("evenodd")),n.beginPath(),u(n,Ga(o,f,l)),n.fillStyle=i.backgroundColor,n.fill(),n.restore()}inRange(n,i,o){return Wa(this,n,i,o)}inXRange(n,i){return Wa(this,n,null,i)}inYRange(n,i){return Wa(this,null,n,i)}getCenterPoint(n){const{x:i,y:o,base:l,horizontal:u}=this.getProps(["x","y","base","horizontal"],n);return{x:u?(i+l)/2:i,y:u?o:(o+l)/2}}getRange(n){return n==="x"?this.width/2:this.height/2}}eo.id="bar",eo.defaults={borderSkipped:"start",borderWidth:0,borderRadius:0,enableBorderRadius:!0,pointStyle:void 0},eo.defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};var Xa=Object.freeze({__proto__:null,ArcElement:Qr,LineElement:ti,PointElement:to,BarElement:eo});function Fg(r,n,i,o,l){const u=l.samples||o;if(u>=i)return r.slice(n,n+i);const f=[],m=(i-2)/(u-2);let x=0;const y=n+i-1;let w=n,A,R,O,U,H;for(f[x++]=r[w],A=0;A<u-2;A++){let q=0,Z=0,ct;const Tt=Math.floor((A+1)*m)+1+n,wt=Math.min(Math.floor((A+2)*m)+1,i)+n,yt=wt-Tt;for(ct=Tt;ct<wt;ct++)q+=r[ct].x,Z+=r[ct].y;q/=yt,Z/=yt;const Dt=Math.floor(A*m)+1+n,Ut=Math.min(Math.floor((A+1)*m)+1,i)+n,{x:zt,y:Kt}=r[w];for(O=U=-1,ct=Dt;ct<Ut;ct++)U=.5*Math.abs((zt-q)*(r[ct].y-Kt)-(zt-r[ct].x)*(Z-Kt)),U>O&&(O=U,R=r[ct],H=ct);f[x++]=R,w=H}return f[x++]=r[y],f}function kg(r,n,i,o){let l=0,u=0,f,m,x,y,w,A,R,O,U,H;const q=[],Z=n+i-1,ct=r[n].x,wt=r[Z].x-ct;for(f=n;f<n+i;++f){m=r[f],x=(m.x-ct)/wt*o,y=m.y;const yt=x|0;if(yt===w)y<U?(U=y,A=f):y>H&&(H=y,R=f),l=(u*l+m.x)/++u;else{const Dt=f-1;if(!at(A)&&!at(R)){const Ut=Math.min(A,R),zt=Math.max(A,R);Ut!==O&&Ut!==Dt&&q.push(il(Qs({},r[Ut]),{x:l})),zt!==O&&zt!==Dt&&q.push(il(Qs({},r[zt]),{x:l}))}f>0&&Dt!==O&&q.push(r[Dt]),q.push(m),w=yt,u=0,U=H=y,A=R=O=f}}return q}function ah(r){if(r._decimated){const n=r._data;delete r._decimated,delete r._data,Object.defineProperty(r,"data",{value:n})}}function lh(r){r.data.datasets.forEach(n=>{ah(n)})}function Og(r,n){const i=n.length;let o=0,l;const{iScale:u}=r,{min:f,max:m,minDefined:x,maxDefined:y}=u.getUserBounds();return x&&(o=Fe(Rn(n,u.axis,f).lo,0,i-1)),y?l=Fe(Rn(n,u.axis,m).hi+1,o,i)-o:l=i-o,{start:o,count:l}}var Bg={id:"decimation",defaults:{algorithm:"min-max",enabled:!1},beforeElementsUpdate:(r,n,i)=>{if(!i.enabled){lh(r);return}const o=r.width;r.data.datasets.forEach((l,u)=>{const{_data:f,indexAxis:m}=l,x=r.getDatasetMeta(u),y=f||l.data;if(ki([m,r.options.indexAxis])==="y"||x.type!=="line")return;const w=r.scales[x.xAxisID];if(w.type!=="linear"&&w.type!=="time"||r.options.parsing)return;let{start:A,count:R}=Og(x,y);const O=i.threshold||4*o;if(R<=O){ah(l);return}at(f)&&(l._data=y,delete l.data,Object.defineProperty(l,"data",{configurable:!0,enumerable:!0,get:function(){return this._decimated},set:function(H){this._data=H}}));let U;switch(i.algorithm){case"lttb":U=Fg(y,A,R,o,i);break;case"min-max":U=kg(y,A,R,o);break;default:throw new Error(`Unsupported decimation algorithm '${i.algorithm}'`)}l._decimated=U})},destroy(r){lh(r)}};function zg(r,n){const i=r.getDatasetMeta(n);return i&&r.isDatasetVisible(n)?i.dataset:null}function Ng(r){const n=r.options,i=n.fill;let o=ft(i&&i.target,i);return o===void 0&&(o=!!n.backgroundColor),o===!1||o===null?!1:o===!0?"origin":o}function Vg(r,n,i){const o=Ng(r);if(Et(o))return isNaN(o.value)?!1:o;let l=parseFloat(o);return At(l)&&Math.floor(l)===l?((o[0]==="-"||o[0]==="+")&&(l=n+l),l===n||l<0||l>=i?!1:l):["origin","start","end","stack","shape"].indexOf(o)>=0&&o}function Ug(r){const{scale:n={},fill:i}=r;let o=null,l;return i==="start"?o=n.bottom:i==="end"?o=n.top:Et(i)?o=n.getPixelForValue(i.value):n.getBasePixel&&(o=n.getBasePixel()),At(o)?(l=n.isHorizontal(),{x:l?o:null,y:l?null:o}):null}class ch{constructor(n){this.x=n.x,this.y=n.y,this.radius=n.radius}pathSegment(n,i,o){const{x:l,y:u,radius:f}=this;return i=i||{start:0,end:P},n.arc(l,u,f,i.end,i.start,!0),!o.bounds}interpolate(n){const{x:i,y:o,radius:l}=this,u=n.angle;return{x:i+Math.cos(u)*l,y:o+Math.sin(u)*l,angle:u}}}function Hg(r){const{scale:n,fill:i}=r,o=n.options,l=n.getLabels().length,u=[],f=o.reverse?n.max:n.min,m=o.reverse?n.min:n.max;let x,y,w;if(i==="start"?w=f:i==="end"?w=m:Et(i)?w=i.value:w=n.getBaseValue(),o.grid.circular)return y=n.getPointPositionForValue(0,f),new ch({x:y.x,y:y.y,radius:n.getDistanceFromCenterForValue(w)});for(x=0;x<l;++x)u.push(n.getPointPositionForValue(x,w));return u}function Wg(r){return(r.scale||{}).getPointPositionForValue?Hg(r):Ug(r)}function uh(r,n,i){for(;n>r;n--){const o=i[n];if(!isNaN(o.x)&&!isNaN(o.y))break}return n}function Gg(r,n){const{x:i=null,y:o=null}=r||{},l=n.points,u=[];return n.segments.forEach(({start:f,end:m})=>{m=uh(f,m,l);const x=l[f],y=l[m];o!==null?(u.push({x:x.x,y:o}),u.push({x:y.x,y:o})):i!==null&&(u.push({x:i,y:x.y}),u.push({x:i,y:y.y}))}),u}function Xg(r){const{chart:n,scale:i,index:o,line:l}=r,u=[],f=l.segments,m=l.points,x=qg(n,o);x.push(hh({x:null,y:i.bottom},l));for(let y=0;y<f.length;y++){const w=f[y];for(let A=w.start;A<=w.end;A++)Yg(u,m[A],x)}return new ti({points:u,options:{}})}const jg=r=>r.type==="line"&&!r.hidden;function qg(r,n){const i=[],o=r.getSortedVisibleDatasetMetas();for(let l=0;l<o.length;l++){const u=o[l];if(u.index===n)break;jg(u)&&i.unshift(u.dataset)}return i}function Yg(r,n,i){const o=[];for(let l=0;l<i.length;l++){const u=i[l],{first:f,last:m,point:x}=$g(u,n,"x");if(!(!x||f&&m)){if(f)o.unshift(x);else if(r.push(x),!m)break}}r.push(...o)}function $g(r,n,i){const o=r.interpolate(n,i);if(!o)return{};const l=o[i],u=r.segments,f=r.points;let m=!1,x=!1;for(let y=0;y<u.length;y++){const w=u[y],A=f[w.start][i],R=f[w.end][i];if(l>=A&&l<=R){m=l===A,x=l===R;break}}return{first:m,last:x,point:o}}function Zg(r){const{chart:n,fill:i,line:o}=r;if(At(i))return zg(n,i);if(i==="stack")return Xg(r);if(i==="shape")return!0;const l=Wg(r);return l instanceof ch?l:hh(l,o)}function hh(r,n){let i=[],o=!1;return gt(r)?(o=!0,i=r):i=Gg(r,n),i.length?new ti({points:i,options:{tension:0},_loop:o,_fullLoop:o}):null}function Jg(r,n,i){let l=r[n].fill;const u=[n];let f;if(!i)return l;for(;l!==!1&&u.indexOf(l)===-1;){if(!At(l))return l;if(f=r[l],!f)return!1;if(f.visible)return l;u.push(l),l=f.fill}return!1}function dh(r,n,i){r.beginPath(),n.path(r),r.lineTo(n.last().x,i),r.lineTo(n.first().x,i),r.closePath(),r.clip()}function ja(r,n,i,o){if(o)return;let l=n[r],u=i[r];return r==="angle"&&(l=Me(l),u=Me(u)),{property:r,start:l,end:u}}function fh(r,n,i,o){return r&&n?o(r[i],n[i]):r?r[i]:n?n[i]:0}function Kg(r,n,i){const o=r.segments,l=r.points,u=n.points,f=[];for(const m of o){let{start:x,end:y}=m;y=uh(x,y,l);const w=ja(i,l[x],l[y],m.loop);if(!n.segments){f.push({source:m,target:w,start:l[x],end:l[y]});continue}const A=Ra(n,w);for(const R of A){const O=ja(i,u[R.start],u[R.end],R.loop),U=Ca(m,l,O);for(const H of U)f.push({source:H,target:R,start:{[i]:fh(w,O,"start",Math.max)},end:{[i]:fh(w,O,"end",Math.min)}})}}return f}function Qg(r,n,i){const{top:o,bottom:l}=n.chart.chartArea,{property:u,start:f,end:m}=i||{};u==="x"&&(r.beginPath(),r.rect(f,o,m-f,l-o),r.clip())}function ph(r,n,i,o){const l=n.interpolate(i,o);l&&r.lineTo(l.x,l.y)}function mh(r,n){const{line:i,target:o,property:l,color:u,scale:f}=n,m=Kg(i,o,l);for(const{source:x,target:y,start:w,end:A}of m){const{style:{backgroundColor:R=u}={}}=x,O=o!==!0;r.save(),r.fillStyle=R,Qg(r,f,O&&ja(l,w,A)),r.beginPath();const U=!!i.pathSegment(r,x);let H;if(O){U?r.closePath():ph(r,o,A,l);const q=!!o.pathSegment(r,y,{move:U,reverse:!0});H=U&&q,H||ph(r,o,w,l)}r.closePath(),r.fill(H?"evenodd":"nonzero"),r.restore()}}function tx(r,n){const{line:i,target:o,above:l,below:u,area:f,scale:m}=n,x=i._loop?"angle":n.axis;r.save(),x==="x"&&u!==l&&(dh(r,o,f.top),mh(r,{line:i,target:o,color:l,scale:m,property:x}),r.restore(),r.save(),dh(r,o,f.bottom)),mh(r,{line:i,target:o,color:u,scale:m,property:x}),r.restore()}function qa(r,n,i){const o=Zg(n),{line:l,scale:u,axis:f}=n,m=l.options,x=m.fill,y=m.backgroundColor,{above:w=y,below:A=y}=x||{};o&&l.points.length&&(Fs(r,i),tx(r,{line:l,target:o,above:w,below:A,area:i,scale:u,axis:f}),ks(r))}var ex={id:"filler",afterDatasetsUpdate(r,n,i){const o=(r.data.datasets||[]).length,l=[];let u,f,m,x;for(f=0;f<o;++f)u=r.getDatasetMeta(f),m=u.dataset,x=null,m&&m.options&&m instanceof ti&&(x={visible:r.isDatasetVisible(f),index:f,fill:Vg(m,f,o),chart:r,axis:u.controller.options.indexAxis,scale:u.vScale,line:m}),u.$filler=x,l.push(x);for(f=0;f<o;++f)x=l[f],!(!x||x.fill===!1)&&(x.fill=Jg(l,f,i.propagate))},beforeDraw(r,n,i){const o=i.drawTime==="beforeDraw",l=r.getSortedVisibleDatasetMetas(),u=r.chartArea;for(let f=l.length-1;f>=0;--f){const m=l[f].$filler;!m||(m.line.updateControlPoints(u,m.axis),o&&qa(r.ctx,m,u))}},beforeDatasetsDraw(r,n,i){if(i.drawTime!=="beforeDatasetsDraw")return;const o=r.getSortedVisibleDatasetMetas();for(let l=o.length-1;l>=0;--l){const u=o[l].$filler;u&&qa(r.ctx,u,r.chartArea)}},beforeDatasetDraw(r,n,i){const o=n.meta.$filler;!o||o.fill===!1||i.drawTime!=="beforeDatasetDraw"||qa(r.ctx,o,r.chartArea)},defaults:{propagate:!0,drawTime:"beforeDatasetDraw"}};const gh=(r,n)=>{let{boxHeight:i=n,boxWidth:o=n}=r;return r.usePointStyle&&(i=Math.min(i,n),o=Math.min(o,n)),{boxWidth:o,boxHeight:i,itemHeight:Math.max(n,i)}},nx=(r,n)=>r!==null&&n!==null&&r.datasetIndex===n.datasetIndex&&r.index===n.index;class xh extends gn{constructor(n){super();this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=n.chart,this.options=n.options,this.ctx=n.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(n,i,o){const l=this;l.maxWidth=n,l.maxHeight=i,l._margins=o,l.setDimensions(),l.buildLabels(),l.fit()}setDimensions(){const n=this;n.isHorizontal()?(n.width=n.maxWidth,n.left=n._margins.left,n.right=n.width):(n.height=n.maxHeight,n.top=n._margins.top,n.bottom=n.height)}buildLabels(){const n=this,i=n.options.labels||{};let o=nt(i.generateLabels,[n.chart],n)||[];i.filter&&(o=o.filter(l=>i.filter(l,n.chart.data))),i.sort&&(o=o.sort((l,u)=>i.sort(l,u,n.chart.data))),n.options.reverse&&o.reverse(),n.legendItems=o}fit(){const n=this,{options:i,ctx:o}=n;if(!i.display){n.width=n.height=0;return}const l=i.labels,u=Ce(l.font),f=u.size,m=n._computeTitleHeight(),{boxWidth:x,itemHeight:y}=gh(l,f);let w,A;o.font=u.string,n.isHorizontal()?(w=n.maxWidth,A=n._fitRows(m,f,x,y)+10):(A=n.maxHeight,w=n._fitCols(m,f,x,y)+10),n.width=Math.min(w,i.maxWidth||n.maxWidth),n.height=Math.min(A,i.maxHeight||n.maxHeight)}_fitRows(n,i,o,l){const u=this,{ctx:f,maxWidth:m,options:{labels:{padding:x}}}=u,y=u.legendHitBoxes=[],w=u.lineWidths=[0],A=l+x;let R=n;f.textAlign="left",f.textBaseline="middle";let O=-1,U=-A;return u.legendItems.forEach((H,q)=>{const Z=o+i/2+f.measureText(H.text).width;(q===0||w[w.length-1]+Z+2*x>m)&&(R+=A,w[w.length-(q>0?0:1)]=0,U+=A,O++),y[q]={left:0,top:U,row:O,width:Z,height:l},w[w.length-1]+=Z+x}),R}_fitCols(n,i,o,l){const u=this,{ctx:f,maxHeight:m,options:{labels:{padding:x}}}=u,y=u.legendHitBoxes=[],w=u.columnSizes=[],A=m-n;let R=x,O=0,U=0,H=0,q=0;return u.legendItems.forEach((Z,ct)=>{const Tt=o+i/2+f.measureText(Z.text).width;ct>0&&U+l+2*x>A&&(R+=O+x,w.push({width:O,height:U}),H+=O+x,q++,O=U=0),y[ct]={left:H,top:U,col:q,width:Tt,height:l},O=Math.max(O,Tt),U+=l+x}),R+=O,w.push({width:O,height:U}),R}adjustHitBoxes(){const n=this;if(!n.options.display)return;const i=n._computeTitleHeight(),{legendHitBoxes:o,options:{align:l,labels:{padding:u},rtl:f}}=n,m=wi(f,n.left,n.width);if(this.isHorizontal()){let x=0,y=p(l,n.left+u,n.right-n.lineWidths[x]);for(const w of o)x!==w.row&&(x=w.row,y=p(l,n.left+u,n.right-n.lineWidths[x])),w.top+=n.top+i+u,w.left=m.leftForLtr(m.x(y),w.width),y+=w.width+u}else{let x=0,y=p(l,n.top+i+u,n.bottom-n.columnSizes[x].height);for(const w of o)w.col!==x&&(x=w.col,y=p(l,n.top+i+u,n.bottom-n.columnSizes[x].height)),w.top=y,w.left+=n.left+u,w.left=m.leftForLtr(m.x(w.left),w.width),y+=w.height+u}}isHorizontal(){return this.options.position==="top"||this.options.position==="bottom"}draw(){const n=this;if(n.options.display){const i=n.ctx;Fs(i,n),n._draw(),ks(i)}}_draw(){const n=this,{options:i,columnSizes:o,lineWidths:l,ctx:u}=n,{align:f,labels:m}=i,x=ie.color,y=wi(i.rtl,n.left,n.width),w=Ce(m.font),{color:A,padding:R}=m,O=w.size,U=O/2;let H;n.drawTitle(),u.textAlign=y.textAlign("left"),u.textBaseline="middle",u.lineWidth=.5,u.font=w.string;const{boxWidth:q,boxHeight:Z,itemHeight:ct}=gh(m,O),Tt=function(zt,Kt,he){if(isNaN(q)||q<=0||isNaN(Z)||Z<0)return;u.save();const ae=ft(he.lineWidth,1);if(u.fillStyle=ft(he.fillStyle,x),u.lineCap=ft(he.lineCap,"butt"),u.lineDashOffset=ft(he.lineDashOffset,0),u.lineJoin=ft(he.lineJoin,"miter"),u.lineWidth=ae,u.strokeStyle=ft(he.strokeStyle,x),u.setLineDash(ft(he.lineDash,[])),m.usePointStyle){const Se={radius:q*Math.SQRT2/2,pointStyle:he.pointStyle,rotation:he.rotation,borderWidth:ae},le=y.xPlus(zt,q/2),Re=Kt+U;Is(u,Se,le,Re)}else{const Se=Kt+Math.max((O-Z)/2,0),le=y.leftForLtr(zt,q),Re=zr(he.borderRadius);u.beginPath(),Object.values(Re).some(Ke=>Ke!==0)?Os(u,{x:le,y:Se,w:q,h:Z,radius:Re}):u.rect(le,Se,q,Z),u.fill(),ae!==0&&u.stroke()}u.restore()},wt=function(zt,Kt,he){Zn(u,he.text,zt,Kt+ct/2,w,{strikethrough:he.hidden,textAlign:y.textAlign(he.textAlign)})},yt=n.isHorizontal(),Dt=this._computeTitleHeight();yt?H={x:p(f,n.left+R,n.right-l[0]),y:n.top+R+Dt,line:0}:H={x:n.left+R,y:p(f,n.top+Dt+R,n.bottom-o[0].height),line:0},Aa(n.ctx,i.textDirection);const Ut=ct+R;n.legendItems.forEach((zt,Kt)=>{u.strokeStyle=zt.fontColor||A,u.fillStyle=zt.fontColor||A;const he=u.measureText(zt.text).width,ae=y.textAlign(zt.textAlign||(zt.textAlign=m.textAlign)),Se=q+U+he;let le=H.x,Re=H.y;y.setWidth(n.width),yt?Kt>0&&le+Se+R>n.right&&(Re=H.y+=Ut,H.line++,le=H.x=p(f,n.left+R,n.right-l[H.line])):Kt>0&&Re+Ut>n.bottom&&(le=H.x=le+o[H.line].width+R,H.line++,Re=H.y=p(f,n.top+Dt+R,n.bottom-o[H.line].height));const Ke=y.x(le);Tt(Ke,Re,zt),le=g(ae,le+q+U,yt?le+Se:n.right,i.rtl),wt(y.x(le),Re,zt),yt?H.x+=Se+R:H.y+=Ut}),La(n.ctx,i.textDirection)}drawTitle(){const n=this,i=n.options,o=i.title,l=Ce(o.font),u=je(o.padding);if(!o.display)return;const f=wi(i.rtl,n.left,n.width),m=n.ctx,x=o.position,y=l.size/2,w=u.top+y;let A,R=n.left,O=n.width;if(this.isHorizontal())O=Math.max(...n.lineWidths),A=n.top+w,R=p(i.align,R,n.right-O);else{const H=n.columnSizes.reduce((q,Z)=>Math.max(q,Z.height),0);A=w+p(i.align,n.top,n.bottom-H-i.labels.padding-n._computeTitleHeight())}const U=p(x,R,R+O);m.textAlign=f.textAlign(d(x)),m.textBaseline="middle",m.strokeStyle=o.color,m.fillStyle=o.color,m.font=l.string,Zn(m,o.text,U,A,l)}_computeTitleHeight(){const n=this.options.title,i=Ce(n.font),o=je(n.padding);return n.display?i.lineHeight+o.height:0}_getLegendItemAt(n,i){const o=this;let l,u,f;if(n>=o.left&&n<=o.right&&i>=o.top&&i<=o.bottom){for(f=o.legendHitBoxes,l=0;l<f.length;++l)if(u=f[l],n>=u.left&&n<=u.left+u.width&&i>=u.top&&i<=u.top+u.height)return o.legendItems[l]}return null}handleEvent(n){const i=this,o=i.options;if(!ix(n.type,o))return;const l=i._getLegendItemAt(n.x,n.y);if(n.type==="mousemove"){const u=i._hoveredItem,f=nx(u,l);u&&!f&&nt(o.onLeave,[n,u,i],i),i._hoveredItem=l,l&&!f&&nt(o.onHover,[n,l,i],i)}else l&&nt(o.onClick,[n,l,i],i)}}function ix(r,n){return!!(r==="mousemove"&&(n.onHover||n.onLeave)||n.onClick&&(r==="click"||r==="mouseup"))}var sx={id:"legend",_element:xh,start(r,n,i){const o=r.legend=new xh({ctx:r.ctx,options:i,chart:r});He.configure(r,o,i),He.addBox(r,o)},stop(r){He.removeBox(r,r.legend),delete r.legend},beforeUpdate(r,n,i){const o=r.legend;He.configure(r,o,i),o.options=i},afterUpdate(r){const n=r.legend;n.buildLabels(),n.adjustHitBoxes()},afterEvent(r,n){n.replay||r.legend.handleEvent(n.event)},defaults:{display:!0,position:"top",align:"center",fullSize:!0,reverse:!1,weight:1e3,onClick(r,n,i){const o=n.datasetIndex,l=i.chart;l.isDatasetVisible(o)?(l.hide(o),n.hidden=!0):(l.show(o),n.hidden=!1)},onHover:null,onLeave:null,labels:{color:r=>r.chart.options.color,boxWidth:40,padding:10,generateLabels(r){const n=r.data.datasets,{labels:{usePointStyle:i,pointStyle:o,textAlign:l,color:u}}=r.legend.options;return r._getSortedDatasetMetas().map(f=>{const m=f.controller.getStyle(i?0:void 0),x=je(m.borderWidth);return{text:n[f.index].label,fillStyle:m.backgroundColor,fontColor:u,hidden:!f.visible,lineCap:m.borderCapStyle,lineDash:m.borderDash,lineDashOffset:m.borderDashOffset,lineJoin:m.borderJoinStyle,lineWidth:(x.width+x.height)/4,strokeStyle:m.borderColor,pointStyle:o||m.pointStyle,rotation:m.rotation,textAlign:l||m.textAlign,borderRadius:0,datasetIndex:f.index}},this)}},title:{color:r=>r.chart.options.color,display:!1,position:"center",text:""}},descriptors:{_scriptable:r=>!r.startsWith("on"),labels:{_scriptable:r=>!["generateLabels","filter","sort"].includes(r)}}};class Ya extends gn{constructor(n){super();this.chart=n.chart,this.options=n.options,this.ctx=n.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(n,i){const o=this,l=o.options;if(o.left=0,o.top=0,!l.display){o.width=o.height=o.right=o.bottom=0;return}o.width=o.right=n,o.height=o.bottom=i;const u=gt(l.text)?l.text.length:1;o._padding=je(l.padding);const f=u*Ce(l.font).lineHeight+o._padding.height;o.isHorizontal()?o.height=f:o.width=f}isHorizontal(){const n=this.options.position;return n==="top"||n==="bottom"}_drawArgs(n){const{top:i,left:o,bottom:l,right:u,options:f}=this,m=f.align;let x=0,y,w,A;return this.isHorizontal()?(w=p(m,o,u),A=i+n,y=u-o):(f.position==="left"?(w=o+n,A=p(m,l,i),x=ye*-.5):(w=u-n,A=p(m,i,l),x=ye*.5),y=l-i),{titleX:w,titleY:A,maxWidth:y,rotation:x}}draw(){const n=this,i=n.ctx,o=n.options;if(!o.display)return;const l=Ce(o.font),f=l.lineHeight/2+n._padding.top,{titleX:m,titleY:x,maxWidth:y,rotation:w}=n._drawArgs(f);Zn(i,o.text,0,0,l,{color:o.color,maxWidth:y,rotation:w,textAlign:d(o.align),textBaseline:"middle",translation:[m,x]})}}function rx(r,n){const i=new Ya({ctx:r.ctx,options:n,chart:r});He.configure(r,i,n),He.addBox(r,i),r.titleBlock=i}var ox={id:"title",_element:Ya,start(r,n,i){rx(r,i)},stop(r){const n=r.titleBlock;He.removeBox(r,n),delete r.titleBlock},beforeUpdate(r,n,i){const o=r.titleBlock;He.configure(r,o,i),o.options=i},defaults:{align:"center",display:!1,font:{weight:"bold"},fullSize:!0,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};const no=new WeakMap;var ax={id:"subtitle",start(r,n,i){const o=new Ya({ctx:r.ctx,options:i,chart:r});He.configure(r,o,i),He.addBox(r,o),no.set(r,o)},stop(r){He.removeBox(r,no.get(r)),no.delete(r)},beforeUpdate(r,n,i){const o=no.get(r);He.configure(r,o,i),o.options=i},defaults:{align:"center",display:!1,font:{weight:"normal"},fullSize:!0,padding:0,position:"top",text:"",weight:1500},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};const qs={average(r){if(!r.length)return!1;let n,i,o=0,l=0,u=0;for(n=0,i=r.length;n<i;++n){const f=r[n].element;if(f&&f.hasValue()){const m=f.tooltipPosition();o+=m.x,l+=m.y,++u}}return{x:o/u,y:l/u}},nearest(r,n){if(!r.length)return!1;let i=n.x,o=n.y,l=Number.POSITIVE_INFINITY,u,f,m;for(u=0,f=r.length;u<f;++u){const x=r[u].element;if(x&&x.hasValue()){const y=x.getCenterPoint(),w=Cn(n,y);w<l&&(l=w,m=x)}}if(m){const x=m.tooltipPosition();i=x.x,o=x.y}return{x:i,y:o}}};function Dn(r,n){return n&&(gt(n)?Array.prototype.push.apply(r,n):r.push(n)),r}function Vn(r){return(typeof r=="string"||r instanceof String)&&r.indexOf(`
`)>-1?r.split(`
`):r}function lx(r,n){const{element:i,datasetIndex:o,index:l}=n,u=r.getDatasetMeta(o).controller,{label:f,value:m}=u.getLabelAndValue(l);return{chart:r,label:f,parsed:u.getParsed(l),raw:r.data.datasets[o].data[l],formattedValue:m,dataset:u.getDataset(),dataIndex:l,datasetIndex:o,element:i}}function _h(r,n){const i=r._chart.ctx,{body:o,footer:l,title:u}=r,{boxWidth:f,boxHeight:m}=n,x=Ce(n.bodyFont),y=Ce(n.titleFont),w=Ce(n.footerFont),A=u.length,R=l.length,O=o.length,U=je(n.padding);let H=U.height,q=0,Z=o.reduce((wt,yt)=>wt+yt.before.length+yt.lines.length+yt.after.length,0);if(Z+=r.beforeBody.length+r.afterBody.length,A&&(H+=A*y.lineHeight+(A-1)*n.titleSpacing+n.titleMarginBottom),Z){const wt=n.displayColors?Math.max(m,x.lineHeight):x.lineHeight;H+=O*wt+(Z-O)*x.lineHeight+(Z-1)*n.bodySpacing}R&&(H+=n.footerMarginTop+R*w.lineHeight+(R-1)*n.footerSpacing);let ct=0;const Tt=function(wt){q=Math.max(q,i.measureText(wt).width+ct)};return i.save(),i.font=y.string,mt(r.title,Tt),i.font=x.string,mt(r.beforeBody.concat(r.afterBody),Tt),ct=n.displayColors?f+2:0,mt(o,wt=>{mt(wt.before,Tt),mt(wt.lines,Tt),mt(wt.after,Tt)}),ct=0,i.font=w.string,mt(r.footer,Tt),i.restore(),q+=U.width,{width:q,height:H}}function cx(r,n){const{y:i,height:o}=n;return i<o/2?"top":i>r.height-o/2?"bottom":"center"}function ux(r,n,i,o){const{x:l,width:u}=o,f=i.caretSize+i.caretPadding;if(r==="left"&&l+u+f>n.width||r==="right"&&l-u-f<0)return!0}function hx(r,n,i,o){const{x:l,width:u}=i,{width:f,chartArea:{left:m,right:x}}=r;let y="center";return o==="center"?y=l<=(m+x)/2?"left":"right":l<=u/2?y="left":l>=f-u/2&&(y="right"),ux(y,r,n,i)&&(y="center"),y}function yh(r,n,i){const o=n.yAlign||cx(r,i);return{xAlign:n.xAlign||hx(r,n,i,o),yAlign:o}}function dx(r,n){let{x:i,width:o}=r;return n==="right"?i-=o:n==="center"&&(i-=o/2),i}function fx(r,n,i){let{y:o,height:l}=r;return n==="top"?o+=i:n==="bottom"?o-=l+i:o-=l/2,o}function vh(r,n,i,o){const{caretSize:l,caretPadding:u,cornerRadius:f}=r,{xAlign:m,yAlign:x}=i,y=l+u,w=f+u;let A=dx(n,m);const R=fx(n,x,y);return x==="center"?m==="left"?A+=y:m==="right"&&(A-=y):m==="left"?A-=w:m==="right"&&(A+=w),{x:Fe(A,0,o.width-n.width),y:Fe(R,0,o.height-n.height)}}function io(r,n,i){const o=je(i.padding);return n==="center"?r.x+r.width/2:n==="right"?r.x+r.width-o.right:r.x+o.left}function bh(r){return Dn([],Vn(r))}function px(r,n,i){return Object.assign(Object.create(r),{tooltip:n,tooltipItems:i,type:"tooltip"})}function Mh(r,n){const i=n&&n.dataset&&n.dataset.tooltip&&n.dataset.tooltip.callbacks;return i?r.override(i):r}class $a extends gn{constructor(n){super();this.opacity=0,this._active=[],this._chart=n._chart,this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.options=n.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(n){this.options=n,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const n=this,i=n._cachedAnimations;if(i)return i;const o=n._chart,l=n.options.setContext(n.getContext()),u=l.enabled&&o.options.animation&&l.animations,f=new Ia(n._chart,u);return u._cacheable&&(n._cachedAnimations=Object.freeze(f)),f}getContext(){const n=this;return n.$context||(n.$context=px(n._chart.getContext(),n,n._tooltipItems))}getTitle(n,i){const o=this,{callbacks:l}=i,u=l.beforeTitle.apply(o,[n]),f=l.title.apply(o,[n]),m=l.afterTitle.apply(o,[n]);let x=[];return x=Dn(x,Vn(u)),x=Dn(x,Vn(f)),x=Dn(x,Vn(m)),x}getBeforeBody(n,i){return bh(i.callbacks.beforeBody.apply(this,[n]))}getBody(n,i){const o=this,{callbacks:l}=i,u=[];return mt(n,f=>{const m={before:[],lines:[],after:[]},x=Mh(l,f);Dn(m.before,Vn(x.beforeLabel.call(o,f))),Dn(m.lines,x.label.call(o,f)),Dn(m.after,Vn(x.afterLabel.call(o,f))),u.push(m)}),u}getAfterBody(n,i){return bh(i.callbacks.afterBody.apply(this,[n]))}getFooter(n,i){const o=this,{callbacks:l}=i,u=l.beforeFooter.apply(o,[n]),f=l.footer.apply(o,[n]),m=l.afterFooter.apply(o,[n]);let x=[];return x=Dn(x,Vn(u)),x=Dn(x,Vn(f)),x=Dn(x,Vn(m)),x}_createItems(n){const i=this,o=i._active,l=i._chart.data,u=[],f=[],m=[];let x=[],y,w;for(y=0,w=o.length;y<w;++y)x.push(lx(i._chart,o[y]));return n.filter&&(x=x.filter((A,R,O)=>n.filter(A,R,O,l))),n.itemSort&&(x=x.sort((A,R)=>n.itemSort(A,R,l))),mt(x,A=>{const R=Mh(n.callbacks,A);u.push(R.labelColor.call(i,A)),f.push(R.labelPointStyle.call(i,A)),m.push(R.labelTextColor.call(i,A))}),i.labelColors=u,i.labelPointStyles=f,i.labelTextColors=m,i.dataPoints=x,x}update(n,i){const o=this,l=o.options.setContext(o.getContext()),u=o._active;let f,m=[];if(!u.length)o.opacity!==0&&(f={opacity:0});else{const x=qs[l.position].call(o,u,o._eventPosition);m=o._createItems(l),o.title=o.getTitle(m,l),o.beforeBody=o.getBeforeBody(m,l),o.body=o.getBody(m,l),o.afterBody=o.getAfterBody(m,l),o.footer=o.getFooter(m,l);const y=o._size=_h(o,l),w=Object.assign({},x,y),A=yh(o._chart,l,w),R=vh(l,w,A,o._chart);o.xAlign=A.xAlign,o.yAlign=A.yAlign,f={opacity:1,x:R.x,y:R.y,width:y.width,height:y.height,caretX:x.x,caretY:x.y}}o._tooltipItems=m,o.$context=void 0,f&&o._resolveAnimations().update(o,f),n&&l.external&&l.external.call(o,{chart:o._chart,tooltip:o,replay:i})}drawCaret(n,i,o,l){const u=this.getCaretPosition(n,o,l);i.lineTo(u.x1,u.y1),i.lineTo(u.x2,u.y2),i.lineTo(u.x3,u.y3)}getCaretPosition(n,i,o){const{xAlign:l,yAlign:u}=this,{cornerRadius:f,caretSize:m}=o,{x,y}=n,{width:w,height:A}=i;let R,O,U,H,q,Z;return u==="center"?(q=y+A/2,l==="left"?(R=x,O=R-m,H=q+m,Z=q-m):(R=x+w,O=R+m,H=q-m,Z=q+m),U=R):(l==="left"?O=x+f+m:l==="right"?O=x+w-f-m:O=this.caretX,u==="top"?(H=y,q=H-m,R=O-m,U=O+m):(H=y+A,q=H+m,R=O+m,U=O-m),Z=H),{x1:R,x2:O,x3:U,y1:H,y2:q,y3:Z}}drawTitle(n,i,o){const l=this,u=l.title,f=u.length;let m,x,y;if(f){const w=wi(o.rtl,l.x,l.width);for(n.x=io(l,o.titleAlign,o),i.textAlign=w.textAlign(o.titleAlign),i.textBaseline="middle",m=Ce(o.titleFont),x=o.titleSpacing,i.fillStyle=o.titleColor,i.font=m.string,y=0;y<f;++y)i.fillText(u[y],w.x(n.x),n.y+m.lineHeight/2),n.y+=m.lineHeight+x,y+1===f&&(n.y+=o.titleMarginBottom-x)}}_drawColorBox(n,i,o,l,u){const f=this,m=f.labelColors[o],x=f.labelPointStyles[o],{boxHeight:y,boxWidth:w}=u,A=Ce(u.bodyFont),R=io(f,"left",u),O=l.x(R),U=y<A.lineHeight?(A.lineHeight-y)/2:0,H=i.y+U;if(u.usePointStyle){const q={radius:Math.min(w,y)/2,pointStyle:x.pointStyle,rotation:x.rotation,borderWidth:1},Z=l.leftForLtr(O,w)+w/2,ct=H+y/2;n.strokeStyle=u.multiKeyBackground,n.fillStyle=u.multiKeyBackground,Is(n,q,Z,ct),n.strokeStyle=m.borderColor,n.fillStyle=m.backgroundColor,Is(n,q,Z,ct)}else{n.lineWidth=m.borderWidth||1,n.strokeStyle=m.borderColor,n.setLineDash(m.borderDash||[]),n.lineDashOffset=m.borderDashOffset||0;const q=l.leftForLtr(O,w),Z=l.leftForLtr(l.xPlus(O,1),w-2),ct=zr(m.borderRadius);Object.values(ct).some(Tt=>Tt!==0)?(n.beginPath(),n.fillStyle=u.multiKeyBackground,Os(n,{x:q,y:H,w,h:y,radius:ct}),n.fill(),n.stroke(),n.fillStyle=m.backgroundColor,n.beginPath(),Os(n,{x:Z,y:H+1,w:w-2,h:y-2,radius:ct}),n.fill()):(n.fillStyle=u.multiKeyBackground,n.fillRect(q,H,w,y),n.strokeRect(q,H,w,y),n.fillStyle=m.backgroundColor,n.fillRect(Z,H+1,w-2,y-2))}n.fillStyle=f.labelTextColors[o]}drawBody(n,i,o){const l=this,{body:u}=l,{bodySpacing:f,bodyAlign:m,displayColors:x,boxHeight:y,boxWidth:w}=o,A=Ce(o.bodyFont);let R=A.lineHeight,O=0;const U=wi(o.rtl,l.x,l.width),H=function(zt){i.fillText(zt,U.x(n.x+O),n.y+R/2),n.y+=R+f},q=U.textAlign(m);let Z,ct,Tt,wt,yt,Dt,Ut;for(i.textAlign=m,i.textBaseline="middle",i.font=A.string,n.x=io(l,q,o),i.fillStyle=o.bodyColor,mt(l.beforeBody,H),O=x&&q!=="right"?m==="center"?w/2+1:w+2:0,wt=0,Dt=u.length;wt<Dt;++wt){for(Z=u[wt],ct=l.labelTextColors[wt],i.fillStyle=ct,mt(Z.before,H),Tt=Z.lines,x&&Tt.length&&(l._drawColorBox(i,n,wt,U,o),R=Math.max(A.lineHeight,y)),yt=0,Ut=Tt.length;yt<Ut;++yt)H(Tt[yt]),R=A.lineHeight;mt(Z.after,H)}O=0,R=A.lineHeight,mt(l.afterBody,H),n.y-=f}drawFooter(n,i,o){const l=this,u=l.footer,f=u.length;let m,x;if(f){const y=wi(o.rtl,l.x,l.width);for(n.x=io(l,o.footerAlign,o),n.y+=o.footerMarginTop,i.textAlign=y.textAlign(o.footerAlign),i.textBaseline="middle",m=Ce(o.footerFont),i.fillStyle=o.footerColor,i.font=m.string,x=0;x<f;++x)i.fillText(u[x],y.x(n.x),n.y+m.lineHeight/2),n.y+=m.lineHeight+o.footerSpacing}}drawBackground(n,i,o,l){const{xAlign:u,yAlign:f}=this,{x:m,y:x}=n,{width:y,height:w}=o,A=l.cornerRadius;i.fillStyle=l.backgroundColor,i.strokeStyle=l.borderColor,i.lineWidth=l.borderWidth,i.beginPath(),i.moveTo(m+A,x),f==="top"&&this.drawCaret(n,i,o,l),i.lineTo(m+y-A,x),i.quadraticCurveTo(m+y,x,m+y,x+A),f==="center"&&u==="right"&&this.drawCaret(n,i,o,l),i.lineTo(m+y,x+w-A),i.quadraticCurveTo(m+y,x+w,m+y-A,x+w),f==="bottom"&&this.drawCaret(n,i,o,l),i.lineTo(m+A,x+w),i.quadraticCurveTo(m,x+w,m,x+w-A),f==="center"&&u==="left"&&this.drawCaret(n,i,o,l),i.lineTo(m,x+A),i.quadraticCurveTo(m,x,m+A,x),i.closePath(),i.fill(),l.borderWidth>0&&i.stroke()}_updateAnimationTarget(n){const i=this,o=i._chart,l=i.$animations,u=l&&l.x,f=l&&l.y;if(u||f){const m=qs[n.position].call(i,i._active,i._eventPosition);if(!m)return;const x=i._size=_h(i,n),y=Object.assign({},m,i._size),w=yh(o,n,y),A=vh(n,y,w,o);(u._to!==A.x||f._to!==A.y)&&(i.xAlign=w.xAlign,i.yAlign=w.yAlign,i.width=x.width,i.height=x.height,i.caretX=m.x,i.caretY=m.y,i._resolveAnimations().update(i,A))}}draw(n){const i=this,o=i.options.setContext(i.getContext());let l=i.opacity;if(!l)return;i._updateAnimationTarget(o);const u={width:i.width,height:i.height},f={x:i.x,y:i.y};l=Math.abs(l)<.001?0:l;const m=je(o.padding),x=i.title.length||i.beforeBody.length||i.body.length||i.afterBody.length||i.footer.length;o.enabled&&x&&(n.save(),n.globalAlpha=l,i.drawBackground(f,n,u,o),Aa(n,o.textDirection),f.y+=m.top,i.drawTitle(f,n,o),i.drawBody(f,n,o),i.drawFooter(f,n,o),La(n,o.textDirection),n.restore())}getActiveElements(){return this._active||[]}setActiveElements(n,i){const o=this,l=o._active,u=n.map(({datasetIndex:x,index:y})=>{const w=o._chart.getDatasetMeta(x);if(!w)throw new Error("Cannot find a dataset at index "+x);return{datasetIndex:x,element:w.data[y],index:y}}),f=!kt(l,u),m=o._positionChanged(u,i);(f||m)&&(o._active=u,o._eventPosition=i,o.update(!0))}handleEvent(n,i){const o=this,l=o.options,u=o._active||[];let f=!1,m=[];n.type!=="mouseout"&&(m=o._chart.getElementsAtEventForMode(n,l.mode,l,i),l.reverse&&m.reverse());const x=o._positionChanged(m,n);return f=i||!kt(m,u)||x,f&&(o._active=m,(l.enabled||l.external)&&(o._eventPosition={x:n.x,y:n.y},o.update(!0,i))),f}_positionChanged(n,i){const{caretX:o,caretY:l,options:u}=this,f=qs[u.position].call(this,n,i);return f!==!1&&(o!==f.x||l!==f.y)}}$a.positioners=qs;var mx={id:"tooltip",_element:$a,positioners:qs,afterInit(r,n,i){i&&(r.tooltip=new $a({_chart:r,options:i}))},beforeUpdate(r,n,i){r.tooltip&&r.tooltip.initialize(i)},reset(r,n,i){r.tooltip&&r.tooltip.initialize(i)},afterDraw(r){const n=r.tooltip,i={tooltip:n};r.notifyPlugins("beforeTooltipDraw",i)!==!1&&(n&&n.draw(r.ctx),r.notifyPlugins("afterTooltipDraw",i))},afterEvent(r,n){if(r.tooltip){const i=n.replay;r.tooltip.handleEvent(n.event,i)&&(n.changed=!0)}},defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(r,n)=>n.bodyFont.size,boxWidth:(r,n)=>n.bodyFont.size,multiKeyBackground:"#fff",displayColors:!0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:{beforeTitle:et,title(r){if(r.length>0){const n=r[0],i=n.chart.data.labels,o=i?i.length:0;if(this&&this.options&&this.options.mode==="dataset")return n.dataset.label||"";if(n.label)return n.label;if(o>0&&n.dataIndex<o)return i[n.dataIndex]}return""},afterTitle:et,beforeBody:et,beforeLabel:et,label(r){if(this&&this.options&&this.options.mode==="dataset")return r.label+": "+r.formattedValue||r.formattedValue;let n=r.dataset.label||"";n&&(n+=": ");const i=r.formattedValue;return at(i)||(n+=i),n},labelColor(r){const i=r.chart.getDatasetMeta(r.datasetIndex).controller.getStyle(r.dataIndex);return{borderColor:i.borderColor,backgroundColor:i.backgroundColor,borderWidth:i.borderWidth,borderDash:i.borderDash,borderDashOffset:i.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(r){const i=r.chart.getDatasetMeta(r.datasetIndex).controller.getStyle(r.dataIndex);return{pointStyle:i.pointStyle,rotation:i.rotation}},afterLabel:et,afterBody:et,beforeFooter:et,footer:et,afterFooter:et}},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:r=>r!=="filter"&&r!=="itemSort"&&r!=="external",_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]},wh=Object.freeze({__proto__:null,Decimation:Bg,Filler:ex,Legend:sx,SubTitle:ax,Title:ox,Tooltip:mx});const gx=(r,n,i)=>typeof n=="string"?r.push(n)-1:isNaN(n)?null:i;function xx(r,n,i){const o=r.indexOf(n);if(o===-1)return gx(r,n,i);const l=r.lastIndexOf(n);return o!==l?i:o}const _x=(r,n)=>r===null?null:Fe(Math.round(r),0,n);class so extends Kn{constructor(n){super(n);this._startValue=void 0,this._valueRange=0}parse(n,i){if(at(n))return null;const o=this.getLabels();return i=isFinite(i)&&o[i]===n?i:xx(o,n,ft(i,n)),_x(i,o.length-1)}determineDataLimits(){const n=this,{minDefined:i,maxDefined:o}=n.getUserBounds();let{min:l,max:u}=n.getMinMax(!0);n.options.bounds==="ticks"&&(i||(l=0),o||(u=n.getLabels().length-1)),n.min=l,n.max=u}buildTicks(){const n=this,i=n.min,o=n.max,l=n.options.offset,u=[];let f=n.getLabels();f=i===0&&o===f.length-1?f:f.slice(i,o+1),n._valueRange=Math.max(f.length-(l?0:1),1),n._startValue=n.min-(l?.5:0);for(let m=i;m<=o;m++)u.push({value:m});return u}getLabelForValue(n){const o=this.getLabels();return n>=0&&n<o.length?o[n]:n}configure(){const n=this;super.configure(),n.isHorizontal()||(n._reversePixels=!n._reversePixels)}getPixelForValue(n){const i=this;return typeof n!="number"&&(n=i.parse(n)),n===null?NaN:i.getPixelForDecimal((n-i._startValue)/i._valueRange)}getPixelForTick(n){const i=this,o=i.ticks;return n<0||n>o.length-1?null:i.getPixelForValue(o[n].value)}getValueForPixel(n){const i=this;return Math.round(i._startValue+i.getDecimalForPixel(n)*i._valueRange)}getBasePixel(){return this.bottom}}so.id="category",so.defaults={ticks:{callback:so.prototype.getLabelForValue}};function yx(r,n){const i=[],o=1e-14,{bounds:l,step:u,min:f,max:m,precision:x,count:y,maxTicks:w,maxDigits:A,includeBounds:R}=r,O=u||1,U=w-1,{min:H,max:q}=n,Z=!at(f),ct=!at(m),Tt=!at(y),wt=(q-H)/(A+1);let yt=ce((q-H)/U/O)*O,Dt,Ut,zt,Kt;if(yt<o&&!Z&&!ct)return[{value:H},{value:q}];Kt=Math.ceil(q/yt)-Math.floor(H/yt),Kt>U&&(yt=ce(Kt*yt/U/O)*O),at(x)||(Dt=Math.pow(10,x),yt=Math.ceil(yt*Dt)/Dt),l==="ticks"?(Ut=Math.floor(H/yt)*yt,zt=Math.ceil(q/yt)*yt):(Ut=H,zt=q),Z&&ct&&u&&oe((m-f)/u,yt/1e3)?(Kt=Math.round(Math.min((m-f)/yt,w)),yt=(m-f)/Kt,Ut=f,zt=m):Tt?(Ut=Z?f:Ut,zt=ct?m:zt,Kt=y-1,yt=(zt-Ut)/Kt):(Kt=(zt-Ut)/yt,fe(Kt,Math.round(Kt),yt/1e3)?Kt=Math.round(Kt):Kt=Math.ceil(Kt));const he=Math.max(qn(yt),qn(Ut));Dt=Math.pow(10,at(x)?he:x),Ut=Math.round(Ut*Dt)/Dt,zt=Math.round(zt*Dt)/Dt;let ae=0;for(Z&&(R&&Ut!==f?(i.push({value:f}),Ut<f&&ae++,fe(Math.round((Ut+ae*yt)*Dt)/Dt,f,Sh(f,wt,r))&&ae++):Ut<f&&ae++);ae<Kt;++ae)i.push({value:Math.round((Ut+ae*yt)*Dt)/Dt});return ct&&R&&zt!==m?fe(i[i.length-1].value,m,Sh(m,wt,r))?i[i.length-1].value=m:i.push({value:m}):(!ct||zt===m)&&i.push({value:zt}),i}function Sh(r,n,{horizontal:i,minRotation:o}){const l=ue(o),u=(i?Math.sin(l):Math.cos(l))||.001,f=.75*n*(""+r).length;return Math.min(n/u,f)}class ro extends Kn{constructor(n){super(n);this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(n,i){return at(n)||(typeof n=="number"||n instanceof Number)&&!isFinite(+n)?null:+n}handleTickRangeOptions(){const n=this,{beginAtZero:i}=n.options,{minDefined:o,maxDefined:l}=n.getUserBounds();let{min:u,max:f}=n;const m=y=>u=o?u:y,x=y=>f=l?f:y;if(i){const y=Yt(u),w=Yt(f);y<0&&w<0?x(0):y>0&&w>0&&m(0)}if(u===f){let y=1;(f>=Number.MAX_SAFE_INTEGER||u<=Number.MIN_SAFE_INTEGER)&&(y=Math.abs(f*.05)),x(f+y),i||m(u-y)}n.min=u,n.max=f}getTickLimit(){const n=this,i=n.options.ticks;let{maxTicksLimit:o,stepSize:l}=i,u;return l?u=Math.ceil(n.max/l)-Math.floor(n.min/l)+1:(u=n.computeTickLimit(),o=o||11),o&&(u=Math.min(o,u)),u}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const n=this,i=n.options,o=i.ticks;let l=n.getTickLimit();l=Math.max(2,l);const u={maxTicks:l,bounds:i.bounds,min:i.min,max:i.max,precision:o.precision,step:o.stepSize,count:o.count,maxDigits:n._maxDigits(),horizontal:n.isHorizontal(),minRotation:o.minRotation||0,includeBounds:o.includeBounds!==!1},f=n._range||n,m=yx(u,f);return i.bounds==="ticks"&&Ln(m,n,"value"),i.reverse?(m.reverse(),n.start=n.max,n.end=n.min):(n.start=n.min,n.end=n.max),m}configure(){const n=this,i=n.ticks;let o=n.min,l=n.max;if(super.configure(),n.options.offset&&i.length){const u=(l-o)/Math.max(i.length-1,1)/2;o-=u,l+=u}n._startValue=o,n._endValue=l,n._valueRange=l-o}getLabelForValue(n){return zi(n,this.chart.options.locale)}}class Za extends ro{determineDataLimits(){const n=this,{min:i,max:o}=n.getMinMax(!0);n.min=At(i)?i:0,n.max=At(o)?o:1,n.handleTickRangeOptions()}computeTickLimit(){const n=this,i=n.isHorizontal(),o=i?n.width:n.height,l=ue(n.options.ticks.minRotation),u=(i?Math.sin(l):Math.cos(l))||.001,f=n._resolveTickFontOptions(0);return Math.ceil(o/Math.min(40,f.lineHeight/u))}getPixelForValue(n){return n===null?NaN:this.getPixelForDecimal((n-this._startValue)/this._valueRange)}getValueForPixel(n){return this._startValue+this.getDecimalForPixel(n)*this._valueRange}}Za.id="linear",Za.defaults={ticks:{callback:Ws.formatters.numeric}};function Th(r){return r/Math.pow(10,Math.floor(Ot(r)))===1}function vx(r,n){const i=Math.floor(Ot(n.max)),o=Math.ceil(n.max/Math.pow(10,i)),l=[];let u=Vt(r.min,Math.pow(10,Math.floor(Ot(n.min)))),f=Math.floor(Ot(u)),m=Math.floor(u/Math.pow(10,f)),x=f<0?Math.pow(10,Math.abs(f)):1;do l.push({value:u,major:Th(u)}),++m,m===10&&(m=1,++f,x=f>=0?1:x),u=Math.round(m*Math.pow(10,f)*x)/x;while(f<i||f===i&&m<o);const y=Vt(r.max,u);return l.push({value:y,major:Th(u)}),l}class Ja extends Kn{constructor(n){super(n);this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}parse(n,i){const o=ro.prototype.parse.apply(this,[n,i]);if(o===0){this._zero=!0;return}return At(o)&&o>0?o:null}determineDataLimits(){const n=this,{min:i,max:o}=n.getMinMax(!0);n.min=At(i)?Math.max(0,i):null,n.max=At(o)?Math.max(0,o):null,n.options.beginAtZero&&(n._zero=!0),n.handleTickRangeOptions()}handleTickRangeOptions(){const n=this,{minDefined:i,maxDefined:o}=n.getUserBounds();let l=n.min,u=n.max;const f=y=>l=i?l:y,m=y=>u=o?u:y,x=(y,w)=>Math.pow(10,Math.floor(Ot(y))+w);l===u&&(l<=0?(f(1),m(10)):(f(x(l,-1)),m(x(u,1)))),l<=0&&f(x(u,-1)),u<=0&&m(x(l,1)),n._zero&&n.min!==n._suggestedMin&&l===x(n.min,0)&&f(x(l,-1)),n.min=l,n.max=u}buildTicks(){const n=this,i=n.options,o={min:n._userMin,max:n._userMax},l=vx(o,n);return i.bounds==="ticks"&&Ln(l,n,"value"),i.reverse?(l.reverse(),n.start=n.max,n.end=n.min):(n.start=n.min,n.end=n.max),l}getLabelForValue(n){return n===void 0?"0":zi(n,this.chart.options.locale)}configure(){const n=this,i=n.min;super.configure(),n._startValue=Ot(i),n._valueRange=Ot(n.max)-Ot(i)}getPixelForValue(n){const i=this;return(n===void 0||n===0)&&(n=i.min),n===null||isNaN(n)?NaN:i.getPixelForDecimal(n===i.min?0:(Ot(n)-i._startValue)/i._valueRange)}getValueForPixel(n){const i=this,o=i.getDecimalForPixel(n);return Math.pow(10,i._startValue+o*i._valueRange)}}Ja.id="logarithmic",Ja.defaults={ticks:{callback:Ws.formatters.logarithmic,major:{enabled:!0}}};function Ka(r){const n=r.ticks;if(n.display&&r.display){const i=je(n.backdropPadding);return ft(n.font&&n.font.size,ie.font.size)+i.height}return 0}function bx(r,n,i){return i=gt(i)?i:[i],{w:Dc(r,n.string,i),h:i.length*n.lineHeight}}function Eh(r,n,i,o,l){return r===o||r===l?{start:n-i/2,end:n+i/2}:r<o||r>l?{start:n-i,end:n}:{start:n,end:n+i}}function Mx(r){const n={l:0,r:r.width,t:0,b:r.height-r.paddingTop},i={},o=[],l=[],u=r.getLabels().length;for(let f=0;f<u;f++){const m=r.options.pointLabels.setContext(r.getPointLabelContext(f));l[f]=m.padding;const x=r.getPointPosition(f,r.drawingArea+l[f]),y=Ce(m.font),w=bx(r.ctx,y,r._pointLabels[f]);o[f]=w;const A=r.getIndexAngle(f),R=ze(A),O=Eh(R,x.x,w.w,0,180),U=Eh(R,x.y,w.h,90,270);O.start<n.l&&(n.l=O.start,i.l=A),O.end>n.r&&(n.r=O.end,i.r=A),U.start<n.t&&(n.t=U.start,i.t=A),U.end>n.b&&(n.b=U.end,i.b=A)}r._setReductions(r.drawingArea,n,i),r._pointLabelItems=wx(r,o,l)}function wx(r,n,i){const o=[],l=r.getLabels().length,u=r.options,f=Ka(u),m=r.getDistanceFromCenterForValue(u.ticks.reverse?r.min:r.max);for(let x=0;x<l;x++){const y=x===0?f/2:0,w=r.getPointPosition(x,m+y+i[x]),A=ze(r.getIndexAngle(x)),R=n[x],O=Ex(w.y,R.h,A),U=Sx(A),H=Tx(w.x,R.w,U);o.push({x:w.x,y:O,textAlign:U,left:H,top:O,right:H+R.w,bottom:O+R.h})}return o}function Sx(r){return r===0||r===180?"center":r<180?"left":"right"}function Tx(r,n,i){return i==="right"?r-=n:i==="center"&&(r-=n/2),r}function Ex(r,n,i){return i===90||i===270?r-=n/2:(i>270||i<90)&&(r-=n),r}function Ax(r,n){const{ctx:i,options:{pointLabels:o}}=r;for(let l=n-1;l>=0;l--){const u=o.setContext(r.getPointLabelContext(l)),f=Ce(u.font),{x:m,y:x,textAlign:y,left:w,top:A,right:R,bottom:O}=r._pointLabelItems[l],{backdropColor:U}=u;if(!at(U)){const H=je(u.backdropPadding);i.fillStyle=U,i.fillRect(w-H.left,A-H.top,R-w+H.width,O-A+H.height)}Zn(i,r._pointLabels[l],m,x+f.lineHeight/2,f,{color:u.color,textAlign:y,textBaseline:"middle"})}}function Ah(r,n,i,o){const{ctx:l}=r;if(i)l.arc(r.xCenter,r.yCenter,n,0,P);else{let u=r.getPointPosition(0,n);l.moveTo(u.x,u.y);for(let f=1;f<o;f++)u=r.getPointPosition(f,n),l.lineTo(u.x,u.y)}}function Lx(r,n,i,o){const l=r.ctx,u=n.circular,{color:f,lineWidth:m}=n;!u&&!o||!f||!m||i<0||(l.save(),l.strokeStyle=f,l.lineWidth=m,l.setLineDash(n.borderDash),l.lineDashOffset=n.borderDashOffset,l.beginPath(),Ah(r,i,u,o),l.closePath(),l.stroke(),l.restore())}function oo(r){return te(r)?r:0}function Cx(r,n,i){return Object.assign(Object.create(r),{label:i,index:n,type:"pointLabel"})}class Ys extends ro{constructor(n){super(n);this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){const n=this;n.width=n.maxWidth,n.height=n.maxHeight,n.paddingTop=Ka(n.options)/2,n.xCenter=Math.floor(n.width/2),n.yCenter=Math.floor((n.height-n.paddingTop)/2),n.drawingArea=Math.min(n.height-n.paddingTop,n.width)/2}determineDataLimits(){const n=this,{min:i,max:o}=n.getMinMax(!1);n.min=At(i)&&!isNaN(i)?i:0,n.max=At(o)&&!isNaN(o)?o:0,n.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/Ka(this.options))}generateTickLabels(n){const i=this;ro.prototype.generateTickLabels.call(i,n),i._pointLabels=i.getLabels().map((o,l)=>{const u=nt(i.options.pointLabels.callback,[o,l],i);return u||u===0?u:""})}fit(){const n=this,i=n.options;i.display&&i.pointLabels.display?Mx(n):n.setCenterPoint(0,0,0,0)}_setReductions(n,i,o){const l=this;let u=i.l/Math.sin(o.l),f=Math.max(i.r-l.width,0)/Math.sin(o.r),m=-i.t/Math.cos(o.t),x=-Math.max(i.b-(l.height-l.paddingTop),0)/Math.cos(o.b);u=oo(u),f=oo(f),m=oo(m),x=oo(x),l.drawingArea=Math.max(n/2,Math.min(Math.floor(n-(u+f)/2),Math.floor(n-(m+x)/2))),l.setCenterPoint(u,f,m,x)}setCenterPoint(n,i,o,l){const u=this,f=u.width-i-u.drawingArea,m=n+u.drawingArea,x=o+u.drawingArea,y=u.height-u.paddingTop-l-u.drawingArea;u.xCenter=Math.floor((m+f)/2+u.left),u.yCenter=Math.floor((x+y)/2+u.top+u.paddingTop)}getIndexAngle(n){const i=P/this.getLabels().length,o=this.options.startAngle||0;return Me(n*i+ue(o))}getDistanceFromCenterForValue(n){const i=this;if(at(n))return NaN;const o=i.drawingArea/(i.max-i.min);return i.options.reverse?(i.max-n)*o:(n-i.min)*o}getValueForDistanceFromCenter(n){if(at(n))return NaN;const i=this,o=n/(i.drawingArea/(i.max-i.min));return i.options.reverse?i.max-o:i.min+o}getPointLabelContext(n){const i=this,o=i._pointLabels||[];if(n>=0&&n<o.length){const l=o[n];return Cx(i.getContext(),n,l)}}getPointPosition(n,i){const o=this,l=o.getIndexAngle(n)-lt;return{x:Math.cos(l)*i+o.xCenter,y:Math.sin(l)*i+o.yCenter,angle:l}}getPointPositionForValue(n,i){return this.getPointPosition(n,this.getDistanceFromCenterForValue(i))}getBasePosition(n){return this.getPointPositionForValue(n||0,this.getBaseValue())}getPointLabelPosition(n){const{left:i,top:o,right:l,bottom:u}=this._pointLabelItems[n];return{left:i,top:o,right:l,bottom:u}}drawBackground(){const n=this,{backgroundColor:i,grid:{circular:o}}=n.options;if(i){const l=n.ctx;l.save(),l.beginPath(),Ah(n,n.getDistanceFromCenterForValue(n._endValue),o,n.getLabels().length),l.closePath(),l.fillStyle=i,l.fill(),l.restore()}}drawGrid(){const n=this,i=n.ctx,o=n.options,{angleLines:l,grid:u}=o,f=n.getLabels().length;let m,x,y;if(o.pointLabels.display&&Ax(n,f),u.display&&n.ticks.forEach((w,A)=>{if(A!==0){x=n.getDistanceFromCenterForValue(w.value);const R=u.setContext(n.getContext(A-1));Lx(n,R,x,f)}}),l.display){for(i.save(),m=n.getLabels().length-1;m>=0;m--){const w=l.setContext(n.getPointLabelContext(m)),{color:A,lineWidth:R}=w;!R||!A||(i.lineWidth=R,i.strokeStyle=A,i.setLineDash(w.borderDash),i.lineDashOffset=w.borderDashOffset,x=n.getDistanceFromCenterForValue(o.ticks.reverse?n.min:n.max),y=n.getPointPosition(m,x),i.beginPath(),i.moveTo(n.xCenter,n.yCenter),i.lineTo(y.x,y.y),i.stroke())}i.restore()}}drawBorder(){}drawLabels(){const n=this,i=n.ctx,o=n.options,l=o.ticks;if(!l.display)return;const u=n.getIndexAngle(0);let f,m;i.save(),i.translate(n.xCenter,n.yCenter),i.rotate(u),i.textAlign="center",i.textBaseline="middle",n.ticks.forEach((x,y)=>{if(y===0&&!o.reverse)return;const w=l.setContext(n.getContext(y)),A=Ce(w.font);if(f=n.getDistanceFromCenterForValue(n.ticks[y].value),w.showLabelBackdrop){i.font=A.string,m=i.measureText(x.label).width,i.fillStyle=w.backdropColor;const R=je(w.backdropPadding);i.fillRect(-m/2-R.left,-f-A.size/2-R.top,m+R.width,A.size+R.height)}Zn(i,x.label,0,-f,A,{color:w.color})}),i.restore()}drawTitle(){}}Ys.id="radialLinear",Ys.defaults={display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:Ws.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback(r){return r},padding:5}},Ys.defaultRoutes={"angleLines.color":"borderColor","pointLabels.color":"color","ticks.color":"color"},Ys.descriptors={angleLines:{_fallback:"grid"}};const ao={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},nn=Object.keys(ao);function Rx(r,n){return r-n}function Lh(r,n){if(at(n))return null;const i=r._adapter,{parser:o,round:l,isoWeekday:u}=r._parseOpts;let f=n;return typeof o=="function"&&(f=o(f)),At(f)||(f=typeof o=="string"?i.parse(f,o):i.parse(f)),f===null?null:(l&&(f=l==="week"&&(te(u)||u===!0)?i.startOf(f,"isoWeek",u):i.startOf(f,l)),+f)}function Ch(r,n,i,o){const l=nn.length;for(let u=nn.indexOf(r);u<l-1;++u){const f=ao[nn[u]],m=f.steps?f.steps:Number.MAX_SAFE_INTEGER;if(f.common&&Math.ceil((i-n)/(m*f.size))<=o)return nn[u]}return nn[l-1]}function Px(r,n,i,o,l){for(let u=nn.length-1;u>=nn.indexOf(i);u--){const f=nn[u];if(ao[f].common&&r._adapter.diff(l,o,f)>=n-1)return f}return nn[i?nn.indexOf(i):0]}function Dx(r){for(let n=nn.indexOf(r)+1,i=nn.length;n<i;++n)if(ao[nn[n]].common)return nn[n]}function Rh(r,n,i){if(!i)r[n]=!0;else if(i.length){const{lo:o,hi:l}=Fr(i,n),u=i[o]>=n?i[o]:i[l];r[u]=!0}}function Ix(r,n,i,o){const l=r._adapter,u=+l.startOf(n[0].value,o),f=n[n.length-1].value;let m,x;for(m=u;m<=f;m=+l.add(m,1,o))x=i[m],x>=0&&(n[x].major=!0);return n}function Ph(r,n,i){const o=[],l={},u=n.length;let f,m;for(f=0;f<u;++f)m=n[f],l[m]=f,o.push({value:m,major:!1});return u===0||!i?o:Ix(r,o,l,i)}class $s extends Kn{constructor(n){super(n);this._cache={data:[],labels:[],all:[]},this._unit="day",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(n,i){const o=n.time||(n.time={}),l=this._adapter=new Zu._date(n.adapters.date);me(o.displayFormats,l.formats()),this._parseOpts={parser:o.parser,round:o.round,isoWeekday:o.isoWeekday},super.init(n),this._normalized=i.normalized}parse(n,i){return n===void 0?null:Lh(this,n)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const n=this,i=n.options,o=n._adapter,l=i.time.unit||"day";let{min:u,max:f,minDefined:m,maxDefined:x}=n.getUserBounds();function y(w){!m&&!isNaN(w.min)&&(u=Math.min(u,w.min)),!x&&!isNaN(w.max)&&(f=Math.max(f,w.max))}(!m||!x)&&(y(n._getLabelBounds()),(i.bounds!=="ticks"||i.ticks.source!=="labels")&&y(n.getMinMax(!1))),u=At(u)&&!isNaN(u)?u:+o.startOf(Date.now(),l),f=At(f)&&!isNaN(f)?f:+o.endOf(Date.now(),l)+1,n.min=Math.min(u,f-1),n.max=Math.max(u+1,f)}_getLabelBounds(){const n=this.getLabelTimestamps();let i=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY;return n.length&&(i=n[0],o=n[n.length-1]),{min:i,max:o}}buildTicks(){const n=this,i=n.options,o=i.time,l=i.ticks,u=l.source==="labels"?n.getLabelTimestamps():n._generate();i.bounds==="ticks"&&u.length&&(n.min=n._userMin||u[0],n.max=n._userMax||u[u.length-1]);const f=n.min,m=n.max,x=Oc(u,f,m);return n._unit=o.unit||(l.autoSkip?Ch(o.minUnit,n.min,n.max,n._getLabelCapacity(f)):Px(n,x.length,o.minUnit,n.min,n.max)),n._majorUnit=!l.major.enabled||n._unit==="year"?void 0:Dx(n._unit),n.initOffsets(u),i.reverse&&x.reverse(),Ph(n,x,n._majorUnit)}initOffsets(n){const i=this;let o=0,l=0,u,f;i.options.offset&&n.length&&(u=i.getDecimalForValue(n[0]),n.length===1?o=1-u:o=(i.getDecimalForValue(n[1])-u)/2,f=i.getDecimalForValue(n[n.length-1]),n.length===1?l=f:l=(f-i.getDecimalForValue(n[n.length-2]))/2);const m=n.length<3?.5:.25;o=Fe(o,0,m),l=Fe(l,0,m),i._offsets={start:o,end:l,factor:1/(o+1+l)}}_generate(){const n=this,i=n._adapter,o=n.min,l=n.max,u=n.options,f=u.time,m=f.unit||Ch(f.minUnit,o,l,n._getLabelCapacity(o)),x=ft(f.stepSize,1),y=m==="week"?f.isoWeekday:!1,w=te(y)||y===!0,A={};let R=o,O,U;if(w&&(R=+i.startOf(R,"isoWeek",y)),R=+i.startOf(R,w?"day":m),i.diff(l,o,m)>1e5*x)throw new Error(o+" and "+l+" are too far apart with stepSize of "+x+" "+m);const H=u.ticks.source==="data"&&n.getDataTimestamps();for(O=R,U=0;O<l;O=+i.add(O,x,m),U++)Rh(A,O,H);return(O===l||u.bounds==="ticks"||U===1)&&Rh(A,O,H),Object.keys(A).sort((q,Z)=>q-Z).map(q=>+q)}getLabelForValue(n){const i=this,o=i._adapter,l=i.options.time;return l.tooltipFormat?o.format(n,l.tooltipFormat):o.format(n,l.displayFormats.datetime)}_tickFormatFunction(n,i,o,l){const u=this,f=u.options,m=f.time.displayFormats,x=u._unit,y=u._majorUnit,w=x&&m[x],A=y&&m[y],R=o[i],O=y&&A&&R&&R.major,U=u._adapter.format(n,l||(O?A:w)),H=f.ticks.callback;return H?nt(H,[U,i,o],u):U}generateTickLabels(n){let i,o,l;for(i=0,o=n.length;i<o;++i)l=n[i],l.label=this._tickFormatFunction(l.value,i,n)}getDecimalForValue(n){const i=this;return n===null?NaN:(n-i.min)/(i.max-i.min)}getPixelForValue(n){const i=this,o=i._offsets,l=i.getDecimalForValue(n);return i.getPixelForDecimal((o.start+l)*o.factor)}getValueForPixel(n){const i=this,o=i._offsets,l=i.getDecimalForPixel(n)/o.factor-o.end;return i.min+l*(i.max-i.min)}_getLabelSize(n){const i=this,o=i.options.ticks,l=i.ctx.measureText(n).width,u=ue(i.isHorizontal()?o.maxRotation:o.minRotation),f=Math.cos(u),m=Math.sin(u),x=i._resolveTickFontOptions(0).size;return{w:l*f+x*m,h:l*m+x*f}}_getLabelCapacity(n){const i=this,o=i.options.time,l=o.displayFormats,u=l[o.unit]||l.millisecond,f=i._tickFormatFunction(n,0,Ph(i,[n],i._majorUnit),u),m=i._getLabelSize(f),x=Math.floor(i.isHorizontal()?i.width/m.w:i.height/m.h)-1;return x>0?x:1}getDataTimestamps(){const n=this;let i=n._cache.data||[],o,l;if(i.length)return i;const u=n.getMatchingVisibleMetas();if(n._normalized&&u.length)return n._cache.data=u[0].controller.getAllParsedValues(n);for(o=0,l=u.length;o<l;++o)i=i.concat(u[o].controller.getAllParsedValues(n));return n._cache.data=n.normalize(i)}getLabelTimestamps(){const n=this,i=n._cache.labels||[];let o,l;if(i.length)return i;const u=n.getLabels();for(o=0,l=u.length;o<l;++o)i.push(Lh(n,u[o]));return n._cache.labels=n._normalized?i:n.normalize(i)}normalize(n){return ga(n.sort(Rx))}}$s.id="time",$s.defaults={bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",major:{enabled:!1}}};function lo(r,n,i){let o=0,l=r.length-1,u,f,m,x;i?(n>=r[o].pos&&n<=r[l].pos&&({lo:o,hi:l}=Rn(r,"pos",n)),{pos:u,time:m}=r[o],{pos:f,time:x}=r[l]):(n>=r[o].time&&n<=r[l].time&&({lo:o,hi:l}=Rn(r,"time",n)),{time:u,pos:m}=r[o],{time:f,pos:x}=r[l]);const y=f-u;return y?m+(x-m)*(n-u)/y:m}class Qa extends $s{constructor(n){super(n);this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const n=this,i=n._getTimestampsForTable(),o=n._table=n.buildLookupTable(i);n._minPos=lo(o,n.min),n._tableRange=lo(o,n.max)-n._minPos,super.initOffsets(i)}buildLookupTable(n){const{min:i,max:o}=this,l=[],u=[];let f,m,x,y,w;for(f=0,m=n.length;f<m;++f)y=n[f],y>=i&&y<=o&&l.push(y);if(l.length<2)return[{time:i,pos:0},{time:o,pos:1}];for(f=0,m=l.length;f<m;++f)w=l[f+1],x=l[f-1],y=l[f],Math.round((w+x)/2)!==y&&u.push({time:y,pos:f/(m-1)});return u}_getTimestampsForTable(){const n=this;let i=n._cache.all||[];if(i.length)return i;const o=n.getDataTimestamps(),l=n.getLabelTimestamps();return o.length&&l.length?i=n.normalize(o.concat(l)):i=o.length?o:l,i=n._cache.all=i,i}getDecimalForValue(n){return(lo(this._table,n)-this._minPos)/this._tableRange}getValueForPixel(n){const i=this,o=i._offsets,l=i.getDecimalForPixel(n)/o.factor-o.end;return lo(i._table,l*i._tableRange+i._minPos,!0)}}Qa.id="timeseries",Qa.defaults=$s.defaults;var Dh=Object.freeze({__proto__:null,CategoryScale:so,LinearScale:Za,LogarithmicScale:Ja,RadialLinearScale:Ys,TimeScale:$s,TimeSeriesScale:Qa});return Ee.register(eh,Dh,Xa,wh),Ee.helpers=Qs({},Kp),Ee._adapters=Zu,Ee.Animation=Au,Ee.Animations=Ia,Ee.animator=v,Ee.controllers=Pn.controllers.items,Ee.DatasetController=bn,Ee.Element=gn,Ee.elements=Xa,Ee.Interaction=Gc,Ee.layouts=He,Ee.platforms=Tu,Ee.Scale=Kn,Ee.Ticks=Ws,Object.assign(Ee,eh,Dh,Xa,wh,Tu),Ee.Chart=Ee,typeof window!="undefined"&&(window.Chart=Ee),Ee})})(hp);var OT=hp.exports;export{ST as $,bT as A,Nx as B,kT as C,oT as D,qx as E,lT as F,cT as G,aT as H,tr as I,hT as J,vT as K,pT as L,gT as M,er as N,_f as O,CS as P,on as Q,Fn as R,FT as S,rn as T,Zf as U,hS as V,xe as W,Nh as X,fr as Y,OT as Z,RT as _,Zx as a,mT as b,xT as c,Yx as d,$x as e,uT as f,Qx as g,yT as h,IT as i,PT as j,dT as k,fT as l,DT as m,_T as n,s_ as o,LT as p,CT as q,TT as r,Ux as s,sl as t,AT as u,r_ as v,ET as w,i_ as x,wT as y,MT as z};
